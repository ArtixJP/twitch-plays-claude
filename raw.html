<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Rick and Morty 3D Portal Opening - Advanced Graphics Demo</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        #scene-container { width: 100vw; height: 100vh; }
        #episode-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Arial Black', sans-serif;
            font-size: 1rem;
            z-index: 300;
            border: 2px solid rgba(0, 255, 100, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 100, 0.3), inset 0 0 10px rgba(0, 255, 100, 0.1);
        }
        #graphics-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0,255,100,0.2), rgba(100,0,255,0.2));
            color: #00ff88;
            padding: 8px 15px;
            border-radius: 8px;
            font-family: 'Arial', sans-serif;
            font-size: 0.8rem;
            z-index: 300;
            border: 1px solid rgba(0,255,100,0.4);
            text-shadow: 0 0 10px rgba(0,255,100,0.5);
        }
        #gag-text {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: white;
            text-shadow: 2px 2px 4px black;
            text-align: center;
            opacity: 0;
            z-index: 200;
            font-family: 'Arial Black', sans-serif;
            transition: opacity 0.5s;
        }
        .instruction {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #a0aec0;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 300;
            font-family: Arial, sans-serif;
        }
        .instruction code {
            background: rgba(145, 71, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            color: #bf94ff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-family: 'Arial Black', sans-serif;
            font-size: 2rem;
            z-index: 400;
        }
        .speech-bubble {
            position: absolute;
            background: white;
            border-radius: 15px;
            padding: 10px 15px;
            font-family: 'Comic Sans MS', cursive;
            font-size: 0.9rem;
            max-width: 200px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
            z-index: 250;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent transparent;
        }
        .speech-bubble.rick { border: 3px solid #97E5E5; }
        .speech-bubble.morty { border: 3px solid #FFFF00; }
        .speech-bubble.summer { border: 3px solid #5DADE2; }
        .speech-bubble.beth { border: 3px solid #FFC0CB; }
        .speech-bubble.jerry { border: 3px solid #2E8B57; }
    </style>
</head>
<body>
<div id="scene-container"></div>
<div id="graphics-badge">ðŸŽ® FORTNITE x RICK AND MORTY: Battle Royale Island</div>
<div id="episode-counter">Episode: <span id="ep-num">1</span></div>
<div id="gag-text"></div>
<p class="instruction">Type <code>!idea your idea</code> in chat to modify the show!</p>
<div id="loading" style="display:none;">Opening Portal to Dimension C-137...</div>
<div class="speech-bubble rick" id="speech-rick"></div>
<div class="speech-bubble morty" id="speech-morty"></div>
<div class="speech-bubble summer" id="speech-summer"></div>
<div class="speech-bubble beth" id="speech-beth"></div>
<div class="speech-bubble jerry" id="speech-jerry"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/shaders/CopyShader.js"></script>
<script>
        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const noteFreqs = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'A4': 440.00, 'A#4': 466.16,
            'C5': 523.25, 'E5': 659.25, 'F#5': 739.99, 'G5': 783.99, 'A5': 880.00
        };
        
        const melody = [
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A#4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'G4', duration: 0.2}, {note: 'E4', duration: 0.6}
        ];
        
        function playNote(freq, startTime, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.12, startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(startTime);
            osc.stop(startTime + duration);
        }
        
        function playTheme() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            let time = audioCtx.currentTime;
            melody.forEach(({note, duration}) => {
                if (noteFreqs[note]) playNote(noteFreqs[note], time, duration * 0.9);
                time += duration * 0.5;
            });
        }
        
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb); // Bright sky blue - lights on everywhere
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputEncoding = THREE.sRGBEncoding || THREE.LinearEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // Advanced Lighting System
        // Photorealistic Lighting Setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Bright ambient - lights on everywhere
        scene.add(ambientLight);
        
        // Hemisphere light for natural sky/ground bounce
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x88aa88, 1.0); // Bright hemisphere light
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);
        
        // Main key light - simulating sun/studio light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3.0); // Super bright sun
        directionalLight.position.set(10, 25, 15);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);
        
        // Rim light for dramatic edge lighting
        const rimLight = new THREE.DirectionalLight(0x88ccff, 0.8);
        rimLight.position.set(-15, 8, -15);
        scene.add(rimLight);
        
        // Fill light to soften shadows
        const fillLight = new THREE.DirectionalLight(0x4466aa, 0.4);
        fillLight.position.set(-10, 5, 10);
        scene.add(fillLight);
        
        // Bounce light from floor
        const bounceLight = new THREE.DirectionalLight(0x333344, 0.2);
        bounceLight.position.set(0, -10, 0);
        scene.add(bounceLight);
        
        // Portal glow light with realistic falloff
        const portalLight = new THREE.PointLight(0x00ff00, 50, 20, 2);
        portalLight.position.set(-4, 2, 45);
        portalLight.castShadow = true;
        portalLight.shadow.mapSize.width = 1024;
        portalLight.shadow.mapSize.height = 1024;
        scene.add(portalLight);
        
        // Secondary portal glow
        const portalGlow2 = new THREE.PointLight(0x00ff88, 30, 15, 2);
        portalGlow2.position.set(-4, 2, 44);
        scene.add(portalGlow2);
        
        // Volumetric Nebula Particle System
        const nebulaParticles = new THREE.BufferGeometry();
        const nebulaCount = 5000;
        const nebulaPositions = new Float32Array(nebulaCount * 3);
        const nebulaColors = new Float32Array(nebulaCount * 3);
        const nebulaSizes = new Float32Array(nebulaCount);
        
        for (let i = 0; i < nebulaCount; i++) {
            const i3 = i * 3;
            const radius = 20 + Math.random() * 80;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            nebulaPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            nebulaPositions[i3 + 1] = (Math.random() - 0.5) * 40;
            nebulaPositions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta) - 30;
            
            // Color gradient: cyan to magenta to green
            const colorChoice = Math.random();
            if (colorChoice < 0.33) {
                nebulaColors[i3] = 0; nebulaColors[i3 + 1] = 1; nebulaColors[i3 + 2] = 0.5;
            } else if (colorChoice < 0.66) {
                nebulaColors[i3] = 0.5; nebulaColors[i3 + 1] = 0; nebulaColors[i3 + 2] = 1;
            } else {
                nebulaColors[i3] = 0; nebulaColors[i3 + 1] = 0.8; nebulaColors[i3 + 2] = 1;
            }
            
            nebulaSizes[i] = 0.5 + Math.random() * 2;
        }
        
        nebulaParticles.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
        nebulaParticles.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
        nebulaParticles.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
        
        const nebulaMaterial = new THREE.PointsMaterial({
            size: 1.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const nebula = new THREE.Points(nebulaParticles, nebulaMaterial);
        scene.add(nebula);
        window.nebula = nebula;
        
        // Glowing Stars with Bloom
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            starPositions[i3] = (Math.random() - 0.5) * 200;
            starPositions[i3 + 1] = (Math.random() - 0.5) * 100 + 20;
            starPositions[i3 + 2] = (Math.random() - 0.5) * 200 - 50;
            
            const brightness = 0.5 + Math.random() * 0.5;
            starColors[i3] = brightness;
            starColors[i3 + 1] = brightness;
            starColors[i3 + 2] = brightness + Math.random() * 0.3;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        
        const starMaterial = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        window.stars = stars;
        
        // Energy Ring Effect
        const ringCount = 5;
        const energyRings = [];
        for (let r = 0; r < ringCount; r++) {
            const ringGeo = new THREE.TorusGeometry(3 + r * 1.5, 0.05, 8, 64);
            const ringMat = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.3 + r * 0.1, 1, 0.5),
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.set(-4, 2, 45);
            ring.userData.speed = 0.5 + r * 0.2;
            ring.userData.axis = r % 2 === 0 ? 'x' : 'y';
            scene.add(ring);
            energyRings.push(ring);
        }
        window.energyRings = energyRings;
        
        // PBR Photorealistic Materials
        const yellowMat = new THREE.MeshStandardMaterial({ 
            color: 0xAFE1AF, 
            roughness: 0.7, 
            metalness: 0.0,
            envMapIntensity: 0.5
        }); // Rick's skin tone
        const whiteMat = new THREE.MeshStandardMaterial({ 
            color: 0xE8EDF2, 
            roughness: 0.8, 
            metalness: 0.0,
            envMapIntensity: 0.3
        }); // Lab coat - fabric
        const blueMat = new THREE.MeshStandardMaterial({ 
            color: 0x97E5E5, 
            roughness: 0.6, 
            metalness: 0.1,
            envMapIntensity: 0.4
        }); // Rick's hair
        const greenMat = new THREE.MeshStandardMaterial({ 
            color: 0x00FF00, 
            roughness: 0.2, 
            metalness: 0.8,
            emissive: 0x003300,
            emissiveIntensity: 0.5
        }); // Portal green
        const orangeMat = new THREE.MeshStandardMaterial({ 
            color: 0xFFFF00, 
            roughness: 0.75, 
            metalness: 0.0
        }); // Morty's shirt
        const redMat = new THREE.MeshStandardMaterial({ 
            color: 0x8B0000, 
            roughness: 0.7, 
            metalness: 0.0
        }); // Morty's pants
        const babyBlueMat = new THREE.MeshStandardMaterial({ 
            color: 0x5DADE2, 
            roughness: 0.65, 
            metalness: 0.0
        }); // Summer
        const couchMat = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a2a, 
            roughness: 0.9, 
            metalness: 0.1,
            envMapIntensity: 0.2
        }); // Garage workbench - worn metal
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0x3a3a3a, 
            roughness: 0.95, 
            metalness: 0.0
        }); // Garage floor - concrete
        const wallMat = new THREE.MeshStandardMaterial({ 
            color: 0x606060, 
            roughness: 0.85, 
            metalness: 0.0
        }); // Garage wall
        const cloudMat = new THREE.MeshStandardMaterial({ 
            color: 0x00FF00, 
            transparent: true, 
            opacity: 0.6,
            emissive: 0x00FF00,
            emissiveIntensity: 0.3,
            roughness: 1.0
        }); // Portal clouds
        const portalMat = new THREE.MeshStandardMaterial({ 
            color: 0x00FF00, 
            transparent: true, 
            opacity: 0.8,
            emissive: 0x00FF00,
            emissiveIntensity: 1.0,
            roughness: 0.0,
            metalness: 1.0
        });
        
        // Create HDR-like environment for reflections
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        
        // Create a gradient environment texture
        const envScene = new THREE.Scene();
        const envGeo = new THREE.SphereGeometry(50, 32, 32);
        const envGradient = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0a0a2e) },
                bottomColor: { value: new THREE.Color(0x000011) },
                offset: { value: 10 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const envMesh = new THREE.Mesh(envGeo, envGradient);
        envScene.add(envMesh);
        
        // Add some bright spots for reflections
        const brightSpots = new THREE.Group();
        for (let i = 0; i < 20; i++) {
            const spot = new THREE.Mesh(
                new THREE.SphereGeometry(2 + Math.random() * 3, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.4, 0.8, 0.6)
                })
            );
            spot.position.set(
                (Math.random() - 0.5) * 80,
                Math.random() * 30 + 10,
                (Math.random() - 0.5) * 80
            );
            brightSpots.add(spot);
        }
        envScene.add(brightSpots);
        
        const envRenderTarget = pmremGenerator.fromScene(envScene, 0.04);
        scene.environment = envRenderTarget.texture;
        
        // Create clouds
        const clouds = [];
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(1 + Math.random(), 16, 16),
                    cloudMat
                );
                sphere.position.set(Math.random() * 2 - 1, Math.random() * 0.5, Math.random() * 2 - 1);
                cloud.add(sphere);
            }
            cloud.position.set(x, y, z);
            cloud.userData = { speed: 0.01 + Math.random() * 0.02 };
            scene.add(cloud);
            clouds.push(cloud);
        }
        
        for (let i = 0; i < 20; i++) {
            createCloud(
                Math.random() * 60 - 30,
                5 + Math.random() * 10,
                Math.random() * 40 - 50
            );
        }
        
        // Create 3D Title
        const titleGroup = new THREE.Group();
        const titleGeo = new THREE.BoxGeometry(12, 2, 0.5);
        const titleMesh = new THREE.Mesh(titleGeo, yellowMat);
        titleGroup.add(titleMesh);
        
        // Add "RICK AND MORTY" text using boxes
        const letters = 'RICK & MORTY';
        for (let i = 0; i < letters.length; i++) {
            if (letters[i] !== ' ') {
                const letterBox = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                letterBox.position.set(-5 + i * 0.85, 0, 0.4);
                titleGroup.add(letterBox);
            }
        }
        titleGroup.position.set(0, 20, -30);
        scene.add(titleGroup);
        
        // Create character function with PBR materials
        function createCharacter(bodyColor, headHeight = 0.5, bodyHeight = 0.6, scale = 1) {
            const character = new THREE.Group();
            
            // Skin material for heads - subsurface scattering simulation
            const skinMat = new THREE.MeshStandardMaterial({ 
                color: 0xDEB887, 
                roughness: 0.65, 
                metalness: 0.0,
                envMapIntensity: 0.3
            });
            
            // Head with higher geometry for smoother look
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4 * scale, 32, 32), skinMat);
            head.position.y = bodyHeight + 0.4 * scale;
            head.castShadow = true;
            head.receiveShadow = true;
            character.add(head);
            
            // Body with higher geometry
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, bodyHeight, 32),
                bodyColor
            );
            body.position.y = bodyHeight / 2;
            body.castShadow = true;
            body.receiveShadow = true;
            character.add(body);
            
            // Legs with shadows
            const legMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a3a, 
                roughness: 0.8, 
                metalness: 0.0 
            });
            const legGeo = new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 0.4 * scale, 16);
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.12 * scale, -0.2 * scale, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            character.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.12 * scale, -0.2 * scale, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            character.add(rightLeg);
            
            return character;
        }
        
        // Create family
        const homer = createCharacter(whiteMat, 0.5, 0.7, 1.1); // Rick
        // Add Rick's spiky blue hair
        const rickHair = new THREE.Mesh(
            new THREE.ConeGeometry(0.35, 0.6, 8),
            blueMat
        );
        rickHair.position.y = 1.5;
        rickHair.rotation.z = 0.3;
        homer.add(rickHair);
        const rickHair2 = new THREE.Mesh(
            new THREE.ConeGeometry(0.25, 0.5, 8),
            blueMat
        );
        rickHair2.position.set(0.2, 1.4, 0);
        rickHair2.rotation.z = -0.4;
        homer.add(rickHair2);
        
        const marge = createCharacter(orangeMat, 0.5, 0.6, 0.85); // Morty
        // Morty's brown curly hair
        const mortyHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        mortyHair.position.y = 1.15;
        mortyHair.scale.set(1, 0.6, 1);
        marge.add(mortyHair);
        
        const bart = createCharacter(babyBlueMat, 0.4, 0.5, 0.85); // Summer
        // Summer's ponytail
        const summerHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0xFFB347 })
        );
        summerHair.position.y = 1.05;
        bart.add(summerHair);
        const ponytail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.15, 0.4, 8),
            new THREE.MeshLambertMaterial({ color: 0xFFB347 })
        );
        ponytail.position.set(0, 1.1, -0.2);
        ponytail.rotation.x = 0.5;
        bart.add(ponytail);
        
        const lisa = createCharacter(new THREE.MeshLambertMaterial({ color: 0xFFC0CB }), 0.35, 0.4, 0.9); // Beth
        // Beth's blonde hair
        const bethHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0xF0E68C })
        );
        bethHair.position.y = 0.95;
        bethHair.scale.set(1, 0.7, 1);
        lisa.add(bethHair);
        
        const maggie = createCharacter(new THREE.MeshLambertMaterial({ color: 0x2E8B57 }), 0.3, 0.5, 0.95); // Jerry
        // Jerry's boring hair
        const jerryHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        jerryHair.position.y = 1.1;
        jerryHair.scale.set(1, 0.5, 1);
        maggie.add(jerryHair);
        
        const family = [homer, marge, bart, lisa, maggie];
        family.forEach((char, i) => {
            char.position.set(-2 + i * 2, 0, 0);
            char.visible = true; // Always visible - continuous scene
            scene.add(char);
        });
        
        // FORTNITE MAP - Enormous Battle Royale Island
        const fortniteMap = new THREE.Group();
        
        // Massive island terrain
        const islandMat = new THREE.MeshStandardMaterial({ 
            color: 0x4a7c3f, 
            roughness: 0.9, 
            metalness: 0.0,
            envMapIntensity: 0.2
        });
        const islandGeo = new THREE.PlaneGeometry(500, 500, 100, 100);
        // Add terrain displacement
        const islandPositions = islandGeo.attributes.position;
        for (let i = 0; i < islandPositions.count; i++) {
            const x = islandPositions.getX(i);
            const y = islandPositions.getY(i);
            const height = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 8 + 
                          Math.sin(x * 0.05 + y * 0.03) * 3 +
                          Math.random() * 0.5;
            islandPositions.setZ(i, height);
        }
        islandGeo.computeVertexNormals();
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.rotation.x = -Math.PI / 2;
        island.position.y = -5;
        island.receiveShadow = true;
        fortniteMap.add(island);
        
        // Beach/water around island
        const waterMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a6b9c, 
            roughness: 0.1, 
            metalness: 0.3,
            transparent: true,
            opacity: 0.85
        });
        const water = new THREE.Mesh(
            new THREE.PlaneGeometry(800, 800),
            waterMat
        );
        water.rotation.x = -Math.PI / 2;
        water.position.y = -8;
        fortniteMap.add(water);
        
        // TILTED TOWERS - Iconic POI
        const tiltedTowers = new THREE.Group();
        const buildingMat = new THREE.MeshStandardMaterial({ color: 0x666680, roughness: 0.7, metalness: 0.2 });
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.8, emissive: 0x224466, emissiveIntensity: 0.3 });
        
        for (let i = 0; i < 12; i++) {
            const height = 15 + Math.random() * 35;
            const width = 4 + Math.random() * 6;
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, width),
                buildingMat
            );
            building.position.set(
                (Math.random() - 0.5) * 40,
                height / 2 - 5,
                (Math.random() - 0.5) * 40
            );
            building.castShadow = true;
            building.receiveShadow = true;
            tiltedTowers.add(building);
            
            // Windows
            for (let w = 0; w < Math.floor(height / 3); w++) {
                const windowRow = new THREE.Mesh(
                    new THREE.BoxGeometry(width * 0.8, 0.5, 0.1),
                    windowMat
                );
                windowRow.position.set(
                    building.position.x,
                    w * 3 - 3,
                    building.position.z + width / 2
                );
                tiltedTowers.add(windowRow);
            }
        }
        tiltedTowers.position.set(-80, 0, -60);
        fortniteMap.add(tiltedTowers);
        
        // PLEASANT PARK - Suburban houses
        const pleasantPark = new THREE.Group();
        const houseMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.8 });
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
        
        for (let hx = 0; hx < 4; hx++) {
            for (let hz = 0; hz < 3; hz++) {
                const house = new THREE.Group();
                const houseBody = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 5, 6),
                    houseMat
                );
                houseBody.position.y = 2.5;
                houseBody.castShadow = true;
                house.add(houseBody);
                
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(6, 3, 4),
                    roofMat
                );
                roof.position.y = 6.5;
                roof.rotation.y = Math.PI / 4;
                house.add(roof);
                
                house.position.set(hx * 20 - 30, -5, hz * 18 - 25);
                pleasantPark.add(house);
            }
        }
        pleasantPark.position.set(100, 0, 80);
        fortniteMap.add(pleasantPark);
        
        // LOOT LAKE - Center lake with floating island
        const lootLake = new THREE.Mesh(
            new THREE.CircleGeometry(40, 32),
            new THREE.MeshStandardMaterial({ color: 0x2288aa, roughness: 0.1, metalness: 0.2, transparent: true, opacity: 0.9 })
        );
        lootLake.rotation.x = -Math.PI / 2;
        lootLake.position.set(0, -4, 0);
        fortniteMap.add(lootLake);
        
        // Floating island (Kevin reference)
        const floatingIsland = new THREE.Mesh(
            new THREE.DodecahedronGeometry(12, 1),
            new THREE.MeshStandardMaterial({ color: 0x6b4c9a, roughness: 0.6, emissive: 0x3a2a5a, emissiveIntensity: 0.3 })
        );
        floatingIsland.position.set(0, 15, 0);
        fortniteMap.add(floatingIsland);
        
        // STORM CIRCLE - Purple deadly storm
        const stormGeometry = new THREE.CylinderGeometry(200, 200, 100, 64, 1, true);
        const stormMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x6633aa, 
            transparent: true, 
            opacity: 0.3, 
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        const stormWall = new THREE.Mesh(stormGeometry, stormMaterial);
        stormWall.position.y = 30;
        fortniteMap.add(stormWall);
        window.stormWall = stormWall;
        
        // Storm particles
        const stormParticles = new THREE.BufferGeometry();
        const stormCount = 2000;
        const stormPos = new Float32Array(stormCount * 3);
        for (let i = 0; i < stormCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 180 + Math.random() * 40;
            stormPos[i * 3] = Math.cos(angle) * radius;
            stormPos[i * 3 + 1] = Math.random() * 80;
            stormPos[i * 3 + 2] = Math.sin(angle) * radius;
        }
        stormParticles.setAttribute('position', new THREE.BufferAttribute(stormPos, 3));
        const stormPtsMat = new THREE.PointsMaterial({ color: 0x9966ff, size: 2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
        const stormPts = new THREE.Points(stormParticles, stormPtsMat);
        fortniteMap.add(stormPts);
        window.stormPts = stormPts;
        
        // BATTLE BUS in sky
        const battleBus = new THREE.Group();
        const busBody = new THREE.Mesh(
            new THREE.BoxGeometry(4, 3, 8),
            new THREE.MeshStandardMaterial({ color: 0x3377cc, roughness: 0.5 })
        );
        battleBus.add(busBody);
        const busBalloon = new THREE.Mesh(
            new THREE.SphereGeometry(6, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x4488ff, roughness: 0.3, transparent: true, opacity: 0.9 })
        );
        busBalloon.position.y = 8;
        battleBus.add(busBalloon);
        // Balloon strings
        for (let s = 0; s < 4; s++) {
            const string = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 6, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            string.position.set((s % 2 - 0.5) * 2, 4, (Math.floor(s / 2) - 0.5) * 3);
            battleBus.add(string);
        }
        battleBus.position.set(-150, 80, -150);
        fortniteMap.add(battleBus);
        window.battleBus = battleBus;
        
        // SUPPLY DROPS
        const supplyDrops = [];
        for (let d = 0; d < 5; d++) {
            const drop = new THREE.Group();
            const crate = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.4, emissive: 0xaa8800, emissiveIntensity: 0.3 })
            );
            drop.add(crate);
            const dropChute = new THREE.Mesh(
                new THREE.SphereGeometry(2.5, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x4488ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
            );
            dropChute.rotation.x = Math.PI;
            dropChute.position.y = 3;
            drop.add(dropChute);
            // Light beam
            const beam = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 2, 30, 8, 1, true),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
            );
            beam.position.y = -15;
            drop.add(beam);
            
            drop.position.set(
                (Math.random() - 0.5) * 200,
                40 + Math.random() * 20,
                (Math.random() - 0.5) * 200
            );
            drop.userData.fallSpeed = 0.1 + Math.random() * 0.1;
            fortniteMap.add(drop);
            supplyDrops.push(drop);
        }
        window.supplyDrops = supplyDrops;
        
        // RIFT IN SKY (Portal replacement)
        const rift = new THREE.Group();
        const riftCore = new THREE.Mesh(
            new THREE.TorusGeometry(8, 2, 16, 32),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })
        );
        rift.add(riftCore);
        const riftCenter = new THREE.Mesh(
            new THREE.CircleGeometry(6, 32),
            new THREE.MeshBasicMaterial({ color: 0xaaffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
        );
        rift.add(riftCenter);
        // Rift particles
        for (let rp = 0; rp < 50; rp++) {
            const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            spark.position.set(
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 5
            );
            spark.userData.angle = Math.random() * Math.PI * 2;
            spark.userData.speed = 1 + Math.random() * 2;
            spark.userData.radius = 5 + Math.random() * 5;
            rift.add(spark);
        }
        rift.position.set(0, 60, 0);
        rift.rotation.x = -Math.PI / 4;
        fortniteMap.add(rift);
        window.rift = rift;
        
        // Victory Royale sign (hidden initially)
        const victorySign = new THREE.Group();
        const signBack = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            new THREE.MeshBasicMaterial({ color: 0xffdd00, transparent: true, opacity: 0.9 })
        );
        victorySign.add(signBack);
        victorySign.position.set(0, 40, -50);
        victorySign.visible = false;
        fortniteMap.add(victorySign);
        window.victorySign = victorySign;
        
        // Reference old couch for gag system compatibility
        const couch = new THREE.Group();
        fortniteMap.add(couch);
        
        // Reference livingRoom as fortniteMap for compatibility
        const livingRoom = fortniteMap;
        livingRoom.position.set(0, 0, 50);
        livingRoom.visible = true; // Always visible - continuous scene
        scene.add(livingRoom);
        
        // Pentagram and Satan summoning ritual
        const pentagramGroup = new THREE.Group();
        
        // Create pentagram using lines
        const pentagramMat = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 3 });
        const pentagramPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            pentagramPoints.push(new THREE.Vector3(Math.cos(angle) * 2, 0.01, Math.sin(angle) * 2));
        }
        const pentagramGeo = new THREE.BufferGeometry().setFromPoints(pentagramPoints);
        const pentagram = new THREE.Line(pentagramGeo, pentagramMat);
        pentagramGroup.add(pentagram);
        
        // Pentagram inner star
        const starPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = ((i * 2) % 5 * 2 * Math.PI / 5) - Math.PI / 2;
            starPoints.push(new THREE.Vector3(Math.cos(angle) * 2, 0.02, Math.sin(angle) * 2));
        }
        const starGeo = new THREE.BufferGeometry().setFromPoints(starPoints);
        const star = new THREE.Line(starGeo, pentagramMat);
        pentagramGroup.add(star);
        
        // Blood pool
        const bloodPool = new THREE.Mesh(
            new THREE.CircleGeometry(2.5, 32),
            new THREE.MeshBasicMaterial({ color: 0x8B0000, transparent: true, opacity: 0.7 })
        );
        bloodPool.rotation.x = -Math.PI / 2;
        bloodPool.position.y = 0.005;
        pentagramGroup.add(bloodPool);
        
        // Fire pillars at pentagram points
        const firePillars = [];
        for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            const fireGroup = new THREE.Group();
            
            // Fire base
            const fireBase = new THREE.Mesh(
                new THREE.ConeGeometry(0.3, 1.5, 8),
                new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0.9 })
            );
            fireBase.position.y = 0.75;
            fireGroup.add(fireBase);
            
            // Inner flame
            const innerFlame = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 1, 8),
                new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.8 })
            );
            innerFlame.position.y = 0.5;
            fireGroup.add(innerFlame);
            
            // Point light for glow
            const fireLight = new THREE.PointLight(0xFF4500, 1, 5);
            fireLight.position.y = 1;
            fireGroup.add(fireLight);
            
            fireGroup.position.set(Math.cos(angle) * 2.3, 0, Math.sin(angle) * 2.3);
            pentagramGroup.add(fireGroup);
            firePillars.push(fireGroup);
        }
        
        // SATAN - Interdimensional Demon Entity
        const satan = new THREE.Group();
        
        // Demonic body
        const demonBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.7, 2, 16),
            new THREE.MeshLambertMaterial({ color: 0x8B0000 })
        );
        demonBody.position.y = 1;
        satan.add(demonBody);
        
        // Demon head
        const demonHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshLambertMaterial({ color: 0x660000 })
        );
        demonHead.position.y = 2.5;
        satan.add(demonHead);
        
        // Horns
        const hornMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
        const leftHorn = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8, 8), hornMat);
        leftHorn.position.set(-0.3, 3, 0);
        leftHorn.rotation.z = 0.4;
        satan.add(leftHorn);
        
        const rightHorn = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8, 8), hornMat);
        rightHorn.position.set(0.3, 3, 0);
        rightHorn.rotation.z = -0.4;
        satan.add(rightHorn);
        
        // Glowing eyes
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), eyeMat);
        leftEye.position.set(-0.2, 2.6, 0.4);
        satan.add(leftEye);
        
        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), eyeMat);
        rightEye.position.set(0.2, 2.6, 0.4);
        satan.add(rightEye);
        
        // Wings
        const wingMat = new THREE.MeshLambertMaterial({ color: 0x330000, side: THREE.DoubleSide });
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(1.5, 1);
        wingShape.lineTo(2, 0.5);
        wingShape.lineTo(1.8, -0.5);
        wingShape.lineTo(0, -0.2);
        const wingGeo = new THREE.ShapeGeometry(wingShape);
        
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-0.5, 2, -0.3);
        leftWing.rotation.y = -0.5;
        satan.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(0.5, 2, -0.3);
        rightWing.rotation.y = Math.PI + 0.5;
        rightWing.scale.x = -1;
        satan.add(rightWing);
        
        // Trident
        const tridentStaff = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 3, 8),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        tridentStaff.position.set(0.8, 1.5, 0);
        satan.add(tridentStaff);
        
        const tridentHead = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.5, 3),
            new THREE.MeshLambertMaterial({ color: 0x8B0000 })
        );
        tridentHead.position.set(0.8, 3.2, 0);
        satan.add(tridentHead);
        
        satan.position.y = -3;
        satan.visible = false;
        pentagramGroup.add(satan);
        
        pentagramGroup.position.set(0, -0.4, 48);
        pentagramGroup.visible = true; // Always visible - continuous scene
        satan.visible = true; // Satan always visible too
        scene.add(pentagramGroup);
        
        // Store references for animation
        window.pentagramGroup = pentagramGroup;
        window.satan = satan;
        window.firePillars = firePillars;
        
        // Helicopter
        const helicopter = new THREE.Group();
        
        // Helicopter body
        const heliBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 1, 3, 16),
            new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
        );
        heliBody.rotation.z = Math.PI / 2;
        helicopter.add(heliBody);
        
        // Cockpit
        const cockpit = new THREE.Mesh(
            new THREE.SphereGeometry(0.7, 16, 16),
            new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 })
        );
        cockpit.position.set(1.5, 0.2, 0);
        helicopter.add(cockpit);
        
        // Tail
        const heliTail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.4, 2.5, 8),
            new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
        );
        heliTail.rotation.z = Math.PI / 2;
        heliTail.position.set(-2.5, 0, 0);
        helicopter.add(heliTail);
        
        // Main rotor
        const rotorHub = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 0.3, 8),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        rotorHub.position.y = 1;
        helicopter.add(rotorHub);
        
        const rotorBlades = new THREE.Group();
        for (let i = 0; i < 4; i++) {
            const blade = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.05, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x444444 })
            );
            blade.rotation.y = (i * Math.PI) / 2;
            rotorBlades.add(blade);
        }
        rotorBlades.position.y = 1.2;
        helicopter.add(rotorBlades);
        
        // Tail rotor
        const tailRotor = new THREE.Group();
        for (let i = 0; i < 2; i++) {
            const tBlade = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.03, 0.1),
                new THREE.MeshLambertMaterial({ color: 0x444444 })
            );
            tBlade.rotation.y = (i * Math.PI) / 2;
            tailRotor.add(tBlade);
        }
        tailRotor.position.set(-3.5, 0.3, 0.3);
        tailRotor.rotation.x = Math.PI / 2;
        helicopter.add(tailRotor);
        
        // Skids
        const skidMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const leftSkid = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), skidMat);
        leftSkid.rotation.z = Math.PI / 2;
        leftSkid.position.set(0, -0.8, -0.5);
        helicopter.add(leftSkid);
        const rightSkid = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), skidMat);
        rightSkid.rotation.z = Math.PI / 2;
        rightSkid.position.set(0, -0.8, 0.5);
        helicopter.add(rightSkid);
        
        helicopter.position.set(0, 25, 45);
        helicopter.visible = true; // Always visible - continuous scene
        scene.add(helicopter);
        
        // Parachutes for each family member
        const parachutes = [];
        const chuteColors = [0x97E5E5, 0xFFFF00, 0x5DADE2, 0xFFC0CB, 0x2E8B57];
        for (let i = 0; i < 5; i++) {
            const chute = new THREE.Group();
            
            // Canopy
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshLambertMaterial({ color: chuteColors[i], side: THREE.DoubleSide, transparent: true, opacity: 0.85 })
            );
            canopy.rotation.x = Math.PI;
            canopy.position.y = 2;
            chute.add(canopy);
            
            // Strings
            const stringMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            for (let j = 0; j < 8; j++) {
                const angle = (j / 8) * Math.PI * 2;
                const points = [
                    new THREE.Vector3(Math.cos(angle) * 1, 2, Math.sin(angle) * 1),
                    new THREE.Vector3(0, 0, 0)
                ];
                const stringGeo = new THREE.BufferGeometry().setFromPoints(points);
                const string = new THREE.Line(stringGeo, stringMat);
                chute.add(string);
            }
            
            chute.visible = false;
            chute.scale.set(0.5, 0.5, 0.5);
            scene.add(chute);
            parachutes.push(chute);
        }
        
        window.helicopter = helicopter;
        window.rotorBlades = rotorBlades;
        window.tailRotor = tailRotor;
        window.parachutes = parachutes;
        
        // Grass ground with realistic material
        const grassMat = new THREE.MeshStandardMaterial({ 
            color: 0x2d5a27, 
            roughness: 0.9, 
            metalness: 0.0,
            envMapIntensity: 0.15
        });
        const grassGround = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100, 50, 50),
            grassMat
        );
        grassGround.rotation.x = -Math.PI / 2;
        grassGround.position.y = -1;
        grassGround.receiveShadow = true;
        scene.add(grassGround);
        
        // Add subtle ground displacement for realism
        const grassPositions = grassGround.geometry.attributes.position;
        for (let i = 0; i < grassPositions.count; i++) {
            const x = grassPositions.getX(i);
            const y = grassPositions.getY(i);
            grassPositions.setZ(i, Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.2);
        }
        grassGround.geometry.computeVertexNormals();
        
        // Camera initial position
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 5, 0);
        
        // Post-processing setup (Bloom effect)
        let composer;
        try {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8,  // strength - reduced for photorealism
                0.6,  // radius - wider for softer glow
                0.92  // threshold - higher for more selective bloom
            );
            composer.addPass(bloomPass);
            window.composer = composer;
            window.bloomPass = bloomPass;
        } catch(e) {
            console.log('Post-processing not available, using standard rendering');
            composer = null;
        }
        
        // Animation state
        let phase = 'continuous'; // Single continuous scene mode
        let animationTime = 0;
        let episodeCount = 0;
        
        // Speech synthesis setup
        const synth = window.speechSynthesis;
        const voices = {
            rick: { pitch: 0.8, rate: 1.3 },
            morty: { pitch: 1.4, rate: 1.1 },
            summer: { pitch: 1.3, rate: 1.0 },
            beth: { pitch: 1.2, rate: 0.95 },
            jerry: { pitch: 0.9, rate: 0.85 }
        };
        
        const dialogues = {
            rick: [
                "Morty! *burp* We gotta go, Morty!",
                "I'm pickle Riiick! Wait, no I'm not.",
                "Wubba lubba dub dub!",
                "Science isn't about WHY, it's about WHY NOT!",
                "I turned myself into a couch potato, Morty!",
                "The universe is basically an animal. It grazes on the ordinary.",
                "Nobody exists on purpose. Watch TV."
            ],
            morty: [
                "Aw geez, Rick!",
                "I-I don't know about this, Rick!",
                "Oh man, oh geez, oh man!",
                "This is getting out of hand!",
                "Rick, I don't think this is a good idea!",
                "W-what are we even doing here, Rick?",
                "I'm in constant pain, Rick!"
            ],
            summer: [
                "Ugh, you guys are so embarrassing.",
                "This is literally the worst.",
                "I can't even right now.",
                "Mom! Grandpa's being weird again!",
                "Whatever, I'm going to my room.",
                "This family is SO dysfunctional."
            ],
            beth: [
                "Dad, please don't traumatize the kids.",
                "I'm a horse surgeon, not a therapist.",
                "Wine. I need wine.",
                "Jerry, this is your fault somehow.",
                "I'm the smart one in this family.",
                "At least I'm not Jerry."
            ],
            jerry: [
                "Can someone explain what's happening?",
                "I think I'm contributing!",
                "Nobody respects me in this house.",
                "I have a job interview... in my dreams.",
                "This is fine. Everything is fine.",
                "I'm not useless! I can... uh...",
                "Pluto IS a planet!"
            ]
        };
        
        function speak(character, text) {
            if (synth.speaking) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.pitch = voices[character].pitch;
            utterance.rate = voices[character].rate;
            utterance.volume = 0.7;
            synth.speak(utterance);
        }
        
        function showSpeechBubble(character, index) {
            const charNames = ['rick', 'morty', 'summer', 'beth', 'jerry'];
            const name = charNames[index];
            const bubble = document.getElementById('speech-' + name);
            const text = dialogues[name][Math.floor(Math.random() * dialogues[name].length)];
            
            bubble.textContent = text;
            bubble.style.opacity = '1';
            
            // Position based on character screen position
            const positions = [
                { left: '15%', top: '35%' },
                { left: '30%', top: '40%' },
                { left: '45%', top: '38%' },
                { left: '60%', top: '42%' },
                { left: '75%', top: '36%' }
            ];
            bubble.style.left = positions[index].left;
            bubble.style.top = positions[index].top;
            
            speak(name, text);
            
            setTimeout(() => {
                bubble.style.opacity = '0';
            }, 3000);
        }
        
        let dialogueTimer = 0;
        let lastSpeaker = -1;
        
        const couchGags = [
            { text: "WHERE WE DROPPIN' BOYS?!", action: 'fortnite_drop' },
            { text: "TILTED TOWERS! LET'S GO!", action: 'tilted_chaos' },
            { text: "STORM'S CLOSING IN!", action: 'storm_run' },
            { text: "SUPPLY DROP INCOMING!", action: 'supply_hunt' },
            { text: "VICTORY ROYALE!", action: 'victory' },
            { text: "THEY SUMMONED SOMETHING FROM DIMENSION 666!", action: 'satan' },
            { text: "JUMP! JUMP! JUMP!", action: 'skydive' },
            { text: "BUILD BATTLE!", action: 'build_fight' },
            { text: "RIFT ZONE ACTIVATED!", action: 'rift_zone' },
            { text: "DEFAULT DANCE TIME!", action: 'default_dance' }
        ];
        
        let currentGag = couchGags[0];
        let gagStartTime = 0;
        
        function startEpisode() {
            episodeCount++;
            document.getElementById('ep-num').textContent = episodeCount;
            document.getElementById('gag-text').style.opacity = '0';
            
            phase = 'clouds';
            animationTime = 0;
            
            // Reset title
            titleGroup.position.set(0, 20, -30);
            titleGroup.rotation.set(0, 0, 0);
            
            // Reset family
            family.forEach((char, i) => {
                char.position.set(20 + i * 2, 0, 0);
                char.rotation.set(0, 0, 0);
                char.scale.set(1, 1, 1);
                char.visible = false;
            });
            
            // Reset couch
            couch.position.set(0, 0, 0);
            couch.rotation.set(0, 0, 0);
            couch.scale.set(1, 1, 1);
            
            livingRoom.visible = false;
            grassGround.visible = true;
            
            // Reset camera
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 5, 0);
            
            currentGag = couchGags[Math.floor(Math.random() * couchGags.length)];
            
            // Reset dialogue
            dialogueTimer = 0;
            lastSpeaker = -1;
            ['rick', 'morty', 'summer', 'beth', 'jerry'].forEach(name => {
                document.getElementById('speech-' + name).style.opacity = '0';
            });
            
            // Reset pentagram and satan
            if (window.pentagramGroup) {
                window.pentagramGroup.visible = false;
                window.satan.visible = false;
                window.satan.position.y = -3;
            }
            
            // Reset helicopter and parachutes
            if (window.helicopter) {
                window.helicopter.visible = false;
                window.parachutes.forEach(chute => {
                    chute.visible = false;
                    chute.scale.set(0.5, 0.5, 0.5);
                });
            }
            renderer.setClearColor(0x0a0a2e);
            
            playTheme();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            animationTime += 0.016;
            
            // Animate clouds
            clouds.forEach(cloud => {
                cloud.position.x -= cloud.userData.speed;
                if (cloud.position.x < -35) cloud.position.x = 35;
            });
            
            // CONTINUOUS SCENE MODE - Everything runs together
            if (phase === 'continuous') {
                // Smooth camera orbit around the entire scene
                const orbitRadius = 80;
                const orbitSpeed = 0.1;
                camera.position.x = Math.cos(animationTime * orbitSpeed) * orbitRadius;
                camera.position.z = Math.sin(animationTime * orbitSpeed) * orbitRadius + 25;
                camera.position.y = 30 + Math.sin(animationTime * 0.2) * 10;
                camera.lookAt(0, 5, 25);
                
                // Animate family dancing
                family.forEach((char, i) => {
                    char.position.y = 0.5 + Math.abs(Math.sin(animationTime * 4 + i)) * 0.5;
                    char.rotation.y = Math.sin(animationTime * 2 + i) * 0.3;
                });
                
                // Animate helicopter
                if (window.helicopter) {
                    window.helicopter.position.x = Math.sin(animationTime * 0.3) * 20;
                    window.helicopter.position.z = 45 + Math.cos(animationTime * 0.3) * 10;
                    window.rotorBlades.rotation.y += 0.5;
                    window.tailRotor.rotation.y += 0.8;
                }
                
                // Satan floats menacingly
                if (window.satan) {
                    window.satan.position.y = 1 + Math.sin(animationTime * 1.5) * 0.5;
                    window.satan.rotation.y = animationTime * 0.3;
                }
                
                // Fire pillars flicker
                if (window.firePillars) {
                    window.firePillars.forEach((fire, i) => {
                        fire.children[0].scale.y = 1 + Math.sin(animationTime * 10 + i) * 0.3;
                    });
                }
                
                // Battle bus circles
                if (window.battleBus) {
                    window.battleBus.position.x = Math.cos(animationTime * 0.2) * 100;
                    window.battleBus.position.z = Math.sin(animationTime * 0.2) * 100;
                }
                
                // Rift spins
                if (window.rift) {
                    window.rift.rotation.z = animationTime * 0.5;
                }
            } else if (phase === 'clouds') {
                // Title flies through clouds
                titleGroup.position.z += 0.3;
                titleGroup.position.y = 8 + Math.sin(animationTime * 2) * 0.5;
                titleGroup.rotation.y = Math.sin(animationTime) * 0.1;
                
                camera.position.z = 15 + animationTime * 2;
                camera.lookAt(titleGroup.position);
                
                if (animationTime > 3) {
                    phase = 'running';
                    animationTime = 0;
                    family.forEach(char => char.visible = true);
                }
            } else if (phase === 'running') {
                // Family runs across screen
                family.forEach((char, i) => {
                    char.position.x = 15 - animationTime * 8 + i * 1.5;
                    char.position.y = Math.abs(Math.sin(animationTime * 10 + i)) * 0.3;
                    char.rotation.y = -Math.PI / 2;
                });
                
                camera.position.set(0, 3, 10);
                camera.lookAt(family[2].position);
                
                if (animationTime > 4) {
                    phase = 'livingroom';
                    animationTime = 0;
                    livingRoom.visible = true;
                    grassGround.visible = false;
                    gagStartTime = 0;
                }
            } else if (phase === 'livingroom') {
                // Living room scene
                camera.position.set(0, 4, 58);
                camera.lookAt(0, 1, 50);
                
                // Family enters and sits
                if (animationTime < 2) {
                    family.forEach((char, i) => {
                        const targetX = -2 + i * 1;
                        const targetZ = 50.5;
                        char.position.x += (targetX - char.position.x) * 0.05;
                        char.position.z += (targetZ - char.position.z) * 0.05;
                        char.position.y = 0.5 + Math.abs(Math.sin(animationTime * 8 + i)) * 0.2;
                        char.rotation.y = 0;
                    });
                } else {
                    // Apply couch gag
                    gagStartTime += 0.016;
                    document.getElementById('gag-text').textContent = currentGag.text;
                    document.getElementById('gag-text').style.opacity = '1';
                    
                    // Trigger random dialogue
                    dialogueTimer += 0.016;
                    if (dialogueTimer > 2.5) {
                        let speaker = Math.floor(Math.random() * 5);
                        while (speaker === lastSpeaker) speaker = Math.floor(Math.random() * 5);
                        lastSpeaker = speaker;
                        showSpeechBubble(family[speaker], speaker);
                        dialogueTimer = 0;
                    }
                    
                    applyGag(currentGag.action, gagStartTime);
                }
                
                // Continuous scene - no episode restart
                // Scene keeps running forever
            }
            
            // Animate advanced effects
            if (window.nebula) {
                window.nebula.rotation.y += 0.0005;
                const positions = window.nebula.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(animationTime + positions[i] * 0.01) * 0.01;
                }
                window.nebula.geometry.attributes.position.needsUpdate = true;
            }
            
            if (window.stars) {
                window.stars.rotation.y += 0.0002;
            }
            
            if (window.energyRings) {
                window.energyRings.forEach((ring, i) => {
                    if (ring.userData.axis === 'x') {
                        ring.rotation.x += ring.userData.speed * 0.02;
                    } else {
                        ring.rotation.y += ring.userData.speed * 0.02;
                    }
                    ring.rotation.z = Math.sin(animationTime * 2 + i) * 0.5;
                    ring.material.opacity = 0.4 + Math.sin(animationTime * 3 + i) * 0.3;
                });
            }
            
            // Render with post-processing if available
            if (window.composer) {
                window.composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        function applyGag(action, time) {
            switch(action) {
                case 'bounce':
                    homer.position.y = 0.5 + Math.abs(Math.sin(time * 5)) * 3;
                    break;
                case 'spin':
                    couch.rotation.y = time * 3;
                    family.forEach((char, i) => {
                        char.position.x = Math.cos(time * 3 + i * 0.5) * 2.5;
                        char.position.z = 50 + Math.sin(time * 3 + i * 0.5) * 2.5;
                    });
                    break;
                case 'tiny':
                    family.forEach(char => char.scale.setScalar(0.3));
                    break;
                case 'gravity':
                    family.forEach((char, i) => {
                        char.position.y = 3 + Math.sin(time * 2 + i) * 1;
                        char.rotation.z = time;
                    });
                    break;
                case 'orbit':
                    family.forEach((char, i) => {
                        const angle = time * 2 + (i / 5) * Math.PI * 2;
                        char.position.x = Math.cos(angle) * 3;
                        char.position.z = 50 + Math.sin(angle) * 3;
                        char.position.y = 1 + Math.sin(time * 3) * 0.5;
                    });
                    break;
                case 'explode':
                    family.forEach((char, i) => {
                        char.position.x = Math.cos(i * 1.2) * time * 2;
                        char.position.z = 50 + Math.sin(i * 1.2) * time * 2;
                        char.position.y = time * 2;
                        char.rotation.x = time * 3;
                        char.rotation.z = time * 2;
                    });
                    break;
                case 'matrix':
                    camera.position.x = Math.cos(time * 0.5) * 8;
                    camera.position.z = 58 + Math.sin(time * 0.5) * 5;
                    camera.lookAt(0, 1, 50);
                    break;
                case 'schwifty':
                    family.forEach((char, i) => {
                        char.position.y = 0.5 + Math.sin(time * 8 + i) * 0.5;
                        char.rotation.y = Math.sin(time * 4) * 0.5;
                    });
                    break;
                case 'fortnite_drop':
                    // Battle bus flies across map
                    if (window.battleBus) {
                        window.battleBus.position.x = -150 + time * 30;
                        window.battleBus.position.z = -150 + time * 30;
                        window.battleBus.position.y = 80 + Math.sin(time * 2) * 2;
                    }
                    // Family drops from bus
                    family.forEach((char, i) => {
                        const dropDelay = i * 0.8;
                        const dropTime = Math.max(0, time - dropDelay);
                        if (dropTime > 0) {
                            char.position.x = -100 + dropTime * 20 + i * 10;
                            char.position.y = Math.max(0, 70 - dropTime * 25);
                            char.position.z = -100 + dropTime * 20;
                            char.rotation.x = dropTime < 2 ? dropTime * 3 : 0;
                            char.rotation.z = Math.sin(dropTime * 5) * 0.3;
                        }
                    });
                    // Animate supply drops
                    if (window.supplyDrops) {
                        window.supplyDrops.forEach((drop, i) => {
                            drop.position.y = Math.max(-3, drop.position.y - drop.userData.fallSpeed);
                            drop.rotation.y = time * 0.5;
                        });
                    }
                    // Dynamic camera
                    camera.position.set(
                        -80 + time * 15,
                        50 - time * 5,
                        -80 + time * 15
                    );
                    camera.lookAt(family[0].position);
                    renderer.setClearColor(0x87ceeb);
                    break;
                case 'tilted_chaos':
                    // Characters run through Tilted
                    family.forEach((char, i) => {
                        char.position.x = -100 + Math.sin(time * 2 + i) * 20;
                        char.position.y = 0 + Math.abs(Math.sin(time * 8 + i)) * 2;
                        char.position.z = -60 + time * 5;
                        char.rotation.y = Math.sin(time * 3) * 0.5;
                    });
                    // Camera circles Tilted
                    camera.position.set(
                        -80 + Math.cos(time * 0.5) * 50,
                        30,
                        -60 + Math.sin(time * 0.5) * 50
                    );
                    camera.lookAt(-80, 10, -60);
                    break;
                case 'storm_run':
                    // Storm shrinks
                    if (window.stormWall) {
                        const stormRadius = Math.max(50, 200 - time * 20);
                        window.stormWall.scale.set(stormRadius / 200, 1, stormRadius / 200);
                    }
                    // Family runs from storm
                    family.forEach((char, i) => {
                        const angle = time * 0.5 + i * 0.3;
                        const runRadius = Math.max(10, 150 - time * 15);
                        char.position.x = Math.cos(angle) * runRadius * 0.3;
                        char.position.y = Math.abs(Math.sin(time * 10 + i)) * 0.5;
                        char.position.z = Math.sin(angle) * runRadius * 0.3;
                    });
                    // Storm particles rotate
                    if (window.stormPts) {
                        window.stormPts.rotation.y = time * 0.2;
                    }
                    camera.position.set(0, 60, 100);
                    camera.lookAt(0, 0, 0);
                    renderer.setClearColor(new THREE.Color(0.3 + Math.sin(time) * 0.1, 0.2, 0.4));
                    break;
                case 'supply_hunt':
                    // Characters chase supply drops
                    if (window.supplyDrops && window.supplyDrops.length > 0) {
                        const targetDrop = window.supplyDrops[0];
                        family.forEach((char, i) => {
                            const dx = targetDrop.position.x - char.position.x;
                            const dz = targetDrop.position.z - char.position.z;
                            char.position.x += dx * 0.02;
                            char.position.z += dz * 0.02;
                            char.position.y = Math.abs(Math.sin(time * 8 + i)) * 1;
                            char.rotation.y = Math.atan2(dx, dz);
                        });
                        window.supplyDrops.forEach(drop => {
                            drop.position.y = Math.max(-3, drop.position.y - 0.3);
                            drop.children[2].material.opacity = 0.2 + Math.sin(time * 5) * 0.1;
                        });
                    }
                    camera.position.set(50, 40, 50);
                    camera.lookAt(family[2].position);
                    break;
                case 'victory':
                    // Victory celebration
                    if (window.victorySign) window.victorySign.visible = true;
                    family.forEach((char, i) => {
                        char.position.x = -2 + i * 2;
                        char.position.y = 1 + Math.abs(Math.sin(time * 6 + i * 0.5)) * 2;
                        char.position.z = 0;
                        char.rotation.y = time * 3;
                    });
                    // Confetti effect via storm particles
                    if (window.stormPts) {
                        window.stormPts.material.color.setHex(0xffdd00);
                        window.stormPts.rotation.y = time;
                    }
                    camera.position.set(0, 20, 30);
                    camera.lookAt(0, 5, 0);
                    renderer.setClearColor(0x4488ff);
                    break;
                case 'build_fight':
                    // Characters build ramps and walls
                    family.forEach((char, i) => {
                        char.position.x = Math.sin(time * 2 + i) * 10;
                        char.position.y = time * 3 + Math.sin(time * 5 + i) * 2;
                        char.position.z = Math.cos(time * 2 + i) * 10;
                        char.rotation.y = time * 2;
                    });
                    camera.position.set(
                        Math.cos(time * 0.3) * 40,
                        20 + time * 2,
                        Math.sin(time * 0.3) * 40
                    );
                    camera.lookAt(0, time * 3, 0);
                    break;
                case 'rift_zone':
                    // Rift spins and characters orbit it
                    if (window.rift) {
                        window.rift.rotation.z = time;
                        window.rift.children.forEach((child, i) => {
                            if (i > 1 && child.userData.angle !== undefined) {
                                child.userData.angle += 0.05 * child.userData.speed;
                                child.position.x = Math.cos(child.userData.angle) * child.userData.radius;
                                child.position.y = Math.sin(child.userData.angle) * child.userData.radius;
                            }
                        });
                    }
                    family.forEach((char, i) => {
                        const orbitAngle = time + i * 1.2;
                        char.position.x = Math.cos(orbitAngle) * (15 + i * 3);
                        char.position.y = 50 + Math.sin(orbitAngle * 2) * 5;
                        char.position.z = Math.sin(orbitAngle) * (15 + i * 3);
                        char.rotation.x = time * 2;
                    });
                    camera.position.set(0, 80, 60);
                    camera.lookAt(0, 60, 0);
                    renderer.setClearColor(0x112244);
                    break;
                case 'default_dance':
                    // Default dance animation
                    family.forEach((char, i) => {
                        char.position.x = -4 + i * 2;
                        char.position.y = 0.5 + Math.abs(Math.sin(time * 8)) * 0.5;
                        char.position.z = 0;
                        // Dance moves
                        char.rotation.y = Math.sin(time * 4) * 0.8;
                        char.rotation.z = Math.sin(time * 8 + i) * 0.2;
                        char.scale.y = 1 + Math.sin(time * 8) * 0.1;
                    });
                    camera.position.set(0, 5, 15);
                    camera.lookAt(0, 2, 0);
                    renderer.setClearColor(0x332266);
                    break;
                case 'satan':
                    window.pentagramGroup.visible = true;
                    
                    // Animate fire pillars
                    window.firePillars.forEach((fire, i) => {
                        fire.children[0].scale.y = 1 + Math.sin(time * 10 + i) * 0.3;
                        fire.children[1].scale.y = 1 + Math.sin(time * 12 + i) * 0.4;
                        fire.children[2].intensity = 1 + Math.sin(time * 8 + i) * 0.5;
                    });
                    
                    // Satan rises from pentagram
                    window.satan.visible = true;
                    window.satan.position.y = Math.min(-3 + time * 1.5, 0);
                    window.satan.rotation.y = time * 0.5;
                    
                    // Blood pool pulses
                    window.pentagramGroup.children[2].material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
                    
                    // Family reacts in horror
                    family.forEach((char, i) => {
                        char.position.x = -2 + i * 1 + Math.sin(time * 15 + i) * 0.1;
                        char.position.z = 52 + time * 0.3;
                        char.rotation.y = Math.PI;
                    });
                    
                    // Camera shakes
                    camera.position.x = Math.sin(time * 20) * 0.1;
                    camera.position.y = 4 + Math.sin(time * 25) * 0.05;
                    
                    // Red lighting effect
                    renderer.setClearColor(new THREE.Color(0.1 + Math.sin(time * 5) * 0.05, 0, 0));
                    break;
                case 'skydive':
                    // Show helicopter
                    window.helicopter.visible = true;
                    window.rotorBlades.rotation.y += 0.5;
                    window.tailRotor.rotation.y += 0.8;
                    
                    // Helicopter hovers and moves
                    window.helicopter.position.x = Math.sin(time * 0.5) * 3;
                    window.helicopter.position.y = 20 + Math.sin(time * 2) * 0.5;
                    window.helicopter.rotation.z = Math.sin(time * 0.5) * 0.1;
                    
                    // Sky background
                    renderer.setClearColor(new THREE.Color(0.4, 0.6, 0.9));
                    
                    // Family jumps and deploys chutes
                    family.forEach((char, i) => {
                        const jumpDelay = i * 0.5;
                        const jumpTime = Math.max(0, time - jumpDelay);
                        
                        if (jumpTime > 0) {
                            // Falling phase
                            const fallSpeed = jumpTime < 1.5 ? 8 : 2;
                            const targetY = Math.max(0.5, 20 - jumpTime * fallSpeed);
                            
                            char.position.x = -2 + i * 1.5 + Math.sin(jumpTime * 3 + i) * 0.5;
                            char.position.y = targetY;
                            char.position.z = 50 + jumpTime * 2;
                            
                            // Tumble while falling fast
                            if (jumpTime < 1.5) {
                                char.rotation.x = jumpTime * 5;
                                char.rotation.z = Math.sin(jumpTime * 8) * 0.5;
                            } else {
                                char.rotation.x = 0;
                                char.rotation.z = Math.sin(time * 2) * 0.1;
                            }
                            
                            // Parachute deployment
                            const chute = window.parachutes[i];
                            if (jumpTime > 1.5) {
                                chute.visible = true;
                                chute.position.copy(char.position);
                                chute.position.y += 1;
                                
                                // Chute sways
                                const scale = Math.min(1, (jumpTime - 1.5) * 2);
                                chute.scale.set(scale, scale, scale);
                                chute.rotation.z = Math.sin(time * 2 + i) * 0.2;
                            } else {
                                chute.visible = false;
                            }
                        }
                    });
                    
                    // Dynamic camera follows action
                    camera.position.set(
                        5 + Math.sin(time * 0.3) * 3,
                        10 + Math.cos(time * 0.2) * 5,
                        60 + time * 2
                    );
                    camera.lookAt(family[2].position);
                    break;
                default:
                    family.forEach((char, i) => {
                        char.position.set(-2 + i * 1, 0.5, 50.5);
                    });
            }
        }
        
        // Handle resize with post-processing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (window.composer) {
                window.composer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Start
        document.getElementById('loading').style.display = 'none';
        animate();
        // Continuous scene - no episode restart needed
        console.log('Continuous scene mode active - lights on everywhere!');
        playTheme(); // Play theme once
    </script>
</body>
</html>