<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bitcoin Beach Sunset üåÖ</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Courier New', monospace; overflow: hidden; background: #1a0a2f; }
#canvas-container { width: 100vw; height: 100vh; position: relative; }
.hud {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    background: rgba(20, 10, 40, 0.4); backdrop-filter: blur(20px);
    padding: 15px 20px; border-radius: 20px;
    border: 1px solid rgba(255, 215, 0, 0.3);
    color: #ffd700; text-shadow: 0 0 10px #ff8c00;
}
.hud h1 { font-size: 1.2rem; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }
.btc-icon {
    width: 24px; height: 24px; background: linear-gradient(135deg, #f7931a, #ffb84d);
    border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-weight: bold; color: white; font-size: 14px;
}
.price { font-size: 1.8rem; font-weight: bold; color: #ffd700; text-shadow: 0 0 15px #ff8c00; }
.change { font-size: 0.9rem; margin-top: 5px; }
.beach-overlay {
    position: fixed; bottom: 0; left: 0; width: 100%; height: 30%;
    background: linear-gradient(to top, rgba(244, 214, 164, 0.4) 0%, rgba(255, 200, 150, 0.25) 40%, transparent 100%);
    pointer-events: none; z-index: 50;
    mix-blend-mode: soft-light;
}

/* Enhanced Cinematic Vignette */
#canvas-container::after {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(20, 10, 30, 0.4) 100%);
    pointer-events: none;
    z-index: 10;
}

/* Lens flare overlay */
.lens-flare {
    position: fixed;
    top: 20%; left: 30%;
    width: 200px; height: 200px;
    background: radial-gradient(circle, rgba(255,220,150,0.15) 0%, transparent 70%);
    pointer-events: none;
    z-index: 60;
    animation: flare-pulse 4s ease-in-out infinite;
    mix-blend-mode: screen;
}
@keyframes flare-pulse {
    0%, 100% { opacity: 0.6; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.2); }
}
.chill-message {
    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
    text-align: center; z-index: 100; color: #fff; font-size: 1.5rem;
    text-shadow: 0 0 20px rgba(255, 150, 100, 0.8);
    background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(15px);
    padding: 20px 30px; border-radius: 25px; border: 1px solid rgba(255, 255, 255, 0.2);
    animation: breathe 4s ease-in-out infinite;
}
.chill-message .emoji { font-size: 2rem; display: block; margin-bottom: 10px; }
@keyframes breathe { 0%, 100% { opacity: 0.8; transform: translateX(-50%) scale(1); } 50% { opacity: 1; transform: translateX(-50%) scale(1.05); } }
.beach-items { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 1.8rem; z-index: 100; }
.time-display { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #ffcc88; font-size: 1rem; text-shadow: 0 0 10px #ff8800; z-index: 100; }
.instruction { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #666; font-size: 0.7rem; text-align: center; z-index: 100; }
.instruction code { background: rgba(145, 71, 255, 0.2); padding: 2px 6px; border-radius: 4px; color: #bf94ff; }
.village-label {
    position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(247, 147, 26, 0.3), rgba(255, 200, 100, 0.2));
    backdrop-filter: blur(10px); padding: 8px 16px; border-radius: 15px;
    border: 1px solid rgba(255, 215, 0, 0.4); color: #ffd700;
    font-size: 0.85rem; text-shadow: 0 0 10px #ff8c00; z-index: 100;
    animation: village-glow 3s ease-in-out infinite;
}
@keyframes village-glow {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 200, 100, 0.3); }
    50% { box-shadow: 0 0 20px rgba(255, 200, 100, 0.6); }
}
.audio-indicator {
    position: absolute; top: 10px; right: 10px; z-index: 100; color: #00ccff;
    font-size: 0.8rem; cursor: pointer; background: rgba(0, 150, 200, 0.2);
    padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(0, 200, 255, 0.4);
}
.audio-indicator.playing { color: #00ff88; border-color: rgba(0, 255, 136, 0.4); text-shadow: 0 0 10px #00ff88; }
.alien-tourist { position: absolute; z-index: 140; text-align: center; animation: alien-chill 5s ease-in-out infinite; }
.alien-tourist .alien-body { font-size: 2rem; filter: drop-shadow(0 0 10px rgba(0, 255, 136, 0.6)); }
.alien-tourist .speech { background: rgba(0, 255, 136, 0.15); padding: 4px 8px; border-radius: 10px; font-size: 0.55rem; color: #00ff88; border: 1px solid rgba(0, 255, 136, 0.3); margin-top: 4px; }
.abduction-status {
    position: absolute; top: 100px; right: 10px; z-index: 100;
    background: rgba(0, 255, 136, 0.2); backdrop-filter: blur(10px);
    padding: 10px 15px; border-radius: 12px; border: 1px solid rgba(0, 255, 136, 0.4);
    color: #00ff88; font-size: 0.75rem; text-shadow: 0 0 10px #00ff88;
}
.abduction-status .ufo-icon { animation: ufo-pulse 1s ease-in-out infinite; display: inline-block; }
@keyframes ufo-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
.alien-1 { bottom: 100px; left: 30px; }

.commands-menu {
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(20, 10, 40, 0.85); backdrop-filter: blur(15px);
    padding: 8px 15px; border-radius: 12px;
    border: 1px solid rgba(255, 100, 100, 0.4);
    color: #fff; font-size: 0.65rem; z-index: 200;
    display: flex; gap: 15px; align-items: center;
}
.commands-menu .cmd-title {
    color: #ff6b6b; font-weight: bold; font-size: 0.7rem;
    text-shadow: 0 0 8px #ff4444;
}
.commands-menu .cmd-item {
    background: rgba(255, 255, 255, 0.1); padding: 4px 10px;
    border-radius: 8px; cursor: pointer; transition: all 0.3s;
    border: 1px solid rgba(255, 255, 255, 0.2);
}
.commands-menu .cmd-item:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
}
.commands-menu .cmd-item.dance { border-color: rgba(255, 200, 100, 0.5); }
.commands-menu .cmd-item.war { border-color: rgba(255, 50, 50, 0.5); }
.commands-menu .cmd-item code {
    color: #bf94ff; background: rgba(145, 71, 255, 0.3);
    padding: 1px 4px; border-radius: 3px;
}
.war-bench {
    position: absolute; bottom: 160px; left: 10px; z-index: 130;
    background: rgba(80, 20, 20, 0.8); backdrop-filter: blur(10px);
    padding: 8px 10px; border-radius: 10px;
    border: 1px solid rgba(255, 50, 50, 0.4);
    font-size: 0.55rem; display: none;
}
.war-bench.active { display: block; }
.war-bench .bench-title {
    color: #ff6b6b; font-weight: bold; margin-bottom: 5px;
    text-shadow: 0 0 5px #ff4444;
}
.war-bench .eliminated {
    color: #888; margin: 2px 0; text-decoration: line-through;
}
.war-status {
    position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
    background: rgba(255, 50, 50, 0.9); padding: 10px 20px;
    border-radius: 15px; color: #fff; font-weight: bold;
    font-size: 1rem; z-index: 250; display: none;
    animation: war-pulse 0.5s ease-in-out infinite;
    border: 2px solid #ff0000;
}
.war-status.active { display: block; }
@keyframes war-pulse {
    0%, 100% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.05); }
}
@keyframes villager-dance {
    0%, 100% { transform: translateY(0) rotate(-10deg); }
    25% { transform: translateY(-10px) rotate(10deg); }
    50% { transform: translateY(0) rotate(-10deg); }
    75% { transform: translateY(-5px) rotate(5deg); }
}
@keyframes villager-fight {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(10px) rotate(5deg); }
    50% { transform: translateX(-10px) rotate(-5deg); }
    75% { transform: translateX(5px); }
}

.stickman-home {
    position: absolute; bottom: 60px; right: 40px; z-index: 130;
    text-align: center;
}
.tiki-hut {
    font-size: 2.5rem; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    animation: hut-sway 6s ease-in-out infinite;
}
.hut-label {
    font-size: 0.5rem; color: #f4d6a4; margin-top: -5px;
    text-shadow: 0 0 5px rgba(139, 69, 19, 0.8);
}
@keyframes hut-sway { 0%, 100% { transform: rotate(-0.5deg); } 50% { transform: rotate(0.5deg); } }

.stickman-container {
    position: absolute; bottom: 70px; right: 20px; z-index: 135;
    text-align: center; background: rgba(20, 10, 40, 0.6); backdrop-filter: blur(10px);
    padding: 10px 15px; border-radius: 15px; border: 1px solid rgba(255, 200, 100, 0.3);
}
.steve-location {
    font-size: 0.5rem; color: #88ccff; margin-top: 4px;
}

.stickman {
    font-size: 1.8rem; filter: drop-shadow(0 0 8px rgba(255, 200, 100, 0.5));
    animation: steve-walk 0.4s ease-in-out infinite;
}
.stickman-footprints {
    position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%);
    font-size: 0.4rem; opacity: 0.4; white-space: nowrap;
    animation: footprints-fade 1s ease-out infinite;
}
@keyframes footprints-fade {
    0% { opacity: 0.4; } 100% { opacity: 0; }
}
.stickman-speech {
    position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.9); color: #333; padding: 6px 10px;
    border-radius: 12px; font-size: 0.6rem; white-space: nowrap;
    border: 2px solid #ffd700; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    animation: speech-bounce 3s ease-in-out infinite;
}
.stickman-speech::after {
    content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
    border: 6px solid transparent; border-top-color: rgba(255, 255, 255, 0.9);
}
.stickman-name {
    font-size: 0.5rem; color: #ffd700; margin-top: 2px;
    text-shadow: 0 0 5px #ff8c00;
}
@keyframes stickman-idle {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-3px) rotate(2deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-2px) rotate(-2deg); }
}
@keyframes steve-walk {
    0%, 100% { transform: translateY(0) rotate(-3deg); }
    50% { transform: translateY(-5px) rotate(3deg); }
}
.stickman-container:hover .stickman {
    animation: steve-walk 0.3s ease-in-out infinite;
}
.villager-roster {
    position: absolute; bottom: 70px; left: 10px; z-index: 130;
    background: rgba(20, 10, 40, 0.7); backdrop-filter: blur(10px);
    padding: 10px 12px; border-radius: 12px;
    border: 1px solid rgba(255, 200, 100, 0.3);
    font-size: 0.55rem;
}
.roster-title {
    color: #ffd700; font-weight: bold; margin-bottom: 6px;
    text-shadow: 0 0 8px #ff8c00; font-size: 0.65rem;
}
.roster-item {
    color: #fff; margin: 3px 0; padding: 3px 6px; border-radius: 6px;
    display: flex; justify-content: space-between; gap: 8px;
}
.roster-item span { opacity: 0.7; font-style: italic; }
.roster-item.maria { background: rgba(255, 107, 107, 0.3); }
.roster-item.jake { background: rgba(255, 221, 68, 0.3); }
.roster-item.luna { background: rgba(153, 102, 204, 0.3); }
.roster-item.max { background: rgba(255, 68, 68, 0.3); }
.roster-item.zara { background: rgba(247, 147, 26, 0.3); }
@keyframes speech-bounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-3px); }
}
@keyframes alien-chill { 0%, 100% { transform: translateY(0) rotate(-2deg); } 50% { transform: translateY(-8px) rotate(2deg); } }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div class="beach-overlay"></div>
<div class="lens-flare"></div>
<div class="hud">
<h1><span class="btc-icon">‚Çø</span> BEACH BAR</h1>
<div class="price" id="price">$67,432</div>
<div class="change" id="change">‚ñ≤ +2.34%</div>
</div>
<div class="commands-menu">
<span class="cmd-title">‚ö° VILLAGER COMMANDS</span>
<div class="cmd-item dance" onclick="triggerDance()" title="Make all villagers dance!">
        üíÉ <code>/dance</code> Party Time!
    </div>
<div class="cmd-item war" onclick="triggerWar()" title="Start a tournament!">
        ‚öîÔ∏è <code>/war</code> Tournament!
    </div>
</div>
<div class="war-bench" id="war-bench">
<div class="bench-title">üíÄ Eliminated</div>
<div id="eliminated-list"></div>
</div>
<div class="war-status" id="war-status">‚öîÔ∏è BATTLE IN PROGRESS!</div>
<div class="time-display">üåÖ Golden Hour</div>
<div class="chill-message">
<span class="emoji">üå¥‚òÄÔ∏èüåä</span>
<div>Just breathe... You're on Bitcoin Beach</div>
</div>
<div class="beach-items">üèñÔ∏è üå¥ üçπ ü¶Ä ‚õ±Ô∏è üèòÔ∏è</div>
<div class="village-label">
<span>‚ú® Bitcoin Beach Village ‚ú®</span>
</div>
<div class="alien-tourist alien-1">
<span class="alien-body">üëΩüçπ</span>
<div class="speech">Earth sunsets hit different üåÖ</div>
</div>
<div class="stickman-home">
<div class="tiki-hut">üõñ</div>
<div class="hut-label">Steve's Hut</div>
</div>
<div class="stickman-container" id="stickman">
<div class="stickman-speech" id="stickman-speech">Living my best beach life! üèñÔ∏è</div>
<div class="stickman" id="stickman-body">üè†</div>
<div class="stickman-name">Steve Status</div>
<div class="steve-location" id="steve-location">üìç Patrolling village...</div>
</div>
<div class="villager-roster">
<div class="roster-title">üèòÔ∏è Village Residents</div>
<div class="roster-item maria">üçπ Maria <span>Bartender</span></div>
<div class="roster-item jake">üèÑ Jake <span>Surf Instructor</span></div>
<div class="roster-item luna">üõí Luna <span>Market Vendor</span></div>
<div class="roster-item max">üèä Max <span>Lifeguard</span></div>
<div class="roster-item zara">‚Çø Zara <span>BTC Evangelist</span></div>
</div>
<div class="audio-indicator" id="audio-toggle">üåä Ocean Waves</div>
<div class="abduction-status" id="abduction-status">
<span class="ufo-icon">üõ∏</span> UFO Activity: <span id="ufo-activity">Scanning...</span>
</div>
<p class="instruction">Type <code>!idea your idea</code> in chat to modify this world</p>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0xff7744, 0.008);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(-15, 4, 15);
camera.lookAt(5, 0, 30);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xff6b35);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.85;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Sky
const skyGeo = new THREE.SphereGeometry(500, 32, 32);
const skyCanvas = document.createElement('canvas');
skyCanvas.width = 512; skyCanvas.height = 256;
const skyCtx = skyCanvas.getContext('2d');
const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
skyGrad.addColorStop(0, '#1a0a3a'); skyGrad.addColorStop(0.3, '#ff4500');
skyGrad.addColorStop(0.5, '#ff6b35'); skyGrad.addColorStop(0.7, '#ffa07a'); skyGrad.addColorStop(1, '#ffcc88');
skyCtx.fillStyle = skyGrad; skyCtx.fillRect(0, 0, 512, 256);
const sunGrad = skyCtx.createRadialGradient(256, 140, 0, 256, 140, 40);
sunGrad.addColorStop(0, '#fffacd'); sunGrad.addColorStop(0.3, '#ffd700'); sunGrad.addColorStop(1, 'transparent');
skyCtx.fillStyle = sunGrad; skyCtx.fillRect(0, 0, 512, 256);
const sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(skyCanvas), side: THREE.BackSide }));
scene.add(sky);

// Volumetric God Rays from Sun
const godRaysGeo = new THREE.PlaneGeometry(100, 100);
const godRaysMat = new THREE.ShaderMaterial({
    transparent: true,
    uniforms: {
        uTime: { value: 0 },
        uSunPos: { value: new THREE.Vector2(0.5, 0.35) }
    },
    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
    fragmentShader: `
        uniform float uTime;
        uniform vec2 uSunPos;
        varying vec2 vUv;
        float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
        void main() {
            vec2 dir = vUv - uSunPos;
            float dist = length(dir);
            float rays = 0.0;
            for(int i = 0; i < 8; i++) {
                float angle = atan(dir.y, dir.x) + float(i) * 0.785;
                rays += pow(abs(sin(angle * 12.0 + uTime * 0.5)), 8.0) * (1.0 - dist) * 0.15;
            }
            rays *= smoothstep(0.8, 0.0, dist);
            vec3 col = vec3(1.0, 0.8, 0.4) * rays;
            gl_FragColor = vec4(col, rays * 0.4);
        }
    `,
    side: THREE.DoubleSide,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});
const godRays = new THREE.Mesh(godRaysGeo, godRaysMat);
godRays.position.set(0, 30, -50);
godRays.lookAt(camera.position);
scene.add(godRays);

// Dynamic Volumetric Clouds
const cloudGeo = new THREE.PlaneGeometry(300, 300, 1, 1);
const cloudMat = new THREE.ShaderMaterial({
    transparent: true,
    uniforms: {
        uTime: { value: 0 }
    },
    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
    fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;
        float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
        float noise(vec2 p) {
            vec2 i = floor(p); vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            return mix(mix(hash(i), hash(i + vec2(1,0)), f.x),
                       mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x), f.y);
        }
        float fbm(vec2 p) {
            float v = 0.0, a = 0.5;
            for(int i = 0; i < 5; i++) { v += a * noise(p); p *= 2.0; a *= 0.5; }
            return v;
        }
        void main() {
            vec2 uv = vUv * 3.0 + vec2(uTime * 0.02, 0.0);
            float cloud = fbm(uv) * fbm(uv * 2.0 + 1.0);
            cloud = smoothstep(0.3, 0.7, cloud);
            vec3 col = mix(vec3(1.0, 0.6, 0.3), vec3(1.0, 0.9, 0.8), cloud);
            gl_FragColor = vec4(col, cloud * 0.35);
        }
    `,
    side: THREE.DoubleSide,
    depthWrite: false
});
const clouds = new THREE.Mesh(cloudGeo, cloudMat);
clouds.rotation.x = -Math.PI / 2;
clouds.position.y = 60;
scene.add(clouds);

// Ocean with shader
const oceanGeo = new THREE.PlaneGeometry(500, 500, 64, 64);
const oceanMat = new THREE.ShaderMaterial({
    uniforms: { 
        uTime: { value: 0 }, 
        uDeepColor: { value: new THREE.Color(0x001a33) }, 
        uShallowColor: { value: new THREE.Color(0x0099bb) }, 
        uSunsetColor: { value: new THREE.Color(0xff5522) },
        uFoamColor: { value: new THREE.Color(0xffffff) },
        uSunDirection: { value: new THREE.Vector3(0.5, 0.3, -1.0) }
    },
    vertexShader: `
        uniform float uTime;
        varying vec2 vUv;
        varying float vElevation;
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        float wave(vec2 p, float t, float freq, float speed) {
            return sin(p.x * freq + t * speed) * cos(p.y * freq * 0.7 + t * speed * 0.8);
        }
        
        void main() {
            vUv = uv;
            vec3 pos = position;
            
            // Multi-layered Gerstner-style waves
            float w1 = wave(pos.xy, uTime, 0.04, 1.0) * 2.0;
            float w2 = wave(pos.xy + 50.0, uTime, 0.08, 1.5) * 1.0;
            float w3 = wave(pos.xy + 100.0, uTime, 0.15, 2.0) * 0.5;
            float w4 = wave(pos.xy, uTime, 0.3, 3.0) * 0.2;
            
            vElevation = w1 + w2 + w3 + w4;
            pos.z += vElevation;
            
            // Calculate normal for specular
            float delta = 0.1;
            float hL = wave(pos.xy - vec2(delta, 0.0), uTime, 0.04, 1.0) * 2.0;
            float hR = wave(pos.xy + vec2(delta, 0.0), uTime, 0.04, 1.0) * 2.0;
            float hD = wave(pos.xy - vec2(0.0, delta), uTime, 0.04, 1.0) * 2.0;
            float hU = wave(pos.xy + vec2(0.0, delta), uTime, 0.04, 1.0) * 2.0;
            vNormal = normalize(vec3(hL - hR, 2.0 * delta, hD - hU));
            
            vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `,
    fragmentShader: `
        uniform vec3 uDeepColor;
        uniform vec3 uShallowColor;
        uniform vec3 uSunsetColor;
        uniform vec3 uFoamColor;
        uniform vec3 uSunDirection;
        uniform float uTime;
        varying float vElevation;
        varying vec2 vUv;
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
        
        void main() {
            // Depth-based color
            float depth = smoothstep(-2.0, 3.0, vElevation);
            vec3 color = mix(uDeepColor, uShallowColor, depth);
            
            // Sunset reflection
            float sunsetMix = smoothstep(0.7, 0.0, vUv.y) * 0.6;
            color = mix(color, uSunsetColor, sunsetMix);
            
            // Specular highlight (sun reflection)
            vec3 viewDir = normalize(cameraPosition - vWorldPos);
            vec3 reflectDir = reflect(-normalize(uSunDirection), vNormal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128.0);
            color += vec3(1.0, 0.95, 0.8) * spec * 2.0;
            
            // Foam on wave crests
            float foam = smoothstep(1.5, 2.5, vElevation);
            foam += noise(vUv * 200.0 + uTime) * 0.3 * smoothstep(1.0, 2.0, vElevation);
            color = mix(color, uFoamColor, foam * 0.7);
            
            // Subsurface scattering effect
            float sss = pow(max(0.0, dot(viewDir, -vNormal)), 2.0) * 0.3;
            color += vec3(0.0, 0.4, 0.5) * sss;
            
            // Fresnel rim
            float fresnel = pow(1.0 - max(dot(viewDir, vec3(0.0, 1.0, 0.0)), 0.0), 3.0);
            color = mix(color, uSunsetColor * 1.2, fresnel * 0.4);
            
            gl_FragColor = vec4(color, 0.88);
        }
    `,
    transparent: true, side: THREE.DoubleSide
});
const ocean = new THREE.Mesh(oceanGeo, oceanMat);
ocean.rotation.x = -Math.PI / 2; ocean.position.y = -0.5;
scene.add(ocean);

// Beach
const beach = new THREE.Mesh(new THREE.PlaneGeometry(100, 50), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
beach.rotation.x = -Math.PI / 2; beach.position.set(0, -0.3, 30);
scene.add(beach);

// 3D Village Buildings
function createTikiBar(x, z) {
    const g = new THREE.Group();
    // Base platform
    const base = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, 0.3, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
    base.position.y = 0.15; g.add(base);
    // Bamboo poles
    for (let i = 0; i < 4; i++) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2.5, 6), new THREE.MeshPhongMaterial({ color: 0xdeb887 }));
        pole.position.set(Math.cos(i * Math.PI/2) * 1.5, 1.25, Math.sin(i * Math.PI/2) * 1.5); g.add(pole);
    }
    // Thatched roof
    const roof = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.5, 8), new THREE.MeshPhongMaterial({ color: 0xd2691e }));
    roof.position.y = 3; g.add(roof);
    // Bar counter
    const counter = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 0.4), new THREE.MeshPhongMaterial({ color: 0x654321 }));
    counter.position.set(0, 0.7, 1.2); g.add(counter);
    g.position.set(x, 0, z); return g;
}

function createSurfShop(x, z) {
    const g = new THREE.Group();
    // Main building
    const building = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 2.5), new THREE.MeshPhongMaterial({ color: 0x87ceeb }));
    building.position.y = 1.25; g.add(building);
    // Roof
    const roof = new THREE.Mesh(new THREE.BoxGeometry(3.4, 0.3, 2.9), new THREE.MeshPhongMaterial({ color: 0xff6347 }));
    roof.position.y = 2.65; g.add(roof);
    // Surfboard rack
    for (let i = 0; i < 3; i++) {
        const boardGroup = new THREE.Group();
        const boardBody = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1.8, 8), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        const boardTip = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 4), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        const boardTail = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 4), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        boardTip.position.y = 0.9; boardTail.position.y = -0.9;
        boardGroup.add(boardBody); boardGroup.add(boardTip); boardGroup.add(boardTail);
        boardGroup.position.set(-1.7, 1 + i * 0.1, -0.5 + i * 0.5); boardGroup.rotation.z = Math.PI / 8; g.add(boardGroup);
    }
    // Sign
    const sign = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.1), new THREE.MeshPhongMaterial({ color: 0xffd700 }));
    sign.position.set(0, 2.2, 1.3); g.add(sign);
    g.position.set(x, 0, z); return g;
}

function createCottage(x, z) {
    const g = new THREE.Group();
    // Walls
    const walls = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 2), new THREE.MeshPhongMaterial({ color: 0xffefd5 }));
    walls.position.y = 1; g.add(walls);
    // Pitched roof
    const roofGeo = new THREE.ConeGeometry(2, 1.2, 4);
    const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({ color: 0x8b0000 }));
    roof.position.y = 2.6; roof.rotation.y = Math.PI / 4; g.add(roof);
    // Door
    const door = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.1), new THREE.MeshPhongMaterial({ color: 0x654321 }));
    door.position.set(0, 0.5, 1.05); g.add(door);
    // Window
    const window1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.1), new THREE.MeshPhongMaterial({ color: 0x87ceeb, emissive: 0x4444aa, emissiveIntensity: 0.3 }));
    window1.position.set(0.7, 1.2, 1.05); g.add(window1);
    g.position.set(x, 0, z); return g;
}

function createLighthouse(x, z) {
    const g = new THREE.Group();
    // Tower
    const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1, 5, 12), new THREE.MeshPhongMaterial({ color: 0xffffff }));
    tower.position.y = 2.5; g.add(tower);
    // Red stripes
    for (let i = 0; i < 3; i++) {
        const stripe = new THREE.Mesh(new THREE.CylinderGeometry(0.75 - i*0.1, 0.85 - i*0.1, 0.5, 12), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
        stripe.position.y = 1 + i * 1.5; g.add(stripe);
    }
    // Light room
    const lightRoom = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.6, 0.8, 12), new THREE.MeshPhongMaterial({ color: 0x333333 }));
    lightRoom.position.y = 5.2; g.add(lightRoom);
    // Light beacon
    const beacon = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 0.8 }));
    beacon.position.y = 5.2; g.add(beacon);
    // Roof
    const roof = new THREE.Mesh(new THREE.ConeGeometry(0.8, 0.6, 12), new THREE.MeshPhongMaterial({ color: 0x8b0000 }));
    roof.position.y = 5.9; g.add(roof);
    g.position.set(x, 0, z); return g;
}

function createMarketStall(x, z) {
    const g = new THREE.Group();
    // Counter
    const counter = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 1), new THREE.MeshPhongMaterial({ color: 0xdeb887 }));
    counter.position.y = 0.4; g.add(counter);
    // Canopy poles
    for (let i = 0; i < 4; i++) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
        pole.position.set((i % 2) * 1.6 - 0.8, 1.55, (Math.floor(i/2)) * 0.8 - 0.4); g.add(pole);
    }
    // Colorful canopy
    const canopy = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.1, 1.2), new THREE.MeshPhongMaterial({ color: 0xff6b35 }));
    canopy.position.y = 2.3; g.add(canopy);
    // Goods on display
    for (let i = 0; i < 5; i++) {
        const item = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), new THREE.MeshPhongMaterial({ color: [0xff0000, 0xffa500, 0xffff00, 0x00ff00, 0x800080][i] }));
        item.position.set(-0.6 + i * 0.3, 0.95, 0); g.add(item);
    }
    g.position.set(x, 0, z); return g;
}

function createBitcoinATM(x, z) {
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.6), new THREE.MeshPhongMaterial({ color: 0xf7931a }));
    body.position.y = 0.9; g.add(body);
    const screen = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.05), new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 0.5 }));
    screen.position.set(0, 1.3, 0.33); g.add(screen);
    g.position.set(x, 0, z); return g;
}

// Add village buildings
const tikiBar = createTikiBar(-5, 26);
scene.add(tikiBar);

const surfShop = createSurfShop(6, 24);
scene.add(surfShop);

const cottage = createCottage(-2, 32);
scene.add(cottage);

const lighthouse = createLighthouse(12, 30);
scene.add(lighthouse);

const marketStall = createMarketStall(2, 28);
scene.add(marketStall);

const btcATM = createBitcoinATM(0, 25);
scene.add(btcATM);

// UFO Fleet - Alien Ships
const ufos = [];
function createUFO() {
    const g = new THREE.Group();
    // Main saucer body
    const saucerTop = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x88aacc, metalness: 0.8, emissive: 0x224466, emissiveIntensity: 0.3 })
    );
    saucerTop.scale.y = 0.4;
    g.add(saucerTop);
    // Bottom dome
    const saucerBottom = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x556677, metalness: 0.9 })
    );
    saucerBottom.scale.y = 0.25;
    g.add(saucerBottom);
    // Cockpit dome
    const cockpit = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 12, 8),
        new THREE.MeshPhongMaterial({ color: 0x00ff88, emissive: 0x00ff44, emissiveIntensity: 0.6, transparent: true, opacity: 0.7 })
    );
    cockpit.position.y = 0.3;
    cockpit.scale.y = 0.6;
    g.add(cockpit);
    // Ring lights
    for (let i = 0; i < 8; i++) {
        const light = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 6, 6),
            new THREE.MeshBasicMaterial({ color: 0x00ffaa })
        );
        light.position.x = Math.cos(i * Math.PI / 4) * 1.0;
        light.position.z = Math.sin(i * Math.PI / 4) * 1.0;
        light.position.y = -0.1;
        g.add(light);
    }
    // Abduction beam (initially invisible)
    const beamGeo = new THREE.CylinderGeometry(0.3, 2, 15, 16, 1, true);
    const beamMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88, transparent: true, opacity: 0, side: THREE.DoubleSide 
    });
    const beam = new THREE.Mesh(beamGeo, beamMat);
    beam.position.y = -7.5;
    beam.name = 'beam';
    g.add(beam);
    // Point light for glow
    const ufoLight = new THREE.PointLight(0x00ff88, 0, 15);
    ufoLight.position.y = -1;
    g.add(ufoLight);
    g.userData = {
        beam: beam,
        light: ufoLight,
        orbitRadius: 15 + Math.random() * 20,
        orbitSpeed: 0.3 + Math.random() * 0.4,
        orbitOffset: Math.random() * Math.PI * 2,
        height: 18 + Math.random() * 10,
        heightWobble: Math.random() * 3,
        isAbducting: false,
        abductionTimer: 0,
        abductionTarget: null
    };
    return g;
}

// Create UFO fleet
for (let i = 0; i < 4; i++) {
    const ufo = createUFO();
    scene.add(ufo);
    ufos.push(ufo);
}

// Abduction victims (floating people being beamed up)
const victims = [];
function createVictim() {
    const g = new THREE.Group();
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 0.8;
    g.add(head);
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.6, 8), new THREE.MeshPhongMaterial({ color: 0xff6666 }));
    body.position.y = 0.4;
    g.add(body);
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.2, 0.6, 0);
    leftArm.rotation.z = Math.PI / 2.5;
    g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.2, 0.6, 0);
    rightArm.rotation.z = -Math.PI / 2.5;
    g.add(rightArm);
    g.visible = false;
    g.userData = { floatProgress: 0, startY: 0, targetUFO: null };
    return g;
}
for (let i = 0; i < 4; i++) {
    const victim = createVictim();
    scene.add(victim);
    victims.push(victim);
}

// UFO Sound Effects System
let ufoAudioCtx = null;
let ufoSounds = { hum: null, beam: null, woosh: null };
function initUFOAudio() {
    if (ufoAudioCtx) return;
    ufoAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // UFO Hum - low frequency oscillator
    const humOsc = ufoAudioCtx.createOscillator();
    humOsc.type = 'sine';
    humOsc.frequency.value = 80;
    const humGain = ufoAudioCtx.createGain();
    humGain.gain.value = 0.08;
    const humFilter = ufoAudioCtx.createBiquadFilter();
    humFilter.type = 'lowpass';
    humFilter.frequency.value = 200;
    humOsc.connect(humFilter);
    humFilter.connect(humGain);
    humGain.connect(ufoAudioCtx.destination);
    humOsc.start();
    ufoSounds.hum = { osc: humOsc, gain: humGain };
}
function playBeamSound() {
    if (!ufoAudioCtx) initUFOAudio();
    const osc = ufoAudioCtx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(2000, ufoAudioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, ufoAudioCtx.currentTime + 1.5);
    const gain = ufoAudioCtx.createGain();
    gain.gain.setValueAtTime(0.15, ufoAudioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ufoAudioCtx.currentTime + 1.5);
    const filter = ufoAudioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 800;
    filter.Q.value = 2;
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(ufoAudioCtx.destination);
    osc.start();
    osc.stop(ufoAudioCtx.currentTime + 1.5);
}
function playWooshSound() {
    if (!ufoAudioCtx) initUFOAudio();
    const bufferSize = ufoAudioCtx.sampleRate * 0.5;
    const buffer = ufoAudioCtx.createBuffer(1, bufferSize, ufoAudioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }
    const source = ufoAudioCtx.createBufferSource();
    source.buffer = buffer;
    const filter = ufoAudioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 1500;
    filter.Q.value = 1;
    const gain = ufoAudioCtx.createGain();
    gain.gain.value = 0.1;
    source.connect(filter);
    filter.connect(gain);
    gain.connect(ufoAudioCtx.destination);
    source.start();
}

// 3D Stickman Steve - Village Resident
function createStickmanSteve() {
    const g = new THREE.Group();
    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 1.7; g.add(head);
    // Body
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8), new THREE.MeshPhongMaterial({ color: 0x4488ff }));
    body.position.y = 1.2; g.add(body);
    // Arms
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.25, 1.3, 0); leftArm.rotation.z = Math.PI / 4; g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.25, 1.3, 0); rightArm.rotation.z = -Math.PI / 4; g.add(rightArm);
    // Legs
    const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    leftLeg.position.set(-0.1, 0.55, 0); g.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    rightLeg.position.set(0.1, 0.55, 0); g.add(rightLeg);
    // Hat (beach style)
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.1, 12), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
    hat.position.y = 1.95; g.add(hat);
    const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 12), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
    hatTop.position.y = 2.05; g.add(hatTop);
    // Name tag floating above
    g.userData = { leftLeg, rightLeg, leftArm, rightArm };
    return g;
}

const steve3D = createStickmanSteve();
steve3D.position.set(8, 0, 26);
scene.add(steve3D);

// Create other villagers with different roles
function createVillager(color, hatColor, role) {
    const g = new THREE.Group();
    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 1.7; g.add(head);
    // Body with role-specific color
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8), new THREE.MeshPhongMaterial({ color: color }));
    body.position.y = 1.2; g.add(body);
    // Arms
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.25, 1.3, 0); leftArm.rotation.z = Math.PI / 4; g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.25, 1.3, 0); rightArm.rotation.z = -Math.PI / 4; g.add(rightArm);
    // Legs
    const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    leftLeg.position.set(-0.1, 0.55, 0); g.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    rightLeg.position.set(0.1, 0.55, 0); g.add(rightLeg);
    // Role-specific hat
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.1, 12), new THREE.MeshPhongMaterial({ color: hatColor }));
    hat.position.y = 1.95; g.add(hat);
    const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 12), new THREE.MeshPhongMaterial({ color: hatColor }));
    hatTop.position.y = 2.05; g.add(hatTop);
    g.userData = { leftLeg, rightLeg, leftArm, rightArm, role };
    return g;
}

// Maria - Tiki Bar Bartender (Red apron)
const maria = createVillager(0xff6b6b, 0xd2691e, 'bartender');
maria.position.set(-5, 0, 26);
scene.add(maria);
const mariaWaypoints = [
    { x: -5, z: 26 }, { x: -4, z: 27 }, { x: -6, z: 26 }, { x: -5, z: 25 }
];
let mariaWPIndex = 0, mariaLerp = 0;

// Jake - Surf Instructor (Yellow shirt)
const jake = createVillager(0xffdd44, 0x00aaff, 'surfer');
jake.position.set(6, 0, 24);
scene.add(jake);
const jakeWaypoints = [
    { x: 6, z: 24 }, { x: 8, z: 22 }, { x: 4, z: 20 }, { x: 6, z: 22 }
];
let jakeWPIndex = 0, jakeLerp = 0;

// Luna - Market Vendor (Purple dress)
const luna = createVillager(0x9966cc, 0xff69b4, 'vendor');
luna.position.set(2, 0, 28);
scene.add(luna);
const lunaWaypoints = [
    { x: 2, z: 28 }, { x: 3, z: 29 }, { x: 1, z: 28 }, { x: 2, z: 27 }
];
let lunaWPIndex = 0, lunaLerp = 0;

// Max - Lifeguard (Red shorts)
const max = createVillager(0xff4444, 0xffffff, 'lifeguard');
max.position.set(0, 0, 20);
scene.add(max);
const maxWaypoints = [
    { x: 0, z: 20 }, { x: 5, z: 18 }, { x: -5, z: 18 }, { x: 0, z: 22 }
];
let maxWPIndex = 0, maxLerp = 0;

// Zara - Bitcoin Evangelist (Orange BTC shirt)
const zara = createVillager(0xf7931a, 0xf7931a, 'btc_evangelist');
zara.position.set(0, 0, 25);
scene.add(zara);
const zaraWaypoints = [
    { x: 0, z: 25 }, { x: -2, z: 32 }, { x: 6, z: 24 }, { x: 2, z: 28 }
];
let zaraWPIndex = 0, zaraLerp = 0;

const allVillagers = [
    { model: maria, waypoints: mariaWaypoints, wpIndex: () => mariaWPIndex, setWpIndex: (v) => mariaWPIndex = v, lerp: () => mariaLerp, setLerp: (v) => mariaLerp = v, speed: 0.006 },
    { model: jake, waypoints: jakeWaypoints, wpIndex: () => jakeWPIndex, setWpIndex: (v) => jakeWPIndex = v, lerp: () => jakeLerp, setLerp: (v) => jakeLerp = v, speed: 0.01 },
    { model: luna, waypoints: lunaWaypoints, wpIndex: () => lunaWPIndex, setWpIndex: (v) => lunaWPIndex = v, lerp: () => lunaLerp, setLerp: (v) => lunaLerp = v, speed: 0.005 },
    { model: max, waypoints: maxWaypoints, wpIndex: () => maxWPIndex, setWpIndex: (v) => maxWPIndex = v, lerp: () => maxLerp, setLerp: (v) => maxLerp = v, speed: 0.012 },
    { model: zara, waypoints: zaraWaypoints, wpIndex: () => zaraWPIndex, setWpIndex: (v) => zaraWPIndex = v, lerp: () => zaraLerp, setLerp: (v) => zaraLerp = v, speed: 0.007 }
];

// Steve's patrol waypoints around the village
const steveWaypoints = [
    { x: 8, z: 26 },   // Near surf shop
    { x: 2, z: 28 },   // Market stall
    { x: -5, z: 26 },  // Tiki bar
    { x: -2, z: 32 },  // Cottage
    { x: 0, z: 25 },   // BTC ATM
    { x: 6, z: 24 },   // Back to surf shop
];
let steveWaypointIndex = 0;
let steveLerpProgress = 0;
const steveMoveSpeed = 0.008;

// Palm trees
function createPalm(x, z) {
    const g = new THREE.Group();
    g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 4, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 })));
    g.children[0].position.y = 2;
    for (let i = 0; i < 6; i++) {
        const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 4), new THREE.MeshPhongMaterial({ color: 0x228b22 }));
        leaf.position.y = 4; leaf.rotation.z = (i / 6) * Math.PI * 2; leaf.rotation.x = Math.PI / 3;
        g.add(leaf);
    }
    g.position.set(x, 0, z); return g;
}
scene.add(createPalm(-8, 25)); scene.add(createPalm(10, 28)); scene.add(createPalm(-12, 32));

// Enhanced Cinematic Lighting System
scene.add(new THREE.AmbientLight(0xffa07a, 0.35));

// Main Sun Light with shadows
const sunLight = new THREE.DirectionalLight(0xffd700, 1.2);
sunLight.position.set(-30, 40, -50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 200;
sunLight.shadow.camera.left = -50;
sunLight.shadow.camera.right = 50;
sunLight.shadow.camera.top = 50;
sunLight.shadow.camera.bottom = -50;
sunLight.shadow.bias = -0.0001;
scene.add(sunLight);

// Warm fill light from opposite side
const fillLight = new THREE.DirectionalLight(0xff7744, 0.5);
fillLight.position.set(30, 20, 40);
scene.add(fillLight);

// Rim light for dramatic silhouettes
const rimLight = new THREE.DirectionalLight(0xff4400, 0.35);
rimLight.position.set(0, 5, -40);
scene.add(rimLight);

// Village warm point lights
const villageLight = new THREE.PointLight(0xffaa44, 0.8, 60);
villageLight.position.set(0, 8, 28);
scene.add(villageLight);

// Tiki bar torch lights
const torch1 = new THREE.PointLight(0xff6600, 1.0, 15);
torch1.position.set(-5, 3, 26);
scene.add(torch1);

const torch2 = new THREE.PointLight(0xff6600, 1.0, 15);
torch2.position.set(-7, 3, 26);
scene.add(torch2);

// Lighthouse beacon
const lighthouseBeacon = new THREE.PointLight(0xffffaa, 1.0, 40);
lighthouseBeacon.position.set(12, 8, 30);
scene.add(lighthouseBeacon);

// Hemisphere light for natural sky lighting
const hemiLight = new THREE.HemisphereLight(0xff8866, 0x4466aa, 0.4);
scene.add(hemiLight);

// Firefly Particle System
const fireflyCount = 100;
const fireflyGeo = new THREE.BufferGeometry();
const fireflyPositions = new Float32Array(fireflyCount * 3);
const fireflySizes = new Float32Array(fireflyCount);
const fireflyPhases = new Float32Array(fireflyCount);

for (let i = 0; i < fireflyCount; i++) {
    fireflyPositions[i * 3] = (Math.random() - 0.5) * 60;
    fireflyPositions[i * 3 + 1] = 1 + Math.random() * 8;
    fireflyPositions[i * 3 + 2] = 15 + Math.random() * 30;
    fireflySizes[i] = 0.5 + Math.random() * 1.5;
    fireflyPhases[i] = Math.random() * Math.PI * 2;
}

fireflyGeo.setAttribute('position', new THREE.BufferAttribute(fireflyPositions, 3));
fireflyGeo.setAttribute('aSize', new THREE.BufferAttribute(fireflySizes, 1));
fireflyGeo.setAttribute('aPhase', new THREE.BufferAttribute(fireflyPhases, 1));

const fireflyMat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
        attribute float aSize;
        attribute float aPhase;
        varying float vAlpha;
        uniform float uTime;
        void main() {
            vec3 pos = position;
            pos.y += sin(uTime * 2.0 + aPhase) * 0.5;
            pos.x += sin(uTime * 1.5 + aPhase * 2.0) * 0.3;
            vAlpha = (sin(uTime * 4.0 + aPhase * 3.0) + 1.0) * 0.5;
            vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = aSize * (200.0 / -mvPos.z);
            gl_Position = projectionMatrix * mvPos;
        }
    `,
    fragmentShader: `
        varying float vAlpha;
        void main() {
            float d = length(gl_PointCoord - 0.5);
            if (d > 0.5) discard;
            float glow = 1.0 - d * 2.0;
            glow = pow(glow, 2.0);
            vec3 col = mix(vec3(1.0, 0.8, 0.2), vec3(0.2, 1.0, 0.5), vAlpha);
            gl_FragColor = vec4(col, glow * vAlpha * 0.8);
        }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

const fireflies = new THREE.Points(fireflyGeo, fireflyMat);
scene.add(fireflies);

// Sparkle dust particles near water
const sparkleCount = 200;
const sparkleGeo = new THREE.BufferGeometry();
const sparklePositions = new Float32Array(sparkleCount * 3);
for (let i = 0; i < sparkleCount; i++) {
    sparklePositions[i * 3] = (Math.random() - 0.5) * 100;
    sparklePositions[i * 3 + 1] = Math.random() * 0.5;
    sparklePositions[i * 3 + 2] = Math.random() * 40 - 10;
}
sparkleGeo.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));

const sparkleMat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
        uniform float uTime;
        varying float vAlpha;
        void main() {
            vec3 pos = position;
            float phase = pos.x * 0.1 + pos.z * 0.1;
            vAlpha = pow((sin(uTime * 5.0 + phase) + 1.0) * 0.5, 4.0);
            vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = 3.0 * (100.0 / -mvPos.z);
            gl_Position = projectionMatrix * mvPos;
        }
    `,
    fragmentShader: `
        varying float vAlpha;
        void main() {
            float d = length(gl_PointCoord - 0.5);
            if (d > 0.5) discard;
            gl_FragColor = vec4(1.0, 0.95, 0.8, (1.0 - d * 2.0) * vAlpha);
        }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

const sparkles = new THREE.Points(sparkleGeo, sparkleMat);
scene.add(sparkles);

// Seagulls
const birds = [];
for (let i = 0; i < 3; i++) {
    const bird = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 3), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    bird.position.set((Math.random() - 0.5) * 80, 15 + Math.random() * 8, (Math.random() - 0.5) * 80);
    bird.userData = { speed: 0.04 + Math.random() * 0.03, offset: Math.random() * Math.PI * 2 };
    scene.add(bird); birds.push(bird);
}

// Audio
let audioCtx = null, audioOn = false;
document.getElementById('audio-toggle').onclick = () => {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const d = buf.getChannelData(0); for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = true;
        const flt = audioCtx.createBiquadFilter(); flt.type = 'lowpass'; flt.frequency.value = 400;
        const gain = audioCtx.createGain(); gain.gain.value = 0.12;
        src.connect(flt); flt.connect(gain); gain.connect(audioCtx.destination); src.start();
        audioOn = true;
    } else {
        if (audioCtx.state === 'running') { audioCtx.suspend(); audioOn = false; }
        else { audioCtx.resume(); audioOn = true; }
    }
    const el = document.getElementById('audio-toggle');
    el.textContent = audioOn ? 'üîä Ocean Waves' : 'üîá Paused';
    el.classList.toggle('playing', audioOn);
};

// Bitcoin price
let price = 67432;
setInterval(() => {
    price += (Math.random() - 0.48) * 100;
    price = Math.max(60000, Math.min(75000, price));
    document.getElementById('price').textContent = '$' + Math.floor(price).toLocaleString();
    const chg = ((price - 67432) / 67432 * 100).toFixed(2);
    const up = chg >= 0;
    document.getElementById('change').textContent = (up ? '‚ñ≤ +' : '‚ñº ') + Math.abs(chg) + '%';
    document.getElementById('change').style.color = up ? '#00ff88' : '#ff6666';
}, 3000);

// Orbital camera settings
const orbitCenter = new THREE.Vector3(0, 0, 28); // Center of the beach village
const orbitRadius = 18; // Distance from center - closer for better visibility
const orbitSpeed = 0.06; // Rotation speed (radians per second) - slower for smoother view
const orbitHeight = 10; // Camera height - higher for better overview
const orbitHeightVariation = 1.0; // Gentle vertical bob

// Post-processing setup
let composer;
try {
    composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.35,  // strength - reduced to prevent white-out
        0.3,  // radius
        0.85   // threshold - higher to only bloom brightest areas
    );
    composer.addPass(bloomPass);
} catch(e) {
    console.log('Post-processing not available, using standard rendering');
    composer = null;
}

// Animation
function animate() {
    requestAnimationFrame(animate);
    const t = Date.now() * 0.001;
    ocean.material.uniforms.uTime.value = t;
    
    // Update particle systems
    if (fireflyMat) fireflyMat.uniforms.uTime.value = t;
    if (sparkleMat) sparkleMat.uniforms.uTime.value = t;
    if (godRaysMat) godRaysMat.uniforms.uTime.value = t;
    if (cloudMat) cloudMat.uniforms.uTime.value = t;
    
    // Animate torch lights flickering
    if (torch1) torch1.intensity = 1.0 + Math.sin(t * 10) * 0.3 + Math.sin(t * 15) * 0.2;
    if (torch2) torch2.intensity = 1.0 + Math.sin(t * 12 + 1) * 0.3 + Math.sin(t * 17) * 0.2;
    
    // Lighthouse beacon rotation
    if (lighthouseBeacon) {
        lighthouseBeacon.intensity = 2.0 + Math.sin(t * 3) * 0.5;
    }
    
    // Orbital camera rotation around the island
    const angle = t * orbitSpeed;
    const heightOffset = Math.sin(t * 0.3) * orbitHeightVariation;
    
    camera.position.x = orbitCenter.x + Math.cos(angle) * orbitRadius;
    camera.position.z = orbitCenter.z + Math.sin(angle) * orbitRadius;
    camera.position.y = orbitHeight + heightOffset;
    
    // Always look at the center of the build area
    camera.lookAt(orbitCenter.x, 2, orbitCenter.z);
    
    birds.forEach(b => { b.position.x += b.userData.speed; b.position.y += Math.sin(t * 2 + b.userData.offset) * 0.02; if (b.position.x > 50) b.position.x = -50; });
    
    // Animate UFOs
    ufos.forEach((ufo, idx) => {
        const d = ufo.userData;
        // Orbital movement
        const angle = t * d.orbitSpeed + d.orbitOffset;
        ufo.position.x = orbitCenter.x + Math.cos(angle) * d.orbitRadius;
        ufo.position.z = orbitCenter.z + Math.sin(angle) * d.orbitRadius;
        ufo.position.y = d.height + Math.sin(t * 0.5 + d.orbitOffset) * d.heightWobble;
        // Gentle tilt
        ufo.rotation.x = Math.sin(t * 2 + d.orbitOffset) * 0.1;
        ufo.rotation.z = Math.cos(t * 1.5 + d.orbitOffset) * 0.1;
        ufo.rotation.y += 0.02;
        // Abduction logic
        if (!d.isAbducting && Math.random() < 0.001) {
            d.isAbducting = true;
            d.abductionTimer = 0;
            playBeamSound();
            // Find available victim
            const availableVictim = victims.find(v => !v.visible);
            if (availableVictim) {
                availableVictim.visible = true;
                availableVictim.position.x = ufo.position.x;
                availableVictim.position.z = ufo.position.z;
                availableVictim.position.y = 0;
                availableVictim.userData.startY = 0;
                availableVictim.userData.floatProgress = 0;
                availableVictim.userData.targetUFO = ufo;
                d.abductionTarget = availableVictim;
            }
            updateAbductionStatus('ABDUCTING! üëΩ');
        }
        if (d.isAbducting) {
            d.abductionTimer += 0.016;
            const beamOpacity = Math.min(d.abductionTimer * 0.5, 0.4);
            d.beam.material.opacity = beamOpacity;
            d.light.intensity = beamOpacity * 3;
            if (d.abductionTarget) {
                d.abductionTarget.userData.floatProgress += 0.008;
                const progress = d.abductionTarget.userData.floatProgress;
                d.abductionTarget.position.y = progress * (ufo.position.y - 2);
                d.abductionTarget.position.x = ufo.position.x;
                d.abductionTarget.position.z = ufo.position.z;
                d.abductionTarget.rotation.y += 0.1;
                if (progress >= 1) {
                    d.abductionTarget.visible = false;
                    d.abductionTarget.userData.targetUFO = null;
                    d.abductionTarget = null;
                    playWooshSound();
                    updateAbductionStatus('Target acquired! üõ∏');
                }
            }
            if (d.abductionTimer > 5) {
                d.isAbducting = false;
                d.beam.material.opacity = 0;
                d.light.intensity = 0;
                updateAbductionStatus('Scanning...');
            }
        }
    });
    // Animate ring lights on UFOs
    ufos.forEach(ufo => {
        ufo.children.forEach((child, i) => {
            if (child.geometry && child.geometry.type === 'SphereGeometry' && child.material.color && child.position.y === -0.1) {
                const pulse = Math.sin(t * 8 + i) * 0.5 + 0.5;
                child.material.color.setHSL(0.4 + pulse * 0.1, 1, 0.5 + pulse * 0.3);
            }
        });
    });
    
    // Animate 3D Steve walking through the village
    const currentWP = steveWaypoints[steveWaypointIndex];
    const nextWP = steveWaypoints[(steveWaypointIndex + 1) % steveWaypoints.length];
    steveLerpProgress += steveMoveSpeed;
    if (steveLerpProgress >= 1) {
        steveLerpProgress = 0;
        steveWaypointIndex = (steveWaypointIndex + 1) % steveWaypoints.length;
    }
    steve3D.position.x = currentWP.x + (nextWP.x - currentWP.x) * steveLerpProgress;
    steve3D.position.z = currentWP.z + (nextWP.z - currentWP.z) * steveLerpProgress;
    // Face direction of movement
    steve3D.rotation.y = Math.atan2(nextWP.x - currentWP.x, nextWP.z - currentWP.z);
    // Walking animation
    const walkCycle = t * 8;
    steve3D.userData.leftLeg.rotation.x = Math.sin(walkCycle) * 0.5;
    steve3D.userData.rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
    steve3D.userData.leftArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.3;
    steve3D.userData.rightArm.rotation.x = Math.sin(walkCycle) * 0.3;
    steve3D.position.y = Math.abs(Math.sin(walkCycle)) * 0.05;
    
    // Animate all other villagers
    allVillagers.forEach((v, vi) => {
        const currentWP = v.waypoints[v.wpIndex()];
        const nextWP = v.waypoints[(v.wpIndex() + 1) % v.waypoints.length];
        let lerp = v.lerp() + v.speed;
        if (lerp >= 1) {
            lerp = 0;
            v.setWpIndex((v.wpIndex() + 1) % v.waypoints.length);
        }
        v.setLerp(lerp);
        v.model.position.x = currentWP.x + (nextWP.x - currentWP.x) * lerp;
        v.model.position.z = currentWP.z + (nextWP.z - currentWP.z) * lerp;
        v.model.rotation.y = Math.atan2(nextWP.x - currentWP.x, nextWP.z - currentWP.z);
        const vWalk = t * 8 + vi;
        v.model.userData.leftLeg.rotation.x = Math.sin(vWalk) * 0.5;
        v.model.userData.rightLeg.rotation.x = Math.sin(vWalk + Math.PI) * 0.5;
        v.model.userData.leftArm.rotation.x = Math.sin(vWalk + Math.PI) * 0.3;
        v.model.userData.rightArm.rotation.x = Math.sin(vWalk) * 0.3;
        v.model.position.y = Math.abs(Math.sin(vWalk)) * 0.05;
    });
    sky.rotation.y += 0.0001;
    
    // God rays follow camera
    if (godRays) {
        godRays.lookAt(camera.position);
    }
    
    // Use composer if available, otherwise standard render
    if (composer) {
        composer.render();
    } else {
        renderer.render(scene, camera);
    }
}
animate();

window.onresize = () => { 
    camera.aspect = innerWidth / innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(innerWidth, innerHeight);
    if (composer) composer.setSize(innerWidth, innerHeight);
};

// Stickman Steve - Autonomous Beach Resident
const steveActions = [
    { pose: 'üö∂', speech: 'Patrolling the beach! üèñÔ∏è' },
    { pose: 'üèÉ', speech: 'Gotta stay fit!' },
    { pose: 'üö∂', speech: 'Checking on the alien...' },
    { pose: 'üíÉ', speech: 'Dance break! üåÖ' },
    { pose: 'üèÉ', speech: 'Running to my hut!' },
    { pose: 'üö∂', speech: 'Love this sunset view...' },
    { pose: 'ü§∏', speech: 'Cartwheel time!' },
    { pose: 'üö∂', speech: 'BTC still pumping! üìà' },
    { pose: 'üèÉ', speech: 'Quick lap around!' },
    { pose: 'üö∂', speech: 'Hey alien buddy! üëΩ' },
    { pose: 'üôÜ', speech: 'Stretching mid-walk~' },
    { pose: 'üö∂', speech: 'Best patrol ever üòé' }
];
let currentSteveAction = 0;
let steveTask = null;

function updateSteve() {
    const body = document.getElementById('stickman-body');
    const speech = document.getElementById('stickman-speech');
    if (steveTask) {
        speech.textContent = steveTask;
        body.textContent = 'üèÉ';
    } else {
        currentSteveAction = Math.floor(Math.random() * steveActions.length);
        const action = steveActions[currentSteveAction];
        body.textContent = action.pose;
        speech.textContent = action.speech;
    }
}

// Steve changes action every 4 seconds
setInterval(updateSteve, 4000);

// Update Steve's location indicator
const locationNames = ['Surf Shop üèÑ', 'Market Stall üõí', 'Tiki Bar üçπ', 'Cottage üè†', 'BTC ATM ‚Çø', 'Beach Walk üèñÔ∏è'];
setInterval(() => {
    const locEl = document.getElementById('steve-location');
    if (locEl) locEl.textContent = 'üìç ' + locationNames[steveWaypointIndex];
}, 1000);

// Global function for chat to control Steve
window.commandSteve = function(task) {
    steveTask = task;
    updateSteve();
    setTimeout(() => { steveTask = null; }, 8000);
};

// Abduction status updater
function updateAbductionStatus(status) {
    const el = document.getElementById('ufo-activity');
    if (el) el.textContent = status;
}

// Initialize UFO audio on first interaction
document.body.addEventListener('click', () => {
    initUFOAudio();
}, { once: true });

// ========== VILLAGER BATCH COMMANDS ==========
let isDancing = false;
let isWarMode = false;
let warFighters = [];
let eliminatedVillagers = [];
let currentBattle = null;

const villagerNames = ['Maria', 'Jake', 'Luna', 'Max', 'Zara', 'Steve'];
const villagerModels = [maria, jake, luna, max, zara, steve3D];

// DANCE MODE - All villagers dance together!
function triggerDance() {
    if (isWarMode) return; // Can't dance during war
    isDancing = !isDancing;
    
    if (isDancing) {
        console.log('üéâ DANCE PARTY STARTED!');
        // Make all 3D villagers dance
        villagerModels.forEach((v, i) => {
            v.userData.dancing = true;
        });
        // Update HUD villager roster to show dancing
        document.querySelectorAll('.roster-item').forEach(el => {
            el.style.animation = 'villager-dance 0.5s ease-in-out infinite';
        });
        document.getElementById('stickman-speech').textContent = 'üï∫ DANCE PARTY! üíÉ';
    } else {
        console.log('Dance party ended');
        villagerModels.forEach(v => v.userData.dancing = false);
        document.querySelectorAll('.roster-item').forEach(el => {
            el.style.animation = '';
        });
    }
}

// WAR MODE - Tournament bracket!
function triggerWar() {
    if (isDancing) {
        isDancing = false;
        document.querySelectorAll('.roster-item').forEach(el => el.style.animation = '');
    }
    if (isWarMode) return; // Already in war
    
    isWarMode = true;
    warFighters = [...villagerNames];
    eliminatedVillagers = [];
    
    document.getElementById('war-bench').classList.add('active');
    document.getElementById('war-status').classList.add('active');
    document.getElementById('eliminated-list').innerHTML = '';
    
    console.log('‚öîÔ∏è WAR TOURNAMENT STARTED!');
    document.getElementById('stickman-speech').textContent = '‚öîÔ∏è TO BATTLE!';
    
    // Start the tournament
    runTournamentRound();
}

function runTournamentRound() {
    if (warFighters.length <= 1) {
        // We have a winner!
        endWar(warFighters[0]);
        return;
    }
    
    // Pick two random fighters
    const idx1 = Math.floor(Math.random() * warFighters.length);
    let idx2 = Math.floor(Math.random() * warFighters.length);
    while (idx2 === idx1) idx2 = Math.floor(Math.random() * warFighters.length);
    
    const fighter1 = warFighters[idx1];
    const fighter2 = warFighters[idx2];
    
    document.getElementById('war-status').innerHTML = `‚öîÔ∏è ${fighter1} VS ${fighter2}!`;
    
    // Animate the fighters
    const model1 = villagerModels[villagerNames.indexOf(fighter1)];
    const model2 = villagerModels[villagerNames.indexOf(fighter2)];
    
    if (model1) model1.userData.fighting = true;
    if (model2) model2.userData.fighting = true;
    
    // Battle duration
    setTimeout(() => {
        // Random winner
        const winner = Math.random() > 0.5 ? fighter1 : fighter2;
        const loser = winner === fighter1 ? fighter2 : fighter1;
        
        // Eliminate loser
        warFighters = warFighters.filter(f => f !== loser);
        eliminatedVillagers.push(loser);
        
        // Update bench
        const elimList = document.getElementById('eliminated-list');
        elimList.innerHTML += `<div class="eliminated">üíÄ ${loser}</div>`;
        
        // Update roster visual
        const rosterItems = document.querySelectorAll('.roster-item');
        rosterItems.forEach(item => {
            if (item.textContent.includes(loser.split(' ')[0])) {
                item.style.opacity = '0.3';
                item.style.textDecoration = 'line-through';
            }
        });
        
        document.getElementById('war-status').innerHTML = `üèÜ ${winner} WINS! ${loser} eliminated!`;
        
        if (model1) model1.userData.fighting = false;
        if (model2) model2.userData.fighting = false;
        
        // Next round after delay
        setTimeout(runTournamentRound, 2000);
    }, 2500);
}

function endWar(champion) {
    isWarMode = false;
    document.getElementById('war-status').innerHTML = `üëë ${champion} IS THE CHAMPION! üëë`;
    document.getElementById('war-status').style.background = 'rgba(255, 215, 0, 0.9)';
    
    setTimeout(() => {
        document.getElementById('war-bench').classList.remove('active');
        document.getElementById('war-status').classList.remove('active');
        document.getElementById('war-status').style.background = '';
        
        // Reset roster visuals
        document.querySelectorAll('.roster-item').forEach(item => {
            item.style.opacity = '1';
            item.style.textDecoration = '';
        });
        
        document.getElementById('stickman-speech').textContent = `${champion} is the champion! üëë`;
    }, 4000);
}

// Enhanced animation loop for dance/war modes
const originalAnimate = animate;
function enhancedVillagerAnimations(t) {
    villagerModels.forEach((v, i) => {
        if (v.userData.dancing) {
            // Exaggerated dance movements
            v.rotation.y += 0.15;
            v.position.y = 0.3 + Math.abs(Math.sin(t * 10 + i)) * 0.4;
            if (v.userData.leftArm) v.userData.leftArm.rotation.z = Math.sin(t * 8 + i) * 1.2;
            if (v.userData.rightArm) v.userData.rightArm.rotation.z = -Math.sin(t * 8 + i) * 1.2;
        }
        if (v.userData.fighting) {
            // Fighting shake
            v.position.x += (Math.random() - 0.5) * 0.1;
            v.position.z += (Math.random() - 0.5) * 0.1;
            v.rotation.y += (Math.random() - 0.5) * 0.2;
        }
    });
}

// Patch into main animation loop
const _origAnimFrame = animate;
setInterval(() => {
    if (isDancing || isWarMode) {
        enhancedVillagerAnimations(Date.now() * 0.001);
    }
}, 50);

// Global commands for chat integration
window.triggerDance = triggerDance;
window.triggerWar = triggerWar;
</script>
</body>
</html>