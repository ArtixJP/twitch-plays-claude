<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bitcoin Beach Sunset üåÖ</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Courier New', monospace; overflow: hidden; background: #1a0a2f; }
#canvas-container { width: 100vw; height: 100vh; position: relative; }
.hud {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    background: rgba(20, 10, 40, 0.4); backdrop-filter: blur(20px);
    padding: 15px 20px; border-radius: 20px;
    border: 1px solid rgba(255, 215, 0, 0.3);
    color: #ffd700; text-shadow: 0 0 10px #ff8c00;
}
.hud h1 { font-size: 1.2rem; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }
.btc-icon {
    width: 24px; height: 24px; background: linear-gradient(135deg, #f7931a, #ffb84d);
    border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-weight: bold; color: white; font-size: 14px;
}
.price { font-size: 1.8rem; font-weight: bold; color: #ffd700; text-shadow: 0 0 15px #ff8c00; }
.change { font-size: 0.9rem; margin-top: 5px; }
.beach-overlay {
    position: fixed; bottom: 0; left: 0; width: 100%; height: 30%;
    background: linear-gradient(to top, rgba(244, 214, 164, 0.3) 0%, rgba(255, 228, 181, 0.2) 40%, transparent 100%);
    pointer-events: none; z-index: 50;
}
.chill-message {
    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
    text-align: center; z-index: 100; color: #fff; font-size: 1.5rem;
    text-shadow: 0 0 20px rgba(255, 150, 100, 0.8);
    background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(15px);
    padding: 20px 30px; border-radius: 25px; border: 1px solid rgba(255, 255, 255, 0.2);
    animation: breathe 4s ease-in-out infinite;
}
.chill-message .emoji { font-size: 2rem; display: block; margin-bottom: 10px; }
@keyframes breathe { 0%, 100% { opacity: 0.8; transform: translateX(-50%) scale(1); } 50% { opacity: 1; transform: translateX(-50%) scale(1.05); } }
.beach-items { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 1.8rem; z-index: 100; }
.time-display { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #ffcc88; font-size: 1rem; text-shadow: 0 0 10px #ff8800; z-index: 100; }
.instruction { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #666; font-size: 0.7rem; text-align: center; z-index: 100; }
.instruction code { background: rgba(145, 71, 255, 0.2); padding: 2px 6px; border-radius: 4px; color: #bf94ff; }
.village-label {
    position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(247, 147, 26, 0.3), rgba(255, 200, 100, 0.2));
    backdrop-filter: blur(10px); padding: 8px 16px; border-radius: 15px;
    border: 1px solid rgba(255, 215, 0, 0.4); color: #ffd700;
    font-size: 0.85rem; text-shadow: 0 0 10px #ff8c00; z-index: 100;
    animation: village-glow 3s ease-in-out infinite;
}
@keyframes village-glow {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 200, 100, 0.3); }
    50% { box-shadow: 0 0 20px rgba(255, 200, 100, 0.6); }
}
.audio-indicator {
    position: absolute; top: 10px; right: 10px; z-index: 100; color: #00ccff;
    font-size: 0.8rem; cursor: pointer; background: rgba(0, 150, 200, 0.2);
    padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(0, 200, 255, 0.4);
}
.audio-indicator.playing { color: #00ff88; border-color: rgba(0, 255, 136, 0.4); text-shadow: 0 0 10px #00ff88; }
.alien-tourist { position: absolute; z-index: 140; text-align: center; animation: alien-chill 5s ease-in-out infinite; }
.alien-tourist .alien-body { font-size: 2rem; filter: drop-shadow(0 0 10px rgba(0, 255, 136, 0.6)); }
.alien-tourist .speech { background: rgba(0, 255, 136, 0.15); padding: 4px 8px; border-radius: 10px; font-size: 0.55rem; color: #00ff88; border: 1px solid rgba(0, 255, 136, 0.3); margin-top: 4px; }
.abduction-status {
    position: absolute; top: 100px; right: 10px; z-index: 100;
    background: rgba(0, 255, 136, 0.2); backdrop-filter: blur(10px);
    padding: 10px 15px; border-radius: 12px; border: 1px solid rgba(0, 255, 136, 0.4);
    color: #00ff88; font-size: 0.75rem; text-shadow: 0 0 10px #00ff88;
}
.abduction-status .ufo-icon { animation: ufo-pulse 1s ease-in-out infinite; display: inline-block; }
@keyframes ufo-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
.alien-1 { bottom: 100px; left: 30px; }

.stickman-home {
    position: absolute; bottom: 60px; right: 40px; z-index: 130;
    text-align: center;
}
.tiki-hut {
    font-size: 2.5rem; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    animation: hut-sway 6s ease-in-out infinite;
}
.hut-label {
    font-size: 0.5rem; color: #f4d6a4; margin-top: -5px;
    text-shadow: 0 0 5px rgba(139, 69, 19, 0.8);
}
@keyframes hut-sway { 0%, 100% { transform: rotate(-0.5deg); } 50% { transform: rotate(0.5deg); } }

.stickman-container {
    position: absolute; bottom: 70px; right: 20px; z-index: 135;
    text-align: center; background: rgba(20, 10, 40, 0.6); backdrop-filter: blur(10px);
    padding: 10px 15px; border-radius: 15px; border: 1px solid rgba(255, 200, 100, 0.3);
}
.steve-location {
    font-size: 0.5rem; color: #88ccff; margin-top: 4px;
}

.stickman {
    font-size: 1.8rem; filter: drop-shadow(0 0 8px rgba(255, 200, 100, 0.5));
    animation: steve-walk 0.4s ease-in-out infinite;
}
.stickman-footprints {
    position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%);
    font-size: 0.4rem; opacity: 0.4; white-space: nowrap;
    animation: footprints-fade 1s ease-out infinite;
}
@keyframes footprints-fade {
    0% { opacity: 0.4; } 100% { opacity: 0; }
}
.stickman-speech {
    position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.9); color: #333; padding: 6px 10px;
    border-radius: 12px; font-size: 0.6rem; white-space: nowrap;
    border: 2px solid #ffd700; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    animation: speech-bounce 3s ease-in-out infinite;
}
.stickman-speech::after {
    content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
    border: 6px solid transparent; border-top-color: rgba(255, 255, 255, 0.9);
}
.stickman-name {
    font-size: 0.5rem; color: #ffd700; margin-top: 2px;
    text-shadow: 0 0 5px #ff8c00;
}
@keyframes stickman-idle {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-3px) rotate(2deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-2px) rotate(-2deg); }
}
@keyframes steve-walk {
    0%, 100% { transform: translateY(0) rotate(-3deg); }
    50% { transform: translateY(-5px) rotate(3deg); }
}
.stickman-container:hover .stickman {
    animation: steve-walk 0.3s ease-in-out infinite;
}
.villager-roster {
    position: absolute; bottom: 70px; left: 10px; z-index: 130;
    background: rgba(20, 10, 40, 0.7); backdrop-filter: blur(10px);
    padding: 10px 12px; border-radius: 12px;
    border: 1px solid rgba(255, 200, 100, 0.3);
    font-size: 0.55rem;
}
.roster-title {
    color: #ffd700; font-weight: bold; margin-bottom: 6px;
    text-shadow: 0 0 8px #ff8c00; font-size: 0.65rem;
}
.roster-item {
    color: #fff; margin: 3px 0; padding: 3px 6px; border-radius: 6px;
    display: flex; justify-content: space-between; gap: 8px;
}
.roster-item span { opacity: 0.7; font-style: italic; }
.roster-item.maria { background: rgba(255, 107, 107, 0.3); }
.roster-item.jake { background: rgba(255, 221, 68, 0.3); }
.roster-item.luna { background: rgba(153, 102, 204, 0.3); }
.roster-item.max { background: rgba(255, 68, 68, 0.3); }
.roster-item.zara { background: rgba(247, 147, 26, 0.3); }
@keyframes speech-bounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-3px); }
}
@keyframes alien-chill { 0%, 100% { transform: translateY(0) rotate(-2deg); } 50% { transform: translateY(-8px) rotate(2deg); } }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div class="beach-overlay"></div>
<div class="hud">
<h1><span class="btc-icon">‚Çø</span> BEACH BAR</h1>
<div class="price" id="price">$67,432</div>
<div class="change" id="change">‚ñ≤ +2.34%</div>
</div>
<div class="time-display">üåÖ Golden Hour</div>
<div class="chill-message">
<span class="emoji">üå¥‚òÄÔ∏èüåä</span>
<div>Just breathe... You're on Bitcoin Beach</div>
</div>
<div class="beach-items">üèñÔ∏è üå¥ üçπ ü¶Ä ‚õ±Ô∏è üèòÔ∏è</div>
<div class="village-label">
<span>‚ú® Bitcoin Beach Village ‚ú®</span>
</div>
<div class="alien-tourist alien-1">
<span class="alien-body">üëΩüçπ</span>
<div class="speech">Earth sunsets hit different üåÖ</div>
</div>
<div class="stickman-home">
<div class="tiki-hut">üõñ</div>
<div class="hut-label">Steve's Hut</div>
</div>
<div class="stickman-container" id="stickman">
<div class="stickman-speech" id="stickman-speech">Living my best beach life! üèñÔ∏è</div>
<div class="stickman" id="stickman-body">üè†</div>
<div class="stickman-name">Steve Status</div>
<div class="steve-location" id="steve-location">üìç Patrolling village...</div>
</div>
<div class="villager-roster">
<div class="roster-title">üèòÔ∏è Village Residents</div>
<div class="roster-item maria">üçπ Maria <span>Bartender</span></div>
<div class="roster-item jake">üèÑ Jake <span>Surf Instructor</span></div>
<div class="roster-item luna">üõí Luna <span>Market Vendor</span></div>
<div class="roster-item max">üèä Max <span>Lifeguard</span></div>
<div class="roster-item zara">‚Çø Zara <span>BTC Evangelist</span></div>
</div>
<div class="audio-indicator" id="audio-toggle">üåä Ocean Waves</div>
<div class="abduction-status" id="abduction-status">
<span class="ufo-icon">üõ∏</span> UFO Activity: <span id="ufo-activity">Scanning...</span>
</div>
<p class="instruction">Type <code>!idea your idea</code> in chat to modify this world</p>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xff7744, 80, 400);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(-15, 4, 15);
camera.lookAt(5, 0, 30);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xff6b35);
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Sky
const skyGeo = new THREE.SphereGeometry(500, 32, 32);
const skyCanvas = document.createElement('canvas');
skyCanvas.width = 512; skyCanvas.height = 256;
const skyCtx = skyCanvas.getContext('2d');
const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
skyGrad.addColorStop(0, '#1a0a3a'); skyGrad.addColorStop(0.3, '#ff4500');
skyGrad.addColorStop(0.5, '#ff6b35'); skyGrad.addColorStop(0.7, '#ffa07a'); skyGrad.addColorStop(1, '#ffcc88');
skyCtx.fillStyle = skyGrad; skyCtx.fillRect(0, 0, 512, 256);
const sunGrad = skyCtx.createRadialGradient(256, 140, 0, 256, 140, 40);
sunGrad.addColorStop(0, '#fffacd'); sunGrad.addColorStop(0.3, '#ffd700'); sunGrad.addColorStop(1, 'transparent');
skyCtx.fillStyle = sunGrad; skyCtx.fillRect(0, 0, 512, 256);
const sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(skyCanvas), side: THREE.BackSide }));
scene.add(sky);

// Ocean with shader
const oceanGeo = new THREE.PlaneGeometry(500, 500, 64, 64);
const oceanMat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uDeepColor: { value: new THREE.Color(0x003366) }, uShallowColor: { value: new THREE.Color(0x0088aa) }, uSunsetColor: { value: new THREE.Color(0xff6633) } },
    vertexShader: `uniform float uTime; varying vec2 vUv; varying float vElevation;
        void main() { vUv = uv; vec3 pos = position;
            float wave = sin(pos.x * 0.05 + uTime) * cos(pos.y * 0.03 + uTime * 0.7) * 1.5;
            wave += sin(pos.x * 0.1 + uTime * 1.5) * 0.5;
            vElevation = wave; pos.z += wave;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }`,
    fragmentShader: `uniform vec3 uDeepColor; uniform vec3 uShallowColor; uniform vec3 uSunsetColor;
        varying float vElevation; varying vec2 vUv;
        void main() { float depth = smoothstep(-1.0, 2.0, vElevation);
            vec3 color = mix(uDeepColor, uShallowColor, depth);
            color = mix(color, uSunsetColor, smoothstep(0.6, 0.0, vUv.y) * 0.5);
            color += vec3(1.0, 0.9, 0.7) * smoothstep(0.8, 1.5, vElevation) * 0.4;
            gl_FragColor = vec4(color, 0.92); }`,
    transparent: true, side: THREE.DoubleSide
});
const ocean = new THREE.Mesh(oceanGeo, oceanMat);
ocean.rotation.x = -Math.PI / 2; ocean.position.y = -0.5;
scene.add(ocean);

// Beach
const beach = new THREE.Mesh(new THREE.PlaneGeometry(100, 50), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
beach.rotation.x = -Math.PI / 2; beach.position.set(0, -0.3, 30);
scene.add(beach);

// 3D Village Buildings
function createTikiBar(x, z) {
    const g = new THREE.Group();
    // Base platform
    const base = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, 0.3, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
    base.position.y = 0.15; g.add(base);
    // Bamboo poles
    for (let i = 0; i < 4; i++) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2.5, 6), new THREE.MeshPhongMaterial({ color: 0xdeb887 }));
        pole.position.set(Math.cos(i * Math.PI/2) * 1.5, 1.25, Math.sin(i * Math.PI/2) * 1.5); g.add(pole);
    }
    // Thatched roof
    const roof = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.5, 8), new THREE.MeshPhongMaterial({ color: 0xd2691e }));
    roof.position.y = 3; g.add(roof);
    // Bar counter
    const counter = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 0.4), new THREE.MeshPhongMaterial({ color: 0x654321 }));
    counter.position.set(0, 0.7, 1.2); g.add(counter);
    g.position.set(x, 0, z); return g;
}

function createSurfShop(x, z) {
    const g = new THREE.Group();
    // Main building
    const building = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 2.5), new THREE.MeshPhongMaterial({ color: 0x87ceeb }));
    building.position.y = 1.25; g.add(building);
    // Roof
    const roof = new THREE.Mesh(new THREE.BoxGeometry(3.4, 0.3, 2.9), new THREE.MeshPhongMaterial({ color: 0xff6347 }));
    roof.position.y = 2.65; g.add(roof);
    // Surfboard rack
    for (let i = 0; i < 3; i++) {
        const boardGroup = new THREE.Group();
        const boardBody = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1.8, 8), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        const boardTip = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 4), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        const boardTail = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 4), new THREE.MeshPhongMaterial({ color: [0xffff00, 0xff69b4, 0x00ff00][i] }));
        boardTip.position.y = 0.9; boardTail.position.y = -0.9;
        boardGroup.add(boardBody); boardGroup.add(boardTip); boardGroup.add(boardTail);
        boardGroup.position.set(-1.7, 1 + i * 0.1, -0.5 + i * 0.5); boardGroup.rotation.z = Math.PI / 8; g.add(boardGroup);
    }
    // Sign
    const sign = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.1), new THREE.MeshPhongMaterial({ color: 0xffd700 }));
    sign.position.set(0, 2.2, 1.3); g.add(sign);
    g.position.set(x, 0, z); return g;
}

function createCottage(x, z) {
    const g = new THREE.Group();
    // Walls
    const walls = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 2), new THREE.MeshPhongMaterial({ color: 0xffefd5 }));
    walls.position.y = 1; g.add(walls);
    // Pitched roof
    const roofGeo = new THREE.ConeGeometry(2, 1.2, 4);
    const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({ color: 0x8b0000 }));
    roof.position.y = 2.6; roof.rotation.y = Math.PI / 4; g.add(roof);
    // Door
    const door = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.1), new THREE.MeshPhongMaterial({ color: 0x654321 }));
    door.position.set(0, 0.5, 1.05); g.add(door);
    // Window
    const window1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.1), new THREE.MeshPhongMaterial({ color: 0x87ceeb, emissive: 0x4444aa, emissiveIntensity: 0.3 }));
    window1.position.set(0.7, 1.2, 1.05); g.add(window1);
    g.position.set(x, 0, z); return g;
}

function createLighthouse(x, z) {
    const g = new THREE.Group();
    // Tower
    const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1, 5, 12), new THREE.MeshPhongMaterial({ color: 0xffffff }));
    tower.position.y = 2.5; g.add(tower);
    // Red stripes
    for (let i = 0; i < 3; i++) {
        const stripe = new THREE.Mesh(new THREE.CylinderGeometry(0.75 - i*0.1, 0.85 - i*0.1, 0.5, 12), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
        stripe.position.y = 1 + i * 1.5; g.add(stripe);
    }
    // Light room
    const lightRoom = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.6, 0.8, 12), new THREE.MeshPhongMaterial({ color: 0x333333 }));
    lightRoom.position.y = 5.2; g.add(lightRoom);
    // Light beacon
    const beacon = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 0.8 }));
    beacon.position.y = 5.2; g.add(beacon);
    // Roof
    const roof = new THREE.Mesh(new THREE.ConeGeometry(0.8, 0.6, 12), new THREE.MeshPhongMaterial({ color: 0x8b0000 }));
    roof.position.y = 5.9; g.add(roof);
    g.position.set(x, 0, z); return g;
}

function createMarketStall(x, z) {
    const g = new THREE.Group();
    // Counter
    const counter = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 1), new THREE.MeshPhongMaterial({ color: 0xdeb887 }));
    counter.position.y = 0.4; g.add(counter);
    // Canopy poles
    for (let i = 0; i < 4; i++) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
        pole.position.set((i % 2) * 1.6 - 0.8, 1.55, (Math.floor(i/2)) * 0.8 - 0.4); g.add(pole);
    }
    // Colorful canopy
    const canopy = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.1, 1.2), new THREE.MeshPhongMaterial({ color: 0xff6b35 }));
    canopy.position.y = 2.3; g.add(canopy);
    // Goods on display
    for (let i = 0; i < 5; i++) {
        const item = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), new THREE.MeshPhongMaterial({ color: [0xff0000, 0xffa500, 0xffff00, 0x00ff00, 0x800080][i] }));
        item.position.set(-0.6 + i * 0.3, 0.95, 0); g.add(item);
    }
    g.position.set(x, 0, z); return g;
}

function createBitcoinATM(x, z) {
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.6), new THREE.MeshPhongMaterial({ color: 0xf7931a }));
    body.position.y = 0.9; g.add(body);
    const screen = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.05), new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 0.5 }));
    screen.position.set(0, 1.3, 0.33); g.add(screen);
    g.position.set(x, 0, z); return g;
}

// Add village buildings
const tikiBar = createTikiBar(-5, 26);
scene.add(tikiBar);

const surfShop = createSurfShop(6, 24);
scene.add(surfShop);

const cottage = createCottage(-2, 32);
scene.add(cottage);

const lighthouse = createLighthouse(12, 30);
scene.add(lighthouse);

const marketStall = createMarketStall(2, 28);
scene.add(marketStall);

const btcATM = createBitcoinATM(0, 25);
scene.add(btcATM);

// UFO Fleet - Alien Ships
const ufos = [];
function createUFO() {
    const g = new THREE.Group();
    // Main saucer body
    const saucerTop = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x88aacc, metalness: 0.8, emissive: 0x224466, emissiveIntensity: 0.3 })
    );
    saucerTop.scale.y = 0.4;
    g.add(saucerTop);
    // Bottom dome
    const saucerBottom = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x556677, metalness: 0.9 })
    );
    saucerBottom.scale.y = 0.25;
    g.add(saucerBottom);
    // Cockpit dome
    const cockpit = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 12, 8),
        new THREE.MeshPhongMaterial({ color: 0x00ff88, emissive: 0x00ff44, emissiveIntensity: 0.6, transparent: true, opacity: 0.7 })
    );
    cockpit.position.y = 0.3;
    cockpit.scale.y = 0.6;
    g.add(cockpit);
    // Ring lights
    for (let i = 0; i < 8; i++) {
        const light = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 6, 6),
            new THREE.MeshBasicMaterial({ color: 0x00ffaa })
        );
        light.position.x = Math.cos(i * Math.PI / 4) * 1.0;
        light.position.z = Math.sin(i * Math.PI / 4) * 1.0;
        light.position.y = -0.1;
        g.add(light);
    }
    // Abduction beam (initially invisible)
    const beamGeo = new THREE.CylinderGeometry(0.3, 2, 15, 16, 1, true);
    const beamMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88, transparent: true, opacity: 0, side: THREE.DoubleSide 
    });
    const beam = new THREE.Mesh(beamGeo, beamMat);
    beam.position.y = -7.5;
    beam.name = 'beam';
    g.add(beam);
    // Point light for glow
    const ufoLight = new THREE.PointLight(0x00ff88, 0, 15);
    ufoLight.position.y = -1;
    g.add(ufoLight);
    g.userData = {
        beam: beam,
        light: ufoLight,
        orbitRadius: 15 + Math.random() * 20,
        orbitSpeed: 0.3 + Math.random() * 0.4,
        orbitOffset: Math.random() * Math.PI * 2,
        height: 18 + Math.random() * 10,
        heightWobble: Math.random() * 3,
        isAbducting: false,
        abductionTimer: 0,
        abductionTarget: null
    };
    return g;
}

// Create UFO fleet
for (let i = 0; i < 4; i++) {
    const ufo = createUFO();
    scene.add(ufo);
    ufos.push(ufo);
}

// Abduction victims (floating people being beamed up)
const victims = [];
function createVictim() {
    const g = new THREE.Group();
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 0.8;
    g.add(head);
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.6, 8), new THREE.MeshPhongMaterial({ color: 0xff6666 }));
    body.position.y = 0.4;
    g.add(body);
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.2, 0.6, 0);
    leftArm.rotation.z = Math.PI / 2.5;
    g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.2, 0.6, 0);
    rightArm.rotation.z = -Math.PI / 2.5;
    g.add(rightArm);
    g.visible = false;
    g.userData = { floatProgress: 0, startY: 0, targetUFO: null };
    return g;
}
for (let i = 0; i < 4; i++) {
    const victim = createVictim();
    scene.add(victim);
    victims.push(victim);
}

// UFO Sound Effects System
let ufoAudioCtx = null;
let ufoSounds = { hum: null, beam: null, woosh: null };
function initUFOAudio() {
    if (ufoAudioCtx) return;
    ufoAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // UFO Hum - low frequency oscillator
    const humOsc = ufoAudioCtx.createOscillator();
    humOsc.type = 'sine';
    humOsc.frequency.value = 80;
    const humGain = ufoAudioCtx.createGain();
    humGain.gain.value = 0.08;
    const humFilter = ufoAudioCtx.createBiquadFilter();
    humFilter.type = 'lowpass';
    humFilter.frequency.value = 200;
    humOsc.connect(humFilter);
    humFilter.connect(humGain);
    humGain.connect(ufoAudioCtx.destination);
    humOsc.start();
    ufoSounds.hum = { osc: humOsc, gain: humGain };
}
function playBeamSound() {
    if (!ufoAudioCtx) initUFOAudio();
    const osc = ufoAudioCtx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(2000, ufoAudioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, ufoAudioCtx.currentTime + 1.5);
    const gain = ufoAudioCtx.createGain();
    gain.gain.setValueAtTime(0.15, ufoAudioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ufoAudioCtx.currentTime + 1.5);
    const filter = ufoAudioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 800;
    filter.Q.value = 2;
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(ufoAudioCtx.destination);
    osc.start();
    osc.stop(ufoAudioCtx.currentTime + 1.5);
}
function playWooshSound() {
    if (!ufoAudioCtx) initUFOAudio();
    const bufferSize = ufoAudioCtx.sampleRate * 0.5;
    const buffer = ufoAudioCtx.createBuffer(1, bufferSize, ufoAudioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }
    const source = ufoAudioCtx.createBufferSource();
    source.buffer = buffer;
    const filter = ufoAudioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 1500;
    filter.Q.value = 1;
    const gain = ufoAudioCtx.createGain();
    gain.gain.value = 0.1;
    source.connect(filter);
    filter.connect(gain);
    gain.connect(ufoAudioCtx.destination);
    source.start();
}

// 3D Stickman Steve - Village Resident
function createStickmanSteve() {
    const g = new THREE.Group();
    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 1.7; g.add(head);
    // Body
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8), new THREE.MeshPhongMaterial({ color: 0x4488ff }));
    body.position.y = 1.2; g.add(body);
    // Arms
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.25, 1.3, 0); leftArm.rotation.z = Math.PI / 4; g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.25, 1.3, 0); rightArm.rotation.z = -Math.PI / 4; g.add(rightArm);
    // Legs
    const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    leftLeg.position.set(-0.1, 0.55, 0); g.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    rightLeg.position.set(0.1, 0.55, 0); g.add(rightLeg);
    // Hat (beach style)
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.1, 12), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
    hat.position.y = 1.95; g.add(hat);
    const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 12), new THREE.MeshPhongMaterial({ color: 0xf4d6a4 }));
    hatTop.position.y = 2.05; g.add(hatTop);
    // Name tag floating above
    g.userData = { leftLeg, rightLeg, leftArm, rightArm };
    return g;
}

const steve3D = createStickmanSteve();
steve3D.position.set(8, 0, 26);
scene.add(steve3D);

// Create other villagers with different roles
function createVillager(color, hatColor, role) {
    const g = new THREE.Group();
    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    head.position.y = 1.7; g.add(head);
    // Body with role-specific color
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8), new THREE.MeshPhongMaterial({ color: color }));
    body.position.y = 1.2; g.add(body);
    // Arms
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    leftArm.position.set(-0.25, 1.3, 0); leftArm.rotation.z = Math.PI / 4; g.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xffcc99 }));
    rightArm.position.set(0.25, 1.3, 0); rightArm.rotation.z = -Math.PI / 4; g.add(rightArm);
    // Legs
    const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    leftLeg.position.set(-0.1, 0.55, 0); g.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6), new THREE.MeshPhongMaterial({ color: 0x333366 }));
    rightLeg.position.set(0.1, 0.55, 0); g.add(rightLeg);
    // Role-specific hat
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.1, 12), new THREE.MeshPhongMaterial({ color: hatColor }));
    hat.position.y = 1.95; g.add(hat);
    const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 12), new THREE.MeshPhongMaterial({ color: hatColor }));
    hatTop.position.y = 2.05; g.add(hatTop);
    g.userData = { leftLeg, rightLeg, leftArm, rightArm, role };
    return g;
}

// Maria - Tiki Bar Bartender (Red apron)
const maria = createVillager(0xff6b6b, 0xd2691e, 'bartender');
maria.position.set(-5, 0, 26);
scene.add(maria);
const mariaWaypoints = [
    { x: -5, z: 26 }, { x: -4, z: 27 }, { x: -6, z: 26 }, { x: -5, z: 25 }
];
let mariaWPIndex = 0, mariaLerp = 0;

// Jake - Surf Instructor (Yellow shirt)
const jake = createVillager(0xffdd44, 0x00aaff, 'surfer');
jake.position.set(6, 0, 24);
scene.add(jake);
const jakeWaypoints = [
    { x: 6, z: 24 }, { x: 8, z: 22 }, { x: 4, z: 20 }, { x: 6, z: 22 }
];
let jakeWPIndex = 0, jakeLerp = 0;

// Luna - Market Vendor (Purple dress)
const luna = createVillager(0x9966cc, 0xff69b4, 'vendor');
luna.position.set(2, 0, 28);
scene.add(luna);
const lunaWaypoints = [
    { x: 2, z: 28 }, { x: 3, z: 29 }, { x: 1, z: 28 }, { x: 2, z: 27 }
];
let lunaWPIndex = 0, lunaLerp = 0;

// Max - Lifeguard (Red shorts)
const max = createVillager(0xff4444, 0xffffff, 'lifeguard');
max.position.set(0, 0, 20);
scene.add(max);
const maxWaypoints = [
    { x: 0, z: 20 }, { x: 5, z: 18 }, { x: -5, z: 18 }, { x: 0, z: 22 }
];
let maxWPIndex = 0, maxLerp = 0;

// Zara - Bitcoin Evangelist (Orange BTC shirt)
const zara = createVillager(0xf7931a, 0xf7931a, 'btc_evangelist');
zara.position.set(0, 0, 25);
scene.add(zara);
const zaraWaypoints = [
    { x: 0, z: 25 }, { x: -2, z: 32 }, { x: 6, z: 24 }, { x: 2, z: 28 }
];
let zaraWPIndex = 0, zaraLerp = 0;

const allVillagers = [
    { model: maria, waypoints: mariaWaypoints, wpIndex: () => mariaWPIndex, setWpIndex: (v) => mariaWPIndex = v, lerp: () => mariaLerp, setLerp: (v) => mariaLerp = v, speed: 0.006 },
    { model: jake, waypoints: jakeWaypoints, wpIndex: () => jakeWPIndex, setWpIndex: (v) => jakeWPIndex = v, lerp: () => jakeLerp, setLerp: (v) => jakeLerp = v, speed: 0.01 },
    { model: luna, waypoints: lunaWaypoints, wpIndex: () => lunaWPIndex, setWpIndex: (v) => lunaWPIndex = v, lerp: () => lunaLerp, setLerp: (v) => lunaLerp = v, speed: 0.005 },
    { model: max, waypoints: maxWaypoints, wpIndex: () => maxWPIndex, setWpIndex: (v) => maxWPIndex = v, lerp: () => maxLerp, setLerp: (v) => maxLerp = v, speed: 0.012 },
    { model: zara, waypoints: zaraWaypoints, wpIndex: () => zaraWPIndex, setWpIndex: (v) => zaraWPIndex = v, lerp: () => zaraLerp, setLerp: (v) => zaraLerp = v, speed: 0.007 }
];

// Steve's patrol waypoints around the village
const steveWaypoints = [
    { x: 8, z: 26 },   // Near surf shop
    { x: 2, z: 28 },   // Market stall
    { x: -5, z: 26 },  // Tiki bar
    { x: -2, z: 32 },  // Cottage
    { x: 0, z: 25 },   // BTC ATM
    { x: 6, z: 24 },   // Back to surf shop
];
let steveWaypointIndex = 0;
let steveLerpProgress = 0;
const steveMoveSpeed = 0.008;

// Palm trees
function createPalm(x, z) {
    const g = new THREE.Group();
    g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 4, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 })));
    g.children[0].position.y = 2;
    for (let i = 0; i < 6; i++) {
        const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 4), new THREE.MeshPhongMaterial({ color: 0x228b22 }));
        leaf.position.y = 4; leaf.rotation.z = (i / 6) * Math.PI * 2; leaf.rotation.x = Math.PI / 3;
        g.add(leaf);
    }
    g.position.set(x, 0, z); return g;
}
scene.add(createPalm(-8, 25)); scene.add(createPalm(10, 28)); scene.add(createPalm(-12, 32));

// Lights - Enhanced for village visibility
scene.add(new THREE.AmbientLight(0xffa07a, 0.9));
const sunLight = new THREE.DirectionalLight(0xffd700, 1.4);
sunLight.position.set(0, 20, -30); scene.add(sunLight);
const fillLight = new THREE.DirectionalLight(0xff9966, 0.6);
fillLight.position.set(-20, 15, 40); scene.add(fillLight);
const villageLight = new THREE.PointLight(0xffcc88, 1.2, 50);
villageLight.position.set(0, 8, 28); scene.add(villageLight);

// Seagulls
const birds = [];
for (let i = 0; i < 3; i++) {
    const bird = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 3), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    bird.position.set((Math.random() - 0.5) * 80, 15 + Math.random() * 8, (Math.random() - 0.5) * 80);
    bird.userData = { speed: 0.04 + Math.random() * 0.03, offset: Math.random() * Math.PI * 2 };
    scene.add(bird); birds.push(bird);
}

// Audio
let audioCtx = null, audioOn = false;
document.getElementById('audio-toggle').onclick = () => {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const d = buf.getChannelData(0); for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = true;
        const flt = audioCtx.createBiquadFilter(); flt.type = 'lowpass'; flt.frequency.value = 400;
        const gain = audioCtx.createGain(); gain.gain.value = 0.12;
        src.connect(flt); flt.connect(gain); gain.connect(audioCtx.destination); src.start();
        audioOn = true;
    } else {
        if (audioCtx.state === 'running') { audioCtx.suspend(); audioOn = false; }
        else { audioCtx.resume(); audioOn = true; }
    }
    const el = document.getElementById('audio-toggle');
    el.textContent = audioOn ? 'üîä Ocean Waves' : 'üîá Paused';
    el.classList.toggle('playing', audioOn);
};

// Bitcoin price
let price = 67432;
setInterval(() => {
    price += (Math.random() - 0.48) * 100;
    price = Math.max(60000, Math.min(75000, price));
    document.getElementById('price').textContent = '$' + Math.floor(price).toLocaleString();
    const chg = ((price - 67432) / 67432 * 100).toFixed(2);
    const up = chg >= 0;
    document.getElementById('change').textContent = (up ? '‚ñ≤ +' : '‚ñº ') + Math.abs(chg) + '%';
    document.getElementById('change').style.color = up ? '#00ff88' : '#ff6666';
}, 3000);

// Orbital camera settings
const orbitCenter = new THREE.Vector3(0, 0, 28); // Center of the beach village
const orbitRadius = 18; // Distance from center - closer for better visibility
const orbitSpeed = 0.06; // Rotation speed (radians per second) - slower for smoother view
const orbitHeight = 10; // Camera height - higher for better overview
const orbitHeightVariation = 1.0; // Gentle vertical bob

// Animation
function animate() {
    requestAnimationFrame(animate);
    const t = Date.now() * 0.001;
    ocean.material.uniforms.uTime.value = t;
    
    // Orbital camera rotation around the island
    const angle = t * orbitSpeed;
    const heightOffset = Math.sin(t * 0.3) * orbitHeightVariation;
    
    camera.position.x = orbitCenter.x + Math.cos(angle) * orbitRadius;
    camera.position.z = orbitCenter.z + Math.sin(angle) * orbitRadius;
    camera.position.y = orbitHeight + heightOffset;
    
    // Always look at the center of the build area
    camera.lookAt(orbitCenter.x, 2, orbitCenter.z);
    
    birds.forEach(b => { b.position.x += b.userData.speed; b.position.y += Math.sin(t * 2 + b.userData.offset) * 0.02; if (b.position.x > 50) b.position.x = -50; });
    
    // Animate UFOs
    ufos.forEach((ufo, idx) => {
        const d = ufo.userData;
        // Orbital movement
        const angle = t * d.orbitSpeed + d.orbitOffset;
        ufo.position.x = orbitCenter.x + Math.cos(angle) * d.orbitRadius;
        ufo.position.z = orbitCenter.z + Math.sin(angle) * d.orbitRadius;
        ufo.position.y = d.height + Math.sin(t * 0.5 + d.orbitOffset) * d.heightWobble;
        // Gentle tilt
        ufo.rotation.x = Math.sin(t * 2 + d.orbitOffset) * 0.1;
        ufo.rotation.z = Math.cos(t * 1.5 + d.orbitOffset) * 0.1;
        ufo.rotation.y += 0.02;
        // Abduction logic
        if (!d.isAbducting && Math.random() < 0.001) {
            d.isAbducting = true;
            d.abductionTimer = 0;
            playBeamSound();
            // Find available victim
            const availableVictim = victims.find(v => !v.visible);
            if (availableVictim) {
                availableVictim.visible = true;
                availableVictim.position.x = ufo.position.x;
                availableVictim.position.z = ufo.position.z;
                availableVictim.position.y = 0;
                availableVictim.userData.startY = 0;
                availableVictim.userData.floatProgress = 0;
                availableVictim.userData.targetUFO = ufo;
                d.abductionTarget = availableVictim;
            }
            updateAbductionStatus('ABDUCTING! üëΩ');
        }
        if (d.isAbducting) {
            d.abductionTimer += 0.016;
            const beamOpacity = Math.min(d.abductionTimer * 0.5, 0.4);
            d.beam.material.opacity = beamOpacity;
            d.light.intensity = beamOpacity * 3;
            if (d.abductionTarget) {
                d.abductionTarget.userData.floatProgress += 0.008;
                const progress = d.abductionTarget.userData.floatProgress;
                d.abductionTarget.position.y = progress * (ufo.position.y - 2);
                d.abductionTarget.position.x = ufo.position.x;
                d.abductionTarget.position.z = ufo.position.z;
                d.abductionTarget.rotation.y += 0.1;
                if (progress >= 1) {
                    d.abductionTarget.visible = false;
                    d.abductionTarget.userData.targetUFO = null;
                    d.abductionTarget = null;
                    playWooshSound();
                    updateAbductionStatus('Target acquired! üõ∏');
                }
            }
            if (d.abductionTimer > 5) {
                d.isAbducting = false;
                d.beam.material.opacity = 0;
                d.light.intensity = 0;
                updateAbductionStatus('Scanning...');
            }
        }
    });
    // Animate ring lights on UFOs
    ufos.forEach(ufo => {
        ufo.children.forEach((child, i) => {
            if (child.geometry && child.geometry.type === 'SphereGeometry' && child.material.color && child.position.y === -0.1) {
                const pulse = Math.sin(t * 8 + i) * 0.5 + 0.5;
                child.material.color.setHSL(0.4 + pulse * 0.1, 1, 0.5 + pulse * 0.3);
            }
        });
    });
    
    // Animate 3D Steve walking through the village
    const currentWP = steveWaypoints[steveWaypointIndex];
    const nextWP = steveWaypoints[(steveWaypointIndex + 1) % steveWaypoints.length];
    steveLerpProgress += steveMoveSpeed;
    if (steveLerpProgress >= 1) {
        steveLerpProgress = 0;
        steveWaypointIndex = (steveWaypointIndex + 1) % steveWaypoints.length;
    }
    steve3D.position.x = currentWP.x + (nextWP.x - currentWP.x) * steveLerpProgress;
    steve3D.position.z = currentWP.z + (nextWP.z - currentWP.z) * steveLerpProgress;
    // Face direction of movement
    steve3D.rotation.y = Math.atan2(nextWP.x - currentWP.x, nextWP.z - currentWP.z);
    // Walking animation
    const walkCycle = t * 8;
    steve3D.userData.leftLeg.rotation.x = Math.sin(walkCycle) * 0.5;
    steve3D.userData.rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
    steve3D.userData.leftArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.3;
    steve3D.userData.rightArm.rotation.x = Math.sin(walkCycle) * 0.3;
    steve3D.position.y = Math.abs(Math.sin(walkCycle)) * 0.05;
    
    // Animate all other villagers
    allVillagers.forEach((v, vi) => {
        const currentWP = v.waypoints[v.wpIndex()];
        const nextWP = v.waypoints[(v.wpIndex() + 1) % v.waypoints.length];
        let lerp = v.lerp() + v.speed;
        if (lerp >= 1) {
            lerp = 0;
            v.setWpIndex((v.wpIndex() + 1) % v.waypoints.length);
        }
        v.setLerp(lerp);
        v.model.position.x = currentWP.x + (nextWP.x - currentWP.x) * lerp;
        v.model.position.z = currentWP.z + (nextWP.z - currentWP.z) * lerp;
        v.model.rotation.y = Math.atan2(nextWP.x - currentWP.x, nextWP.z - currentWP.z);
        const vWalk = t * 8 + vi;
        v.model.userData.leftLeg.rotation.x = Math.sin(vWalk) * 0.5;
        v.model.userData.rightLeg.rotation.x = Math.sin(vWalk + Math.PI) * 0.5;
        v.model.userData.leftArm.rotation.x = Math.sin(vWalk + Math.PI) * 0.3;
        v.model.userData.rightArm.rotation.x = Math.sin(vWalk) * 0.3;
        v.model.position.y = Math.abs(Math.sin(vWalk)) * 0.05;
    });
    sky.rotation.y += 0.0001;
    renderer.render(scene, camera);
}
animate();

window.onresize = () => { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };

// Stickman Steve - Autonomous Beach Resident
const steveActions = [
    { pose: 'üö∂', speech: 'Patrolling the beach! üèñÔ∏è' },
    { pose: 'üèÉ', speech: 'Gotta stay fit!' },
    { pose: 'üö∂', speech: 'Checking on the alien...' },
    { pose: 'üíÉ', speech: 'Dance break! üåÖ' },
    { pose: 'üèÉ', speech: 'Running to my hut!' },
    { pose: 'üö∂', speech: 'Love this sunset view...' },
    { pose: 'ü§∏', speech: 'Cartwheel time!' },
    { pose: 'üö∂', speech: 'BTC still pumping! üìà' },
    { pose: 'üèÉ', speech: 'Quick lap around!' },
    { pose: 'üö∂', speech: 'Hey alien buddy! üëΩ' },
    { pose: 'üôÜ', speech: 'Stretching mid-walk~' },
    { pose: 'üö∂', speech: 'Best patrol ever üòé' }
];
let currentSteveAction = 0;
let steveTask = null;

function updateSteve() {
    const body = document.getElementById('stickman-body');
    const speech = document.getElementById('stickman-speech');
    if (steveTask) {
        speech.textContent = steveTask;
        body.textContent = 'üèÉ';
    } else {
        currentSteveAction = Math.floor(Math.random() * steveActions.length);
        const action = steveActions[currentSteveAction];
        body.textContent = action.pose;
        speech.textContent = action.speech;
    }
}

// Steve changes action every 4 seconds
setInterval(updateSteve, 4000);

// Update Steve's location indicator
const locationNames = ['Surf Shop üèÑ', 'Market Stall üõí', 'Tiki Bar üçπ', 'Cottage üè†', 'BTC ATM ‚Çø', 'Beach Walk üèñÔ∏è'];
setInterval(() => {
    const locEl = document.getElementById('steve-location');
    if (locEl) locEl.textContent = 'üìç ' + locationNames[steveWaypointIndex];
}, 1000);

// Global function for chat to control Steve
window.commandSteve = function(task) {
    steveTask = task;
    updateSteve();
    setTimeout(() => { steveTask = null; }, 8000);
};

// Abduction status updater
function updateAbductionStatus(status) {
    const el = document.getElementById('ufo-activity');
    if (el) el.textContent = status;
}

// Initialize UFO audio on first interaction
document.body.addEventListener('click', () => {
    initUFOAudio();
}, { once: true });
</script>
</body>
</html>