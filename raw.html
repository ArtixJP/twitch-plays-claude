<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Rick and Morty 3D Portal Opening</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        #scene-container { width: 100vw; height: 100vh; }
        #episode-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Arial Black', sans-serif;
            font-size: 1rem;
            z-index: 300;
        }
        #gag-text {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: white;
            text-shadow: 2px 2px 4px black;
            text-align: center;
            opacity: 0;
            z-index: 200;
            font-family: 'Arial Black', sans-serif;
            transition: opacity 0.5s;
        }
        .instruction {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #a0aec0;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 300;
            font-family: Arial, sans-serif;
        }
        .instruction code {
            background: rgba(145, 71, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            color: #bf94ff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-family: 'Arial Black', sans-serif;
            font-size: 2rem;
            z-index: 400;
        }
        .speech-bubble {
            position: absolute;
            background: white;
            border-radius: 15px;
            padding: 10px 15px;
            font-family: 'Comic Sans MS', cursive;
            font-size: 0.9rem;
            max-width: 200px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
            z-index: 250;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent transparent;
        }
        .speech-bubble.rick { border: 3px solid #97E5E5; }
        .speech-bubble.morty { border: 3px solid #FFFF00; }
        .speech-bubble.summer { border: 3px solid #5DADE2; }
        .speech-bubble.beth { border: 3px solid #FFC0CB; }
        .speech-bubble.jerry { border: 3px solid #2E8B57; }
    </style>
</head>
<body>
<div id="scene-container"></div>
<div id="episode-counter">Episode: <span id="ep-num">1</span></div>
<div id="gag-text"></div>
<p class="instruction">Type <code>!idea your idea</code> in chat to modify the show!</p>
<div id="loading" style="display:none;">Opening Portal to Dimension C-137...</div>
<div class="speech-bubble rick" id="speech-rick"></div>
<div class="speech-bubble morty" id="speech-morty"></div>
<div class="speech-bubble summer" id="speech-summer"></div>
<div class="speech-bubble beth" id="speech-beth"></div>
<div class="speech-bubble jerry" id="speech-jerry"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const noteFreqs = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'A4': 440.00, 'A#4': 466.16,
            'C5': 523.25, 'E5': 659.25, 'F#5': 739.99, 'G5': 783.99, 'A5': 880.00
        };
        
        const melody = [
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A#4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'E4', duration: 0.2}, {note: 'G4', duration: 0.2}, {note: 'A4', duration: 0.4},
            {note: 'G4', duration: 0.2}, {note: 'E4', duration: 0.6}
        ];
        
        function playNote(freq, startTime, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.12, startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(startTime);
            osc.stop(startTime + duration);
        }
        
        function playTheme() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            let time = audioCtx.currentTime;
            melody.forEach(({note, duration}) => {
                if (noteFreqs[note]) playNote(noteFreqs[note], time, duration * 0.9);
                time += duration * 0.5;
            });
        }
        
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a2e); // Dark space background
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        // Materials
        const yellowMat = new THREE.MeshLambertMaterial({ color: 0xAFE1AF }); // Rick's skin tone
        const whiteMat = new THREE.MeshLambertMaterial({ color: 0xB8D4E3 }); // Lab coat
        const blueMat = new THREE.MeshLambertMaterial({ color: 0x97E5E5 }); // Rick's hair
        const greenMat = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Portal green
        const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 }); // Morty's shirt
        const redMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Morty's pants
        const babyBlueMat = new THREE.MeshLambertMaterial({ color: 0x5DADE2 }); // Summer
        const couchMat = new THREE.MeshLambertMaterial({ color: 0x444444 }); // Garage workbench
        const floorMat = new THREE.MeshLambertMaterial({ color: 0x555555 }); // Garage floor
        const wallMat = new THREE.MeshLambertMaterial({ color: 0x777777 }); // Garage wall
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0x00FF00, transparent: true, opacity: 0.6 }); // Portal clouds
        const portalMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.8 });
        
        // Create clouds
        const clouds = [];
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(1 + Math.random(), 16, 16),
                    cloudMat
                );
                sphere.position.set(Math.random() * 2 - 1, Math.random() * 0.5, Math.random() * 2 - 1);
                cloud.add(sphere);
            }
            cloud.position.set(x, y, z);
            cloud.userData = { speed: 0.01 + Math.random() * 0.02 };
            scene.add(cloud);
            clouds.push(cloud);
        }
        
        for (let i = 0; i < 20; i++) {
            createCloud(
                Math.random() * 60 - 30,
                5 + Math.random() * 10,
                Math.random() * 40 - 50
            );
        }
        
        // Create 3D Title
        const titleGroup = new THREE.Group();
        const titleGeo = new THREE.BoxGeometry(12, 2, 0.5);
        const titleMesh = new THREE.Mesh(titleGeo, yellowMat);
        titleGroup.add(titleMesh);
        
        // Add "RICK AND MORTY" text using boxes
        const letters = 'RICK & MORTY';
        for (let i = 0; i < letters.length; i++) {
            if (letters[i] !== ' ') {
                const letterBox = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                letterBox.position.set(-5 + i * 0.85, 0, 0.4);
                titleGroup.add(letterBox);
            }
        }
        titleGroup.position.set(0, 20, -30);
        scene.add(titleGroup);
        
        // Create character function
        function createCharacter(bodyColor, headHeight = 0.5, bodyHeight = 0.6, scale = 1) {
            const character = new THREE.Group();
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4 * scale, 16, 16), yellowMat);
            head.position.y = bodyHeight + 0.4 * scale;
            character.add(head);
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, bodyHeight, 16),
                bodyColor
            );
            body.position.y = bodyHeight / 2;
            character.add(body);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 0.4 * scale, 8);
            const leftLeg = new THREE.Mesh(legGeo, blueMat);
            leftLeg.position.set(-0.12 * scale, -0.2 * scale, 0);
            character.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, blueMat);
            rightLeg.position.set(0.12 * scale, -0.2 * scale, 0);
            character.add(rightLeg);
            
            return character;
        }
        
        // Create family
        const homer = createCharacter(whiteMat, 0.5, 0.7, 1.1); // Rick
        // Add Rick's spiky blue hair
        const rickHair = new THREE.Mesh(
            new THREE.ConeGeometry(0.35, 0.6, 8),
            blueMat
        );
        rickHair.position.y = 1.5;
        rickHair.rotation.z = 0.3;
        homer.add(rickHair);
        const rickHair2 = new THREE.Mesh(
            new THREE.ConeGeometry(0.25, 0.5, 8),
            blueMat
        );
        rickHair2.position.set(0.2, 1.4, 0);
        rickHair2.rotation.z = -0.4;
        homer.add(rickHair2);
        
        const marge = createCharacter(orangeMat, 0.5, 0.6, 0.85); // Morty
        // Morty's brown curly hair
        const mortyHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        mortyHair.position.y = 1.15;
        mortyHair.scale.set(1, 0.6, 1);
        marge.add(mortyHair);
        
        const bart = createCharacter(babyBlueMat, 0.4, 0.5, 0.85); // Summer
        // Summer's ponytail
        const summerHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0xFFB347 })
        );
        summerHair.position.y = 1.05;
        bart.add(summerHair);
        const ponytail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.15, 0.4, 8),
            new THREE.MeshLambertMaterial({ color: 0xFFB347 })
        );
        ponytail.position.set(0, 1.1, -0.2);
        ponytail.rotation.x = 0.5;
        bart.add(ponytail);
        
        const lisa = createCharacter(new THREE.MeshLambertMaterial({ color: 0xFFC0CB }), 0.35, 0.4, 0.9); // Beth
        // Beth's blonde hair
        const bethHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0xF0E68C })
        );
        bethHair.position.y = 0.95;
        bethHair.scale.set(1, 0.7, 1);
        lisa.add(bethHair);
        
        const maggie = createCharacter(new THREE.MeshLambertMaterial({ color: 0x2E8B57 }), 0.3, 0.5, 0.95); // Jerry
        // Jerry's boring hair
        const jerryHair = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 8, 8),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        jerryHair.position.y = 1.1;
        jerryHair.scale.set(1, 0.5, 1);
        maggie.add(jerryHair);
        
        const family = [homer, marge, bart, lisa, maggie];
        family.forEach(char => {
            char.position.set(20, 0, 0);
            char.visible = false;
            scene.add(char);
        });
        
        // Living room
        const livingRoom = new THREE.Group();
        
        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 15),
            floorMat
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        livingRoom.add(floor);
        
        // Back wall
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 10),
            wallMat
        );
        backWall.position.set(0, 4.5, -7);
        livingRoom.add(backWall);
        
        // Couch
        const couch = new THREE.Group();
        const couchBase = new THREE.Mesh(
            new THREE.BoxGeometry(5, 1, 1.5),
            couchMat
        );
        couchBase.position.y = 0;
        couch.add(couchBase);
        
        const couchBack = new THREE.Mesh(
            new THREE.BoxGeometry(5, 1.5, 0.3),
            couchMat
        );
        couchBack.position.set(0, 0.75, -0.6);
        couch.add(couchBack);
        
        couch.position.set(0, 0, 0);
        livingRoom.add(couch);
        
        // Portal Gun on workbench
        const portalGun = new THREE.Group();
        const gunBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.2, 0.8, 16),
            new THREE.MeshLambertMaterial({ color: 0x888888 })
        );
        gunBody.rotation.z = Math.PI / 2;
        portalGun.add(gunBody);
        
        const gunGlow = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x00FF00 })
        );
        gunGlow.position.x = 0.5;
        portalGun.add(gunGlow);
        
        portalGun.position.set(3, 1.2, -5);
        livingRoom.add(portalGun);
        
        // Floating Portal
        const portal = new THREE.Mesh(
            new THREE.TorusGeometry(1.5, 0.3, 16, 32),
            new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.7 })
        );
        portal.position.set(-4, 2, -5);
        livingRoom.add(portal);
        
        const portalCenter = new THREE.Mesh(
            new THREE.CircleGeometry(1.2, 32),
            new THREE.MeshBasicMaterial({ color: 0x90EE90, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
        );
        portalCenter.position.set(-4, 2, -4.9);
        livingRoom.add(portalCenter);
        
        livingRoom.position.set(0, 0, 50);
        livingRoom.visible = false;
        scene.add(livingRoom);
        
        // Pentagram and Satan summoning ritual
        const pentagramGroup = new THREE.Group();
        
        // Create pentagram using lines
        const pentagramMat = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 3 });
        const pentagramPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            pentagramPoints.push(new THREE.Vector3(Math.cos(angle) * 2, 0.01, Math.sin(angle) * 2));
        }
        const pentagramGeo = new THREE.BufferGeometry().setFromPoints(pentagramPoints);
        const pentagram = new THREE.Line(pentagramGeo, pentagramMat);
        pentagramGroup.add(pentagram);
        
        // Pentagram inner star
        const starPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = ((i * 2) % 5 * 2 * Math.PI / 5) - Math.PI / 2;
            starPoints.push(new THREE.Vector3(Math.cos(angle) * 2, 0.02, Math.sin(angle) * 2));
        }
        const starGeo = new THREE.BufferGeometry().setFromPoints(starPoints);
        const star = new THREE.Line(starGeo, pentagramMat);
        pentagramGroup.add(star);
        
        // Blood pool
        const bloodPool = new THREE.Mesh(
            new THREE.CircleGeometry(2.5, 32),
            new THREE.MeshBasicMaterial({ color: 0x8B0000, transparent: true, opacity: 0.7 })
        );
        bloodPool.rotation.x = -Math.PI / 2;
        bloodPool.position.y = 0.005;
        pentagramGroup.add(bloodPool);
        
        // Fire pillars at pentagram points
        const firePillars = [];
        for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            const fireGroup = new THREE.Group();
            
            // Fire base
            const fireBase = new THREE.Mesh(
                new THREE.ConeGeometry(0.3, 1.5, 8),
                new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0.9 })
            );
            fireBase.position.y = 0.75;
            fireGroup.add(fireBase);
            
            // Inner flame
            const innerFlame = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 1, 8),
                new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.8 })
            );
            innerFlame.position.y = 0.5;
            fireGroup.add(innerFlame);
            
            // Point light for glow
            const fireLight = new THREE.PointLight(0xFF4500, 1, 5);
            fireLight.position.y = 1;
            fireGroup.add(fireLight);
            
            fireGroup.position.set(Math.cos(angle) * 2.3, 0, Math.sin(angle) * 2.3);
            pentagramGroup.add(fireGroup);
            firePillars.push(fireGroup);
        }
        
        // SATAN - Interdimensional Demon Entity
        const satan = new THREE.Group();
        
        // Demonic body
        const demonBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.7, 2, 16),
            new THREE.MeshLambertMaterial({ color: 0x8B0000 })
        );
        demonBody.position.y = 1;
        satan.add(demonBody);
        
        // Demon head
        const demonHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshLambertMaterial({ color: 0x660000 })
        );
        demonHead.position.y = 2.5;
        satan.add(demonHead);
        
        // Horns
        const hornMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
        const leftHorn = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8, 8), hornMat);
        leftHorn.position.set(-0.3, 3, 0);
        leftHorn.rotation.z = 0.4;
        satan.add(leftHorn);
        
        const rightHorn = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8, 8), hornMat);
        rightHorn.position.set(0.3, 3, 0);
        rightHorn.rotation.z = -0.4;
        satan.add(rightHorn);
        
        // Glowing eyes
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), eyeMat);
        leftEye.position.set(-0.2, 2.6, 0.4);
        satan.add(leftEye);
        
        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), eyeMat);
        rightEye.position.set(0.2, 2.6, 0.4);
        satan.add(rightEye);
        
        // Wings
        const wingMat = new THREE.MeshLambertMaterial({ color: 0x330000, side: THREE.DoubleSide });
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(1.5, 1);
        wingShape.lineTo(2, 0.5);
        wingShape.lineTo(1.8, -0.5);
        wingShape.lineTo(0, -0.2);
        const wingGeo = new THREE.ShapeGeometry(wingShape);
        
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-0.5, 2, -0.3);
        leftWing.rotation.y = -0.5;
        satan.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(0.5, 2, -0.3);
        rightWing.rotation.y = Math.PI + 0.5;
        rightWing.scale.x = -1;
        satan.add(rightWing);
        
        // Trident
        const tridentStaff = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 3, 8),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        tridentStaff.position.set(0.8, 1.5, 0);
        satan.add(tridentStaff);
        
        const tridentHead = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.5, 3),
            new THREE.MeshLambertMaterial({ color: 0x8B0000 })
        );
        tridentHead.position.set(0.8, 3.2, 0);
        satan.add(tridentHead);
        
        satan.position.y = -3;
        satan.visible = false;
        pentagramGroup.add(satan);
        
        pentagramGroup.position.set(0, -0.4, 48);
        pentagramGroup.visible = false;
        scene.add(pentagramGroup);
        
        // Store references for animation
        window.pentagramGroup = pentagramGroup;
        window.satan = satan;
        window.firePillars = firePillars;
        
        // Grass ground
        const grassGround = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            floorMat
        );
        grassGround.rotation.x = -Math.PI / 2;
        grassGround.position.y = -1;
        scene.add(grassGround);
        
        // Camera initial position
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 5, 0);
        
        // Animation state
        let phase = 'clouds';
        let animationTime = 0;
        let episodeCount = 0;
        
        // Speech synthesis setup
        const synth = window.speechSynthesis;
        const voices = {
            rick: { pitch: 0.8, rate: 1.3 },
            morty: { pitch: 1.4, rate: 1.1 },
            summer: { pitch: 1.3, rate: 1.0 },
            beth: { pitch: 1.2, rate: 0.95 },
            jerry: { pitch: 0.9, rate: 0.85 }
        };
        
        const dialogues = {
            rick: [
                "Morty! *burp* We gotta go, Morty!",
                "I'm pickle Riiick! Wait, no I'm not.",
                "Wubba lubba dub dub!",
                "Science isn't about WHY, it's about WHY NOT!",
                "I turned myself into a couch potato, Morty!",
                "The universe is basically an animal. It grazes on the ordinary.",
                "Nobody exists on purpose. Watch TV."
            ],
            morty: [
                "Aw geez, Rick!",
                "I-I don't know about this, Rick!",
                "Oh man, oh geez, oh man!",
                "This is getting out of hand!",
                "Rick, I don't think this is a good idea!",
                "W-what are we even doing here, Rick?",
                "I'm in constant pain, Rick!"
            ],
            summer: [
                "Ugh, you guys are so embarrassing.",
                "This is literally the worst.",
                "I can't even right now.",
                "Mom! Grandpa's being weird again!",
                "Whatever, I'm going to my room.",
                "This family is SO dysfunctional."
            ],
            beth: [
                "Dad, please don't traumatize the kids.",
                "I'm a horse surgeon, not a therapist.",
                "Wine. I need wine.",
                "Jerry, this is your fault somehow.",
                "I'm the smart one in this family.",
                "At least I'm not Jerry."
            ],
            jerry: [
                "Can someone explain what's happening?",
                "I think I'm contributing!",
                "Nobody respects me in this house.",
                "I have a job interview... in my dreams.",
                "This is fine. Everything is fine.",
                "I'm not useless! I can... uh...",
                "Pluto IS a planet!"
            ]
        };
        
        function speak(character, text) {
            if (synth.speaking) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.pitch = voices[character].pitch;
            utterance.rate = voices[character].rate;
            utterance.volume = 0.7;
            synth.speak(utterance);
        }
        
        function showSpeechBubble(character, index) {
            const charNames = ['rick', 'morty', 'summer', 'beth', 'jerry'];
            const name = charNames[index];
            const bubble = document.getElementById('speech-' + name);
            const text = dialogues[name][Math.floor(Math.random() * dialogues[name].length)];
            
            bubble.textContent = text;
            bubble.style.opacity = '1';
            
            // Position based on character screen position
            const positions = [
                { left: '15%', top: '35%' },
                { left: '30%', top: '40%' },
                { left: '45%', top: '38%' },
                { left: '60%', top: '42%' },
                { left: '75%', top: '36%' }
            ];
            bubble.style.left = positions[index].left;
            bubble.style.top = positions[index].top;
            
            speak(name, text);
            
            setTimeout(() => {
                bubble.style.opacity = '0';
            }, 3000);
        }
        
        let dialogueTimer = 0;
        let lastSpeaker = -1;
        
        const couchGags = [
            { text: "Wubba lubba dub dub!", action: 'normal' },
            { text: "Rick portal-hops through dimensions!", action: 'bounce' },
            { text: "Portal vortex!", action: 'spin' },
            { text: "Shrink ray malfunction!", action: 'tiny' },
            { text: "Zero-G space adventure!", action: 'gravity' },
            { text: "Interdimensional orbit!", action: 'orbit' },
            { text: "Portal gun explosion!", action: 'explode' },
            { text: "Time freeze!", action: 'matrix' },
            { text: "Get schwifty!", action: 'schwifty' },
            { text: "THEY SUMMONED SOMETHING FROM DIMENSION 666!", action: 'satan' }
        ];
        
        let currentGag = couchGags[0];
        let gagStartTime = 0;
        
        function startEpisode() {
            episodeCount++;
            document.getElementById('ep-num').textContent = episodeCount;
            document.getElementById('gag-text').style.opacity = '0';
            
            phase = 'clouds';
            animationTime = 0;
            
            // Reset title
            titleGroup.position.set(0, 20, -30);
            titleGroup.rotation.set(0, 0, 0);
            
            // Reset family
            family.forEach((char, i) => {
                char.position.set(20 + i * 2, 0, 0);
                char.rotation.set(0, 0, 0);
                char.scale.set(1, 1, 1);
                char.visible = false;
            });
            
            // Reset couch
            couch.position.set(0, 0, 0);
            couch.rotation.set(0, 0, 0);
            couch.scale.set(1, 1, 1);
            
            livingRoom.visible = false;
            grassGround.visible = true;
            
            // Reset camera
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 5, 0);
            
            currentGag = couchGags[Math.floor(Math.random() * couchGags.length)];
            
            // Reset dialogue
            dialogueTimer = 0;
            lastSpeaker = -1;
            ['rick', 'morty', 'summer', 'beth', 'jerry'].forEach(name => {
                document.getElementById('speech-' + name).style.opacity = '0';
            });
            
            // Reset pentagram and satan
            if (window.pentagramGroup) {
                window.pentagramGroup.visible = false;
                window.satan.visible = false;
                window.satan.position.y = -3;
            }
            renderer.setClearColor(0x0a0a2e);
            
            playTheme();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            animationTime += 0.016;
            
            // Animate clouds
            clouds.forEach(cloud => {
                cloud.position.x -= cloud.userData.speed;
                if (cloud.position.x < -35) cloud.position.x = 35;
            });
            
            // Phase-based animation
            if (phase === 'clouds') {
                // Title flies through clouds
                titleGroup.position.z += 0.3;
                titleGroup.position.y = 8 + Math.sin(animationTime * 2) * 0.5;
                titleGroup.rotation.y = Math.sin(animationTime) * 0.1;
                
                camera.position.z = 15 + animationTime * 2;
                camera.lookAt(titleGroup.position);
                
                if (animationTime > 3) {
                    phase = 'running';
                    animationTime = 0;
                    family.forEach(char => char.visible = true);
                }
            } else if (phase === 'running') {
                // Family runs across screen
                family.forEach((char, i) => {
                    char.position.x = 15 - animationTime * 8 + i * 1.5;
                    char.position.y = Math.abs(Math.sin(animationTime * 10 + i)) * 0.3;
                    char.rotation.y = -Math.PI / 2;
                });
                
                camera.position.set(0, 3, 10);
                camera.lookAt(family[2].position);
                
                if (animationTime > 4) {
                    phase = 'livingroom';
                    animationTime = 0;
                    livingRoom.visible = true;
                    grassGround.visible = false;
                    gagStartTime = 0;
                }
            } else if (phase === 'livingroom') {
                // Living room scene
                camera.position.set(0, 4, 58);
                camera.lookAt(0, 1, 50);
                
                // Family enters and sits
                if (animationTime < 2) {
                    family.forEach((char, i) => {
                        const targetX = -2 + i * 1;
                        const targetZ = 50.5;
                        char.position.x += (targetX - char.position.x) * 0.05;
                        char.position.z += (targetZ - char.position.z) * 0.05;
                        char.position.y = 0.5 + Math.abs(Math.sin(animationTime * 8 + i)) * 0.2;
                        char.rotation.y = 0;
                    });
                } else {
                    // Apply couch gag
                    gagStartTime += 0.016;
                    document.getElementById('gag-text').textContent = currentGag.text;
                    document.getElementById('gag-text').style.opacity = '1';
                    
                    // Trigger random dialogue
                    dialogueTimer += 0.016;
                    if (dialogueTimer > 2.5) {
                        let speaker = Math.floor(Math.random() * 5);
                        while (speaker === lastSpeaker) speaker = Math.floor(Math.random() * 5);
                        lastSpeaker = speaker;
                        showSpeechBubble(family[speaker], speaker);
                        dialogueTimer = 0;
                    }
                    
                    applyGag(currentGag.action, gagStartTime);
                }
                
                if (animationTime > 7) {
                    startEpisode();
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function applyGag(action, time) {
            switch(action) {
                case 'bounce':
                    homer.position.y = 0.5 + Math.abs(Math.sin(time * 5)) * 3;
                    break;
                case 'spin':
                    couch.rotation.y = time * 3;
                    family.forEach((char, i) => {
                        char.position.x = Math.cos(time * 3 + i * 0.5) * 2.5;
                        char.position.z = 50 + Math.sin(time * 3 + i * 0.5) * 2.5;
                    });
                    break;
                case 'tiny':
                    family.forEach(char => char.scale.setScalar(0.3));
                    break;
                case 'gravity':
                    family.forEach((char, i) => {
                        char.position.y = 3 + Math.sin(time * 2 + i) * 1;
                        char.rotation.z = time;
                    });
                    break;
                case 'orbit':
                    family.forEach((char, i) => {
                        const angle = time * 2 + (i / 5) * Math.PI * 2;
                        char.position.x = Math.cos(angle) * 3;
                        char.position.z = 50 + Math.sin(angle) * 3;
                        char.position.y = 1 + Math.sin(time * 3) * 0.5;
                    });
                    break;
                case 'explode':
                    family.forEach((char, i) => {
                        char.position.x = Math.cos(i * 1.2) * time * 2;
                        char.position.z = 50 + Math.sin(i * 1.2) * time * 2;
                        char.position.y = time * 2;
                        char.rotation.x = time * 3;
                        char.rotation.z = time * 2;
                    });
                    break;
                case 'matrix':
                    camera.position.x = Math.cos(time * 0.5) * 8;
                    camera.position.z = 58 + Math.sin(time * 0.5) * 5;
                    camera.lookAt(0, 1, 50);
                    break;
                case 'schwifty':
                    family.forEach((char, i) => {
                        char.position.y = 0.5 + Math.sin(time * 8 + i) * 0.5;
                        char.rotation.y = Math.sin(time * 4) * 0.5;
                    });
                    break;
                case 'satan':
                    window.pentagramGroup.visible = true;
                    
                    // Animate fire pillars
                    window.firePillars.forEach((fire, i) => {
                        fire.children[0].scale.y = 1 + Math.sin(time * 10 + i) * 0.3;
                        fire.children[1].scale.y = 1 + Math.sin(time * 12 + i) * 0.4;
                        fire.children[2].intensity = 1 + Math.sin(time * 8 + i) * 0.5;
                    });
                    
                    // Satan rises from pentagram
                    window.satan.visible = true;
                    window.satan.position.y = Math.min(-3 + time * 1.5, 0);
                    window.satan.rotation.y = time * 0.5;
                    
                    // Blood pool pulses
                    window.pentagramGroup.children[2].material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
                    
                    // Family reacts in horror
                    family.forEach((char, i) => {
                        char.position.x = -2 + i * 1 + Math.sin(time * 15 + i) * 0.1;
                        char.position.z = 52 + time * 0.3;
                        char.rotation.y = Math.PI;
                    });
                    
                    // Camera shakes
                    camera.position.x = Math.sin(time * 20) * 0.1;
                    camera.position.y = 4 + Math.sin(time * 25) * 0.05;
                    
                    // Red lighting effect
                    renderer.setClearColor(new THREE.Color(0.1 + Math.sin(time * 5) * 0.05, 0, 0));
                    break;
                default:
                    family.forEach((char, i) => {
                        char.position.set(-2 + i * 1, 0.5, 50.5);
                    });
            }
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start
        document.getElementById('loading').style.display = 'none';
        animate();
        setTimeout(startEpisode, 1000);
    </script>
</body>
</html>