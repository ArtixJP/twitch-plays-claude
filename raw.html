<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bitcoin Rollercoaster 3D</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            overflow: hidden;
            background: #0a0a0f;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        .hud h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btc-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #f7931a, #ffb84d);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
        }
        .price {
            font-size: 2rem;
            font-weight: bold;
            transition: color 0.3s;
        }
        .price.up { color: #00ff88; text-shadow: 0 0 20px #00ff88; }
        .price.down { color: #ff4444; text-shadow: 0 0 20px #ff4444; }
        .change {
            font-size: 1rem;
            margin-top: 5px;
        }
        .instruction {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 0.8rem;
            text-align: center;
            z-index: 100;
        }
        .instruction code {
            background: rgba(145, 71, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: #bf94ff;
        }
        .scream {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div id="canvas-container"></div>
<div class="hud">
<h1><span class="btc-icon">â‚¿</span> BITCOIN COASTER</h1>
<div class="price up" id="price">$67,432.18</div>
<div class="change" id="change">â–² +2.34%</div>
</div>
<div class="scream" id="scream">ðŸ˜±</div>
<p class="instruction">
        Type <code>!idea your idea</code> in chat to modify this world
    </p>
<script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0f, 10, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0f);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Generate Bitcoin price data (simulated volatility)
        const priceData = [];
        let price = 50000;
        for (let i = 0; i < 200; i++) {
            const volatility = Math.sin(i * 0.1) * 0.03 + (Math.random() - 0.5) * 0.08;
            price *= (1 + volatility);
            price = Math.max(20000, Math.min(100000, price));
            priceData.push(price);
        }

        // Create track geometry
        const trackPoints = [];
        const minPrice = Math.min(...priceData);
        const maxPrice = Math.max(...priceData);
        
        priceData.forEach((p, i) => {
            const x = (i - 100) * 0.5;
            const y = ((p - minPrice) / (maxPrice - minPrice)) * 20 - 10;
            const z = 0;
            trackPoints.push(new THREE.Vector3(x, y, z));
        });

        const curve = new THREE.CatmullRomCurve3(trackPoints);
        
        // Track rails
        const tubeGeometry = new THREE.TubeGeometry(curve, 500, 0.15, 8, false);
        const trackMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xf7931a,
            emissive: 0xf7931a,
            emissiveIntensity: 0.3,
            shininess: 100
        });
        const track = new THREE.Mesh(tubeGeometry, trackMaterial);
        scene.add(track);

        // Second rail
        const rail2Points = trackPoints.map(p => new THREE.Vector3(p.x, p.y, p.z + 1));
        const curve2 = new THREE.CatmullRomCurve3(rail2Points);
        const tube2 = new THREE.TubeGeometry(curve2, 500, 0.15, 8, false);
        const track2 = new THREE.Mesh(tube2, trackMaterial);
        scene.add(track2);

        // Cross beams
        for (let i = 0; i < 200; i += 5) {
            const beamGeo = new THREE.BoxGeometry(0.1, 0.1, 1.3);
            const beam = new THREE.Mesh(beamGeo, new THREE.MeshPhongMaterial({ color: 0x444444 }));
            const point = curve.getPoint(i / 200);
            beam.position.set(point.x, point.y - 0.2, point.z + 0.5);
            scene.add(beam);
        }

        // Cart (the rider)
        const cartGroup = new THREE.Group();
        const cartBody = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.8, 1),
            new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 100 })
        );
        cartGroup.add(cartBody);
        
        // Rider (simple figure)
        const riderBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.25, 0.6, 8),
            new THREE.MeshPhongMaterial({ color: 0x4488ff })
        );
        riderBody.position.y = 0.7;
        cartGroup.add(riderBody);
        
        const riderHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshPhongMaterial({ color: 0xffcc99 })
        );
        riderHead.position.y = 1.2;
        cartGroup.add(riderHead);
        
        scene.add(cartGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(0, 30, 10);
        scene.add(spotLight);

        // Grid floor
        const gridHelper = new THREE.GridHelper(200, 50, 0x00ff88, 0x003322);
        gridHelper.position.y = -15;
        scene.add(gridHelper);

        // UFOs flying around
        const ufos = [];
        for (let i = 0; i < 5; i++) {
            const ufoGroup = new THREE.Group();
            
            // UFO body (disc)
            const ufoBody = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 2, 0.5, 16),
                new THREE.MeshPhongMaterial({ color: 0x88ff88, emissive: 0x22ff22, emissiveIntensity: 0.5, shininess: 150 })
            );
            ufoGroup.add(ufoBody);
            
            // UFO dome
            const ufoDome = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshPhongMaterial({ color: 0xaaffff, transparent: true, opacity: 0.7, shininess: 200 })
            );
            ufoDome.position.y = 0.25;
            ufoGroup.add(ufoDome);
            
            // Alien inside
            const alienHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0x44ff44 })
            );
            alienHead.position.y = 0.4;
            alienHead.scale.set(1, 1.3, 1);
            ufoGroup.add(alienHead);
            
            // Alien eyes
            const eyeGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000, emissive: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 0.45, 0.25);
            ufoGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 0.45, 0.25);
            ufoGroup.add(rightEye);
            
            // UFO lights ring
            for (let j = 0; j < 8; j++) {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff00ff })
                );
                const angle = (j / 8) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 1.7, 0, Math.sin(angle) * 1.7);
                ufoGroup.add(light);
            }
            
            ufoGroup.position.set(
                (Math.random() - 0.5) * 80,
                Math.random() * 20 + 10,
                (Math.random() - 0.5) * 40
            );
            ufoGroup.userData = {
                orbitRadius: 20 + Math.random() * 30,
                orbitSpeed: 0.2 + Math.random() * 0.3,
                orbitOffset: Math.random() * Math.PI * 2,
                hoverOffset: Math.random() * Math.PI * 2
            };
            scene.add(ufoGroup);
            ufos.push(ufoGroup);
        }

        // Mothership watching from above
        const mothershipGroup = new THREE.Group();
        const motherBody = new THREE.Mesh(
            new THREE.CylinderGeometry(8, 12, 3, 32),
            new THREE.MeshPhongMaterial({ color: 0x666688, emissive: 0x222244, shininess: 100 })
        );
        mothershipGroup.add(motherBody);
        const motherDome = new THREE.Mesh(
            new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshPhongMaterial({ color: 0x88ffff, transparent: true, opacity: 0.5 })
        );
        motherDome.position.y = 1.5;
        mothershipGroup.add(motherDome);
        // Mothership beam
        const beamGeo = new THREE.CylinderGeometry(0.5, 4, 30, 16, 1, true);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        beam.position.y = -16.5;
        mothershipGroup.add(beam);
        mothershipGroup.position.set(0, 45, -20);
        scene.add(mothershipGroup);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 1000; i++) {
            starPositions.push((Math.random() - 0.5) * 200);
            starPositions.push((Math.random() - 0.5) * 100 + 20);
            starPositions.push((Math.random() - 0.5) * 200);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const stars = new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
        scene.add(stars);

        // Animation
        let t = 0;
        let lastY = 0;
        const priceEl = document.getElementById('price');
        const changeEl = document.getElementById('change');
        const screamEl = document.getElementById('scream');

        function animate() {
            requestAnimationFrame(animate);
            
            t += 0.001;
            if (t > 1) t = 0;

            const position = curve.getPoint(t);
            const tangent = curve.getTangent(t);
            
            cartGroup.position.copy(position);
            cartGroup.position.z += 0.5;
            cartGroup.position.y += 0.5;
            
            // Tilt based on slope
            const lookAt = position.clone().add(tangent);
            cartGroup.lookAt(lookAt);

            // Smooth camera follow with interpolation
            const targetCamX = position.x - tangent.x * 8;
            const targetCamY = position.y + 4;
            const targetCamZ = position.z + 8;
            const lerpFactor = 0.03; // Lower = smoother/slower
            
            camera.position.x += (targetCamX - camera.position.x) * lerpFactor;
            camera.position.y += (targetCamY - camera.position.y) * lerpFactor;
            camera.position.z += (targetCamZ - camera.position.z) * lerpFactor;
            
            // Smooth look-at using a target object
            const targetLook = cartGroup.position.clone();
            if (!camera.userData.lookTarget) camera.userData.lookTarget = targetLook.clone();
            camera.userData.lookTarget.lerp(targetLook, lerpFactor * 2);
            camera.lookAt(camera.userData.lookTarget);

            // Update price display
            const currentPriceIndex = Math.floor(t * priceData.length);
            const currentPrice = priceData[currentPriceIndex] || priceData[0];
            priceEl.textContent = '$' + currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            
            const changePercent = ((currentPrice - priceData[0]) / priceData[0] * 100);
            const isUp = changePercent >= 0;
            changeEl.textContent = (isUp ? 'â–² +' : 'â–¼ ') + changePercent.toFixed(2) + '%';
            changeEl.style.color = isUp ? '#00ff88' : '#ff4444';
            priceEl.className = 'price ' + (isUp ? 'up' : 'down');

            // Animate UFOs
            ufos.forEach((ufo, i) => {
                const data = ufo.userData;
                const time = Date.now() * 0.001;
                ufo.position.x = Math.cos(time * data.orbitSpeed + data.orbitOffset) * data.orbitRadius;
                ufo.position.z = Math.sin(time * data.orbitSpeed + data.orbitOffset) * data.orbitRadius * 0.5 - 10;
                ufo.position.y = 15 + Math.sin(time * 2 + data.hoverOffset) * 3;
                ufo.rotation.y = time * 2;
                // UFO looks at the cart
                ufo.lookAt(cartGroup.position);
                ufo.rotation.x = 0;
                ufo.rotation.z = 0;
            });
            
            // Mothership slow rotation and beam pulse
            mothershipGroup.rotation.y += 0.002;
            beam.material.opacity = 0.1 + Math.sin(Date.now() * 0.003) * 0.1;

            // Scream on big drops
            const yDiff = position.y - lastY;
            if (yDiff < -0.15) {
                screamEl.style.opacity = '1';
                screamEl.textContent = ['ðŸ˜±', 'ðŸŽ¢', 'ðŸ“‰', 'ðŸ’€', 'ðŸ‘½', 'ðŸ›¸'][Math.floor(Math.random() * 6)];
            } else {
                screamEl.style.opacity = '0';
            }
            lastY = position.y;

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>