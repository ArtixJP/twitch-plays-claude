<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Voxel World - Twitch Plays</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 100;
            text-align: center;
        }
        .key {
            display: inline-block;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 5px 12px;
            margin: 2px;
            min-width: 30px;
            text-align: center;
        }
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #ffcc00;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #ffcc00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #inventory {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
            border: 2px solid #555;
        }
        .inv-slot {
            width: 50px;
            height: 50px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inv-slot:hover, .inv-slot.selected {
            border-color: #fff;
            transform: scale(1.1);
        }
        .inv-slot.selected {
            border-color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        .block-preview {
            width: 35px;
            height: 35px;
            border-radius: 3px;
        }
        #action-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 101;
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="hud">
<div>üéÆ VOXEL WORLD</div>
<div>Position: <span id="pos">0, 0, 0</span></div>
<div>Blocks: <span id="block-count">0</span></div>
</div>
<div id="mode-indicator">ü§ñ AUTO-EXPLORE MODE</div>
<div id="crosshair"></div>
<div id="inventory">
<div class="inv-slot selected" data-block="grass"><div class="block-preview" style="background: #4CAF50;"></div></div>
<div class="inv-slot" data-block="dirt"><div class="block-preview" style="background: #8B4513;"></div></div>
<div class="inv-slot" data-block="stone"><div class="block-preview" style="background: #808080;"></div></div>
<div class="inv-slot" data-block="wood"><div class="block-preview" style="background: #8B5A2B;"></div></div>
<div class="inv-slot" data-block="sand"><div class="block-preview" style="background: #F4D03F;"></div></div>
<div class="inv-slot" data-block="snow"><div class="block-preview" style="background: #FFFFFF;"></div></div>
<div class="inv-slot" data-block="gold"><div class="block-preview" style="background: #FFD700;"></div></div>
</div>
<div id="action-hint"></div>
<div id="controls-hint">
<span class="key">‚Üë</span> Forward
            <span class="key">‚Üì</span> Back
            <span class="key">‚Üê</span> Left
            <span class="key">‚Üí</span> Right
            <span class="key">SPACE</span> Up
            <span class="key">SHIFT</span> Down
            <span class="key">CLICK</span> Mine
            <span class="key">M</span> Place
        </div>
</div>
<script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Block materials (Minecraft-style colors)
        const materials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8B5A2B }),
            leaves: new THREE.MeshLambertMaterial({ color: 0x228B22, transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ color: 0xF4D03F }),
            water: new THREE.MeshLambertMaterial({ color: 0x3498DB, transparent: true, opacity: 0.7 }),
            snow: new THREE.MeshLambertMaterial({ color: 0xFFFFFF }),
            coal: new THREE.MeshLambertMaterial({ color: 0x2C2C2C }),
            gold: new THREE.MeshLambertMaterial({ color: 0xFFD700 }),
        };

        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let blockCount = 0;

        // Simple noise function for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 + 
                   Math.sin(x * 0.05 + 1) * Math.cos(z * 0.07) * 5 +
                   Math.sin(x * 0.02) * Math.sin(z * 0.02) * 8;
        }

        // Generate terrain
        const worldSize = 40;
        const blocks = [];

        function createBlock(x, y, z, material) {
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.push(block);
            blockCount++;
        }

        // Generate world
        for (let x = -worldSize; x < worldSize; x++) {
            for (let z = -worldSize; z < worldSize; z++) {
                const height = Math.floor(noise(x, z)) + 5;
                
                // Bedrock/stone layers
                for (let y = 0; y < height - 3; y++) {
                    if (Math.random() < 0.02) {
                        createBlock(x, y, z, materials.gold);
                    } else if (Math.random() < 0.05) {
                        createBlock(x, y, z, materials.coal);
                    } else {
                        createBlock(x, y, z, materials.stone);
                    }
                }
                
                // Dirt layers
                for (let y = Math.max(0, height - 3); y < height; y++) {
                    createBlock(x, y, z, materials.dirt);
                }
                
                // Surface layer
                if (height > 8) {
                    createBlock(x, height, z, materials.snow);
                } else if (height < 3) {
                    createBlock(x, height, z, materials.sand);
                    // Water
                    for (let y = height + 1; y <= 3; y++) {
                        createBlock(x, y, z, materials.water);
                    }
                } else {
                    createBlock(x, height, z, materials.grass);
                    
                    // Trees
                    if (Math.random() < 0.02 && height > 3) {
                        const treeHeight = 4 + Math.floor(Math.random() * 3);
                        for (let ty = 1; ty <= treeHeight; ty++) {
                            createBlock(x, height + ty, z, materials.wood);
                        }
                        // Leaves
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = treeHeight - 1; ly <= treeHeight + 2; ly++) {
                                    if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - treeHeight) < 4) {
                                        if (lx !== 0 || lz !== 0 || ly > treeHeight) {
                                            createBlock(x + lx, height + ly, z + lz, materials.leaves);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        document.getElementById('block-count').textContent = blockCount;

        // Raycaster for block selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Center of screen
        let selectedBlock = null;
        let selectedBlockType = 'grass';
        
        // Selection highlight
        const highlightGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const highlightMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.3,
            side: THREE.BackSide
        });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
        highlightMesh.visible = false;
        scene.add(highlightMesh);
        
        // Inventory slot selection
        document.querySelectorAll('.inv-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('selected'));
                slot.classList.add('selected');
                selectedBlockType = slot.dataset.block;
                showActionHint('Selected: ' + selectedBlockType.toUpperCase());
            });
        });
        
        function showActionHint(text) {
            const hint = document.getElementById('action-hint');
            hint.textContent = text;
            hint.style.opacity = '1';
            setTimeout(() => hint.style.opacity = '0', 1000);
        }
        
        // Mining (click to remove)
        renderer.domElement.addEventListener('click', (e) => {
            if (selectedBlock && blocks.includes(selectedBlock)) {
                scene.remove(selectedBlock);
                blocks.splice(blocks.indexOf(selectedBlock), 1);
                blockCount--;
                document.getElementById('block-count').textContent = blockCount;
                showActionHint('‚õèÔ∏è MINED!');
                highlightMesh.visible = false;
                selectedBlock = null;
            }
        });
        
        // Place block (M key)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM' && selectedBlock) {
                // Get the face normal to place block adjacent
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(blocks);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const normal = intersect.face.normal;
                    const newPos = new THREE.Vector3(
                        Math.round(intersect.object.position.x + normal.x),
                        Math.round(intersect.object.position.y + normal.y),
                        Math.round(intersect.object.position.z + normal.z)
                    );
                    createBlock(newPos.x, newPos.y, newPos.z, materials[selectedBlockType]);
                    document.getElementById('block-count').textContent = blockCount;
                    showActionHint('üß± PLACED!');
                }
            }
        });
        
        function updateBlockSelection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0 && intersects[0].distance < 10) {
                selectedBlock = intersects[0].object;
                highlightMesh.position.copy(selectedBlock.position);
                highlightMesh.visible = true;
            } else {
                selectedBlock = null;
                highlightMesh.visible = false;
            }
        }

        // Player setup
        const player = {
            x: 0,
            y: 15,
            z: 0,
            yaw: 0,
            pitch: 0,
            velocityY: 0,
            speed: 0.15,
            jumpForce: 0.3
        };

        camera.position.set(player.x, player.y, player.z);

        // Controls
        const keys = {};
        let autoMode = true;
        let autoTime = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'ShiftLeft'].includes(e.code)) {
                autoMode = false;
                document.getElementById('mode-indicator').textContent = 'üéÆ PLAYER CONTROL';
                document.getElementById('mode-indicator').style.color = '#00ff00';
                document.getElementById('mode-indicator').style.borderColor = '#00ff00';
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Re-enable auto mode after inactivity
        let inactivityTimer;
        document.addEventListener('keydown', () => {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                autoMode = true;
                document.getElementById('mode-indicator').textContent = 'ü§ñ AUTO-EXPLORE MODE';
                document.getElementById('mode-indicator').style.color = '#ffcc00';
                document.getElementById('mode-indicator').style.borderColor = '#ffcc00';
            }, 10000);
        });

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (autoMode) {
                // Auto-explore: fly around the world
                autoTime += 0.005;
                player.x = Math.sin(autoTime) * 30;
                player.z = Math.cos(autoTime) * 30;
                player.y = 20 + Math.sin(autoTime * 2) * 5;
                player.yaw = autoTime + Math.PI;
                player.pitch = -0.2 + Math.sin(autoTime * 3) * 0.1;
            } else {
                // Player control
                const moveX = Math.sin(player.yaw) * player.speed;
                const moveZ = Math.cos(player.yaw) * player.speed;

                if (keys['ArrowUp']) {
                    player.x -= moveX;
                    player.z -= moveZ;
                }
                if (keys['ArrowDown']) {
                    player.x += moveX;
                    player.z += moveZ;
                }
                if (keys['ArrowLeft']) {
                    player.yaw += 0.03;
                }
                if (keys['ArrowRight']) {
                    player.yaw -= 0.03;
                }
                if (keys['Space']) {
                    player.y += player.speed;
                }
                if (keys['ShiftLeft']) {
                    player.y -= player.speed;
                }
            }

            // Update camera
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            // Update block selection
            updateBlockSelection();
            
            // Update HUD
            document.getElementById('pos').textContent = 
                `${Math.floor(player.x)}, ${Math.floor(player.y)}, ${Math.floor(player.z)}`;

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>