<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Voxel World - Twitch Plays</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 100;
            text-align: center;
        }
        .key {
            display: inline-block;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 5px 12px;
            margin: 2px;
            min-width: 30px;
            text-align: center;
        }
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #ffcc00;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #ffcc00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #inventory {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
            border: 2px solid #555;
        }
        .inv-slot {
            width: 50px;
            height: 50px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inv-slot:hover, .inv-slot.selected {
            border-color: #fff;
            transform: scale(1.1);
        }
        .inv-slot.selected {
            border-color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        .block-preview {
            width: 35px;
            height: 35px;
            border-radius: 3px;
        }
        #action-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 101;
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="hud">
<div>üéÆ VOXEL WORLD</div>
<div>Position: <span id="pos">0, 0, 0</span></div>
<div>Blocks: <span id="block-count">0</span></div>
<div>Characters: <span id="char-count">20</span> üßë‚Äçüåæüêëüê∑üßô</div>
</div>
<div id="mode-indicator">ü§ñ AUTO-EXPLORE MODE</div>
<div id="crosshair"></div>
<div id="inventory">
<div class="inv-slot selected" data-block="grass"><div class="block-preview" style="background: #4CAF50;"></div></div>
<div class="inv-slot" data-block="dirt"><div class="block-preview" style="background: #8B4513;"></div></div>
<div class="inv-slot" data-block="stone"><div class="block-preview" style="background: #808080;"></div></div>
<div class="inv-slot" data-block="wood"><div class="block-preview" style="background: #8B5A2B;"></div></div>
<div class="inv-slot" data-block="sand"><div class="block-preview" style="background: #F4D03F;"></div></div>
<div class="inv-slot" data-block="snow"><div class="block-preview" style="background: #FFFFFF;"></div></div>
<div class="inv-slot" data-block="gold"><div class="block-preview" style="background: #FFD700;"></div></div>
</div>
<div id="action-hint"></div>
<div id="controls-hint">
<span class="key">‚Üë</span> Forward
            <span class="key">‚Üì</span> Back
            <span class="key">‚Üê</span> Left
            <span class="key">‚Üí</span> Right
            <span class="key">SPACE</span> Up
            <span class="key">SHIFT</span> Down
            <span class="key">CLICK</span> Mine
            <span class="key">M</span> Place
        </div>
</div>
<script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Block materials (Minecraft-style colors)
        const materials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8B5A2B }),
            leaves: new THREE.MeshLambertMaterial({ color: 0x228B22, transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ color: 0xF4D03F }),
            water: new THREE.MeshLambertMaterial({ color: 0x3498DB, transparent: true, opacity: 0.7 }),
            snow: new THREE.MeshLambertMaterial({ color: 0xFFFFFF }),
            coal: new THREE.MeshLambertMaterial({ color: 0x2C2C2C }),
            gold: new THREE.MeshLambertMaterial({ color: 0xFFD700 }),
        };

        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let blockCount = 0;

        // Simple noise function for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 + 
                   Math.sin(x * 0.05 + 1) * Math.cos(z * 0.07) * 5 +
                   Math.sin(x * 0.02) * Math.sin(z * 0.02) * 8;
        }

        // Generate terrain
        const worldSize = 40;
        const blocks = [];

        function createBlock(x, y, z, material) {
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.push(block);
            blockCount++;
        }

        // Generate world
        for (let x = -worldSize; x < worldSize; x++) {
            for (let z = -worldSize; z < worldSize; z++) {
                const height = Math.floor(noise(x, z)) + 5;
                
                // Bedrock/stone layers
                for (let y = 0; y < height - 3; y++) {
                    if (Math.random() < 0.02) {
                        createBlock(x, y, z, materials.gold);
                    } else if (Math.random() < 0.05) {
                        createBlock(x, y, z, materials.coal);
                    } else {
                        createBlock(x, y, z, materials.stone);
                    }
                }
                
                // Dirt layers
                for (let y = Math.max(0, height - 3); y < height; y++) {
                    createBlock(x, y, z, materials.dirt);
                }
                
                // Surface layer
                if (height > 8) {
                    createBlock(x, height, z, materials.snow);
                } else if (height < 3) {
                    createBlock(x, height, z, materials.sand);
                    // Water
                    for (let y = height + 1; y <= 3; y++) {
                        createBlock(x, y, z, materials.water);
                    }
                } else {
                    createBlock(x, height, z, materials.grass);
                    
                    // Trees
                    if (Math.random() < 0.02 && height > 3) {
                        const treeHeight = 4 + Math.floor(Math.random() * 3);
                        for (let ty = 1; ty <= treeHeight; ty++) {
                            createBlock(x, height + ty, z, materials.wood);
                        }
                        // Leaves
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = treeHeight - 1; ly <= treeHeight + 2; ly++) {
                                    if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - treeHeight) < 4) {
                                        if (lx !== 0 || lz !== 0 || ly > treeHeight) {
                                            createBlock(x + lx, height + ly, z + lz, materials.leaves);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        document.getElementById('block-count').textContent = blockCount;

        // === VOXEL CHARACTERS ===
        const characters = [];
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Character colors
        const skinColors = [0xFFDBB4, 0xE8B89D, 0xC68642, 0x8D5524];
        const shirtColors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFECE48, 0xAA96DA];
        const pantsColors = [0x2C3E50, 0x8B4513, 0x34495E, 0x1E3D59];

        function createVoxelCharacter(type, x, z) {
            const group = new THREE.Group();
            const terrainY = Math.floor(noise(x, z)) + 6;
            
            if (type === 'villager') {
                const skin = skinColors[Math.floor(Math.random() * skinColors.length)];
                const shirt = shirtColors[Math.floor(Math.random() * shirtColors.length)];
                const pants = pantsColors[Math.floor(Math.random() * pantsColors.length)];
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({color: skin}));
                head.position.y = 1.5;
                group.add(head);
                
                // Eyes
                const eyeMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
                leftEye.position.set(-0.12, 1.55, 0.25);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
                rightEye.position.set(0.12, 1.55, 0.25);
                group.add(rightEye);
                
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.3), new THREE.MeshLambertMaterial({color: shirt}));
                body.position.y = 0.95;
                group.add(body);
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({color: pants});
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), legMat);
                leftLeg.position.set(-0.12, 0.4, 0);
                leftLeg.name = 'leftLeg';
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), legMat);
                rightLeg.position.set(0.12, 0.4, 0);
                rightLeg.name = 'rightLeg';
                group.add(rightLeg);
                
                // Arms
                const armMat = new THREE.MeshLambertMaterial({color: skin});
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), armMat);
                leftArm.position.set(-0.35, 0.95, 0);
                leftArm.name = 'leftArm';
                group.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), armMat);
                rightArm.position.set(0.35, 0.95, 0);
                rightArm.name = 'rightArm';
                group.add(rightArm);
                
            } else if (type === 'sheep') {
                // Fluffy body
                const wool = new THREE.MeshLambertMaterial({color: 0xF5F5F5});
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), wool);
                body.position.y = 0.6;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.4), new THREE.MeshLambertMaterial({color: 0x333333}));
                head.position.set(0, 0.7, 0.7);
                group.add(head);
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({color: 0x333333});
                [[-0.25, 0.2, -0.35], [0.25, 0.2, -0.35], [-0.25, 0.2, 0.35], [0.25, 0.2, 0.35]].forEach((pos, i) => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), legMat);
                    leg.position.set(...pos);
                    leg.name = 'leg' + i;
                    group.add(leg);
                });
                
            } else if (type === 'pig') {
                const pink = new THREE.MeshLambertMaterial({color: 0xFFB6C1});
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.9), pink);
                body.position.y = 0.45;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.4, 0.4), pink);
                head.position.set(0, 0.5, 0.55);
                group.add(head);
                
                // Snout
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.1), new THREE.MeshLambertMaterial({color: 0xFF9999}));
                snout.position.set(0, 0.45, 0.8);
                group.add(snout);
                
                // Legs
                [[-0.2, 0.15, -0.25], [0.2, 0.15, -0.25], [-0.2, 0.15, 0.25], [0.2, 0.15, 0.25]].forEach((pos, i) => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.3, 0.12), pink);
                    leg.position.set(...pos);
                    leg.name = 'leg' + i;
                    group.add(leg);
                });
                
            } else if (type === 'wizard') {
                // Mysterious robed figure
                const robeColor = new THREE.MeshLambertMaterial({color: 0x4B0082});
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.4), robeColor);
                body.position.y = 0.7;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshLambertMaterial({color: 0xFFDBB4}));
                head.position.y = 1.4;
                group.add(head);
                
                // Wizard hat
                const hatBase = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.6), robeColor);
                hatBase.position.y = 1.65;
                group.add(hatBase);
                const hatTop = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), robeColor);
                hatTop.position.y = 1.9;
                group.add(hatTop);
                const hatTip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), robeColor);
                hatTip.position.y = 2.3;
                group.add(hatTip);
                
                // Glowing staff
                const staff = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1.5, 0.08), new THREE.MeshLambertMaterial({color: 0x8B4513}));
                staff.position.set(0.4, 0.9, 0);
                group.add(staff);
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), new THREE.MeshBasicMaterial({color: 0x00FFFF}));
                orb.position.set(0.4, 1.7, 0);
                orb.name = 'orb';
                group.add(orb);
                
                // Beard
                const beard = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.35, 0.15), new THREE.MeshLambertMaterial({color: 0xCCCCCC}));
                beard.position.set(0, 1.15, 0.22);
                group.add(beard);
            }
            
            group.position.set(x, terrainY, z);
            group.userData = {
                type: type,
                targetX: x,
                targetZ: z,
                wanderTimer: Math.random() * 100,
                walkPhase: Math.random() * Math.PI * 2
            };
            
            characterGroup.add(group);
            characters.push(group);
            return group;
        }

        // Spawn characters around the world
        for (let i = 0; i < 8; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('villager', x, z);
        }
        for (let i = 0; i < 6; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('sheep', x, z);
        }
        for (let i = 0; i < 5; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('pig', x, z);
        }
        // One mysterious wizard
        createVoxelCharacter('wizard', 10, 10);

        function updateCharacters(time) {
            characters.forEach(char => {
                const data = char.userData;
                data.wanderTimer -= 0.016;
                
                // Pick new target when timer runs out
                if (data.wanderTimer <= 0) {
                    data.targetX = char.position.x + (Math.random() - 0.5) * 10;
                    data.targetZ = char.position.z + (Math.random() - 0.5) * 10;
                    data.targetX = Math.max(-35, Math.min(35, data.targetX));
                    data.targetZ = Math.max(-35, Math.min(35, data.targetZ));
                    data.wanderTimer = 3 + Math.random() * 5;
                }
                
                // Move towards target
                const dx = data.targetX - char.position.x;
                const dz = data.targetZ - char.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                
                if (dist > 0.5) {
                    const speed = data.type === 'wizard' ? 0.02 : 0.03;
                    char.position.x += (dx / dist) * speed;
                    char.position.z += (dz / dist) * speed;
                    char.rotation.y = Math.atan2(dx, dz);
                    
                    // Update Y position based on terrain
                    const terrainY = Math.floor(noise(char.position.x, char.position.z)) + 6;
                    char.position.y = terrainY + (data.type === 'wizard' ? Math.sin(time * 2) * 0.3 : 0);
                    
                    // Animate legs/arms
                    data.walkPhase += 0.15;
                    char.children.forEach(part => {
                        if (part.name === 'leftLeg' || part.name === 'leg0' || part.name === 'leg2') {
                            part.rotation.x = Math.sin(data.walkPhase) * 0.5;
                        }
                        if (part.name === 'rightLeg' || part.name === 'leg1' || part.name === 'leg3') {
                            part.rotation.x = Math.sin(data.walkPhase + Math.PI) * 0.5;
                        }
                        if (part.name === 'leftArm') {
                            part.rotation.x = Math.sin(data.walkPhase + Math.PI) * 0.4;
                        }
                        if (part.name === 'rightArm') {
                            part.rotation.x = Math.sin(data.walkPhase) * 0.4;
                        }
                        // Wizard orb glow
                        if (part.name === 'orb') {
                            part.material.color.setHSL((time * 0.1) % 1, 1, 0.6);
                        }
                    });
                }
            });
        }

        // Raycaster for block selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Center of screen
        let selectedBlock = null;
        let selectedBlockType = 'grass';
        
        // Selection highlight
        const highlightGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const highlightMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.3,
            side: THREE.BackSide
        });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
        highlightMesh.visible = false;
        scene.add(highlightMesh);
        
        // Inventory slot selection
        document.querySelectorAll('.inv-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('selected'));
                slot.classList.add('selected');
                selectedBlockType = slot.dataset.block;
                showActionHint('Selected: ' + selectedBlockType.toUpperCase());
            });
        });
        
        function showActionHint(text) {
            const hint = document.getElementById('action-hint');
            hint.textContent = text;
            hint.style.opacity = '1';
            setTimeout(() => hint.style.opacity = '0', 1000);
        }
        
        // Mining (click to remove)
        renderer.domElement.addEventListener('click', (e) => {
            if (selectedBlock && blocks.includes(selectedBlock)) {
                scene.remove(selectedBlock);
                blocks.splice(blocks.indexOf(selectedBlock), 1);
                blockCount--;
                document.getElementById('block-count').textContent = blockCount;
                showActionHint('‚õèÔ∏è MINED!');
                highlightMesh.visible = false;
                selectedBlock = null;
            }
        });
        
        // Place block (M key)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM' && selectedBlock) {
                // Get the face normal to place block adjacent
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(blocks);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const normal = intersect.face.normal;
                    const newPos = new THREE.Vector3(
                        Math.round(intersect.object.position.x + normal.x),
                        Math.round(intersect.object.position.y + normal.y),
                        Math.round(intersect.object.position.z + normal.z)
                    );
                    createBlock(newPos.x, newPos.y, newPos.z, materials[selectedBlockType]);
                    document.getElementById('block-count').textContent = blockCount;
                    showActionHint('üß± PLACED!');
                }
            }
        });
        
        function updateBlockSelection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0 && intersects[0].distance < 10) {
                selectedBlock = intersects[0].object;
                highlightMesh.position.copy(selectedBlock.position);
                highlightMesh.visible = true;
            } else {
                selectedBlock = null;
                highlightMesh.visible = false;
            }
        }

        // Player setup - Calculate ground height at spawn
        const spawnHeight = Math.floor(noise(0, 0)) + 5 + 2; // +2 for player eye level above surface
        const player = {
            x: 0,
            y: spawnHeight,
            z: 0,
            yaw: 0,
            pitch: 0,
            velocityY: 0,
            speed: 0.15,
            jumpForce: 0.3
        };

        camera.position.set(player.x, player.y, player.z);

        // Controls
        const keys = {};
        let autoMode = true;
        let autoTime = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'ShiftLeft'].includes(e.code)) {
                autoMode = false;
                document.getElementById('mode-indicator').textContent = 'üéÆ PLAYER CONTROL';
                document.getElementById('mode-indicator').style.color = '#00ff00';
                document.getElementById('mode-indicator').style.borderColor = '#00ff00';
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Re-enable auto mode after inactivity
        let inactivityTimer;
        document.addEventListener('keydown', () => {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                autoMode = true;
                document.getElementById('mode-indicator').textContent = 'ü§ñ AUTO-EXPLORE MODE';
                document.getElementById('mode-indicator').style.color = '#ffcc00';
                document.getElementById('mode-indicator').style.borderColor = '#ffcc00';
            }, 10000);
        });

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (autoMode) {
                // Auto-explore: walk/fly around the world, staying closer to terrain
                autoTime += 0.005;
                player.x = Math.sin(autoTime) * 30;
                player.z = Math.cos(autoTime) * 30;
                // Calculate terrain height at current position for ground-following
                const terrainY = Math.floor(noise(player.x, player.z)) + 5;
                player.y = terrainY + 3 + Math.sin(autoTime * 2) * 2;
                player.yaw = autoTime + Math.PI;
                player.pitch = -0.2 + Math.sin(autoTime * 3) * 0.1;
            } else {
                // Player control
                const moveX = Math.sin(player.yaw) * player.speed;
                const moveZ = Math.cos(player.yaw) * player.speed;

                if (keys['ArrowUp']) {
                    player.x -= moveX;
                    player.z -= moveZ;
                }
                if (keys['ArrowDown']) {
                    player.x += moveX;
                    player.z += moveZ;
                }
                if (keys['ArrowLeft']) {
                    player.yaw += 0.03;
                }
                if (keys['ArrowRight']) {
                    player.yaw -= 0.03;
                }
                if (keys['Space']) {
                    player.y += player.speed;
                }
                if (keys['ShiftLeft']) {
                    player.y -= player.speed;
                }
            }

            // Update camera
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            // Update block selection
            updateBlockSelection();
            
            // Update characters
            updateCharacters(autoTime);

            // Update HUD
            document.getElementById('pos').textContent = 
                `${Math.floor(player.x)}, ${Math.floor(player.y)}, ${Math.floor(player.z)}`;

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>