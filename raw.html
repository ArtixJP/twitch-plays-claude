<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch plays Claude - Penalty Arena</title>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        h1 { 
            font-size: 2.5rem; 
            text-align: center; 
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(145, 71, 255, 0.6);
            position: relative;
            z-index: 10;
        }
        .instruction {
            text-align: center;
            font-size: 1rem;
            color: #a0aec0;
            max-width: 600px;
            margin: 0 auto;
            padding: 0 15px;
            line-height: 1.5;
        }
        .instruction code {
            background: rgba(145, 71, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            color: #bf94ff;
        }
        #penalty-arena {
            border: 3px solid #00ff88;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4), inset 0 0 20px rgba(0, 255, 136, 0.1);
            margin: 15px 0;
            position: relative;
            z-index: 5;
        }
        .ai-status {
            font-size: 0.9rem;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            z-index: 10;
        }
        .pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .score-display {
            font-size: 1.3rem;
            position: relative;
            z-index: 10;
            color: #ffdd57;
            text-shadow: 0 0 10px #ffdd57;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            display: flex;
            gap: 20px;
        }
        .goals { color: #00ff88; text-shadow: 0 0 10px #00ff88; }
        .saves { color: #ff4757; text-shadow: 0 0 10px #ff4757; }
        .football-bg {
            position: fixed;
            font-size: 2rem;
            animation: floatBg 8s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
            opacity: 0.3;
        }
        @keyframes floatBg {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }
        .result-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .result-flash.show { opacity: 1; }
        .result-flash.goal { color: #00ff88; text-shadow: 0 0 30px #00ff88; }
        .result-flash.save { color: #ff4757; text-shadow: 0 0 30px #ff4757; }
        
        .clipboard {
            position: fixed;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 180px;
            background: linear-gradient(145deg, #8B4513 0%, #654321 100%);
            border-radius: 8px 8px 4px 4px;
            padding: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 50;
            border: 2px solid #5D3A1A;
        }
        .clipboard::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 20px;
            background: linear-gradient(145deg, #C0C0C0 0%, #808080 100%);
            border-radius: 4px;
            border: 2px solid #606060;
        }
        .clipboard-title {
            font-size: 0.75rem;
            color: #FFD700;
            text-align: center;
            margin-bottom: 6px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .clipboard-paper {
            background: linear-gradient(#fffef0 0%, #f5f5dc 100%);
            border-radius: 2px;
            padding: 8px;
            min-height: 150px;
        }
        .todo-input-wrap {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        .todo-input {
            flex: 1;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.7rem;
            background: #fff;
            font-family: 'Comic Sans MS', cursive;
        }
        .todo-add {
            background: #00aa55;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
        }
        .todo-add:hover { background: #00cc66; }
        .todo-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 120px;
            overflow-y: auto;
        }
        .todo-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px 0;
            border-bottom: 1px dashed #ccc;
            font-size: 0.65rem;
            font-family: 'Comic Sans MS', cursive;
            color: #333;
        }
        .todo-item.done span { text-decoration: line-through; color: #999; }
        .todo-check {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #00aa55;
        }
        .todo-delete {
            margin-left: auto;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 2px;
            padding: 1px 4px;
            cursor: pointer;
            font-size: 0.6rem;
        }
        .mini-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            margin-bottom: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            padding: 3px;
        }
        .cal-header {
            font-size: 0.5rem;
            text-align: center;
            color: #666;
            font-weight: bold;
        }
        .cal-day {
            font-size: 0.5rem;
            text-align: center;
            padding: 2px;
            border-radius: 2px;
            cursor: pointer;
            color: #333;
        }
        .cal-day:hover { background: #ddd; }
        .cal-day.today { background: #00aa55; color: white; font-weight: bold; }
        .cal-day.has-task { background: #ffdd57; }
        .cal-day.has-task.today { background: #00cc66; }
        .recur-select {
            font-size: 0.6rem;
            padding: 2px;
            border-radius: 2px;
            border: 1px solid #ccc;
            background: #fff;
            margin-left: 4px;
        }
        .db-status {
            font-size: 0.5rem;
            color: #888;
            text-align: center;
            margin-top: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        .db-status .db-icon {
            color: #00aa55;
            animation: dbPulse 2s infinite;
        }
        @keyframes dbPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .firework {
            position: fixed;
            pointer-events: none;
            z-index: 200;
        }
        .firework-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: fireworkBurst 1.5s ease-out forwards;
        }
        @keyframes fireworkBurst {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        .firework-trail {
            position: fixed;
            width: 4px;
            height: 20px;
            background: linear-gradient(to top, transparent, var(--color));
            border-radius: 2px;
            animation: fireworkRise 0.6s ease-out forwards;
            z-index: 199;
            pointer-events: none;
        }
        @keyframes fireworkRise {
            0% { transform: translateY(0) scaleY(1); opacity: 1; }
            100% { transform: translateY(-150px) scaleY(0.3); opacity: 0; }
        }
        .firework-glow {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--color) 0%, transparent 70%);
            animation: fireworkGlow 0.8s ease-out forwards;
            transform: translate(-50%, -50%);
        }
        @keyframes fireworkGlow {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        .stadium-tv {
            position: fixed;
            left: 15px;
            top: 15%;
            width: 160px;
            background: #111;
            border: 4px solid #333;
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 0 20px rgba(0,0,0,0.6), inset 0 0 10px rgba(0,0,0,0.8);
            z-index: 45;
        }
        .stadium-tv::before {
            content: 'üì∫ STADIUM TV';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: #00ff88;
            background: #1a1a2e;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
        }
        .stadium-tv iframe {
            width: 100%;
            height: 90px;
            border-radius: 4px;
            border: none;
        }
        .tv-static {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.1) 2px,
                rgba(0,0,0,0.1) 4px
            );
            pointer-events: none;
            border-radius: 4px;
            animation: tvFlicker 0.1s infinite;
        }
        @keyframes tvFlicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.1; }
        }
        .intel-btn {
            position: fixed;
            left: 15px;
            top: 65%;
            transform: translateY(-50%);
            background: linear-gradient(145deg, #1a1a2e 0%, #0f0f1a 100%);
            border: 2px solid #ff4757;
            border-radius: 8px;
            padding: 10px 15px;
            color: #ff4757;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255,71,87,0.3);
            z-index: 50;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }
        .intel-btn:hover {
            background: #ff4757;
            color: #1a1a2e;
            box-shadow: 0 0 30px rgba(255,71,87,0.6);
        }
        .firework-btn {
            position: fixed;
            left: 15px;
            bottom: 15%;
            background: linear-gradient(145deg, #ff6b35 0%, #ff4757 100%);
            border: 2px solid #ffdd57;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255,107,53,0.5), 0 0 40px rgba(255,221,87,0.3);
            z-index: 50;
            transition: all 0.3s;
            animation: fireworkBtnPulse 2s infinite;
        }
        .firework-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(255,107,53,0.8), 0 0 60px rgba(255,221,87,0.5);
        }
        .firework-btn:active {
            transform: scale(0.95);
        }
        @keyframes fireworkBtnPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255,107,53,0.5), 0 0 40px rgba(255,221,87,0.3); }
            50% { box-shadow: 0 0 30px rgba(255,107,53,0.7), 0 0 50px rgba(255,221,87,0.5); }
        }
        .firework-counter {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #00ff88;
            color: #1a1a2e;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            font-family: monospace;
        }
        .sparkle {
            position: fixed;
            pointer-events: none;
            z-index: 201;
            font-size: 1.5rem;
            animation: sparkleFloat 1s ease-out forwards;
        }
        @keyframes sparkleFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(0); opacity: 0; }
        }
        .intel-btn.flash {
            animation: intelFlash 0.5s ease;
        }
        @keyframes intelFlash {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.1); box-shadow: 0 0 40px rgba(255,71,87,0.8); }
        }
        .intel-popup {
            position: fixed;
            left: 15px;
            top: calc(65% + 60px);
            width: 160px;
            background: linear-gradient(#fffef0 0%, #f0e6d3 100%);
            border: 2px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            color: #333;
            z-index: 49;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: none;
            max-height: 120px;
            overflow: hidden;
        }
        .intel-popup.show { display: block; animation: popIn 0.3s ease; }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        .intel-popup::before {
            content: 'üîí CLASSIFIED';
            display: block;
            color: #ff4757;
            font-weight: bold;
            font-size: 0.7rem;
            margin-bottom: 5px;
            border-bottom: 1px dashed #999;
            padding-bottom: 3px;
        }
        .intel-stamp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 1.5rem;
            color: rgba(255,0,0,0.3);
            font-weight: bold;
            pointer-events: none;
        }
        .todo-recur {
            font-size: 0.5rem;
            color: #9147ff;
            margin-left: 3px;
        }
    </style>
</head>
<body>
<div id="bg-container"></div>
<h1>‚öΩ AI Penalty Shootout</h1>
<div class="ai-status">üéÆ YOU vs AI KEEPER <span class="pulse">‚óè</span> KEEPER ROAMS FREE!</div>
<div class="score-display">
<span class="goals">Goals: <span id="goals">0</span></span>
<span class="saves">Saves: <span id="saves">0</span></span>
<span>Shots: <span id="shots">0</span></span>
<span style="color:#ff00ff;text-shadow:0 0 10px #ff00ff">‚ù§Ô∏è <span id="health">3</span></span>
</div>
<canvas height="280" id="penalty-arena" width="400"></canvas>
<div class="result-flash" id="result"></div>
<div class="stadium-tv">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" src="https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1&amp;mute=1&amp;loop=1&amp;playlist=dQw4w9WgXcQ&amp;controls=0&amp;modestbranding=1&amp;rel=0" title="Stadium Entertainment"></iframe>
<div class="tv-static"></div>
</div>
<button class="intel-btn" id="intelBtn" onclick="revealIntel()">üîì LEAK<br/>MATCH INTEL</button>
<button class="firework-btn" id="fireworkBtn" onclick="manualFireworks()" title="Launch Fireworks!">üéÜ<span class="firework-counter" id="fireworkCount">‚àû</span></button>
<div class="intel-popup" id="intelPopup">
<div id="intelText">Click to reveal secrets...</div>
<div class="intel-stamp">LEAKED</div>
</div>
<div class="clipboard">
<div class="clipboard-title">üìã Match Calendar</div>
<div class="clipboard-paper">
<div class="mini-calendar" id="miniCal"></div>
<div class="todo-input-wrap">
<input class="todo-input" id="todoInput" maxlength="25" placeholder="New task..." type="text"/>
<select class="recur-select" id="recurSelect">
<option value="none">Once</option>
<option value="daily">Daily</option>
<option value="weekly">Weekly</option>
<option value="match">Each Match</option>
</select>
<button class="todo-add" onclick="addTodo()">+</button>
</div>
<ul class="todo-list" id="todoList">
<li class="todo-item"><input class="todo-check" onchange="toggleTodo(this)" type="checkbox"/><span>Score 5 goals</span><button class="todo-delete" onclick="deleteTodo(this)">√ó</button></li>
<li class="todo-item"><input class="todo-check" onchange="toggleTodo(this)" type="checkbox"/><span>Beat the keeper</span><button class="todo-delete" onclick="deleteTodo(this)">√ó</button></li>
</ul>
<div class="db-status"><span class="db-icon">üíæ</span> LocalDB synced ‚Ä¢ <span id="taskCount">0</span> tasks</div>
</div>
</div>
<p class="instruction">
        Type <code>!idea &lt;your idea&gt;</code> in the Twitch chat to add to this page.<br/>
        Example: <code>!idea Add crowd cheering sounds</code>
</p>
<script>
        const canvas = document.getElementById('penalty-arena');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let goals = 0;
        let saves = 0;
        let shots = 0;
        let gamePhase = 'aiming'; // aiming, shooting, result
        let ball = { x: 200, y: 230, vx: 0, vy: 0, radius: 12 };
        let keeper = { x: 200, y: 50, width: 60, height: 20, targetX: 200 };
        let aimAngle = 0;
        let ballDodgeX = 0; // Player dodge offset
        let keeperProjectiles = [];
        let keeperWeaponCooldown = 0;
        let playerProjectiles = [];
        let playerWeaponCooldown = 0;
        let defenderRespawnTimers = [];
        let playerHealth = 3;
        let aimSpeed = 0.03;
        let shootPower = 0;
        let powerDir = 1;
        let resultTimer = 0;
        let particles = [];
        let defenders = [
            { x: 150, y: 150, vx: 0.5, radius: 15, alive: true, spawnX: 150, spawnY: 150 },
            { x: 250, y: 130, vx: -0.4, radius: 15, alive: true, spawnX: 250, spawnY: 130 },
            { x: 200, y: 170, vx: 0.3, radius: 12, alive: true, spawnX: 200, spawnY: 170 }
        ];
        
        // Goal dimensions
        const goal = { x: 100, y: 20, width: 200, height: 60 };
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 30,
                    color: color
                });
            }
        }
        
        function showResult(text, isGoal) {
            const el = document.getElementById('result');
            el.textContent = text;
            el.className = 'result-flash show ' + (isGoal ? 'goal' : 'save');
            setTimeout(() => el.className = 'result-flash', 1500);
        }
        
        function resetBall() {
            ball = { x: 200, y: 230, vx: 0, vy: 0, radius: 12 };
            ballDodgeX = 0;
            keeperProjectiles = [];
            gamePhase = 'aiming';
            shootPower = 0;
            keeper.targetX = 100 + Math.random() * 200;
        }
        
        function aiAim() {
            // Player controls the aim now - no auto-oscillation!
            ball.x = 200 + ballDodgeX;
            
            // Keeper fires weapon!
            keeperWeaponCooldown--;
            if (keeperWeaponCooldown <= 0 && Math.random() < 0.04) {
                keeperProjectiles.push({
                    x: keeper.x,
                    y: keeper.y + keeper.height/2,
                    vy: 6,
                    width: 8,
                    height: 20
                });
                keeperWeaponCooldown = 30; // Cooldown frames
            }
            
            // Update projectiles
            keeperProjectiles = keeperProjectiles.filter(p => {
                p.y += p.vy;
                
                // Check hit on ball/player
                if (p.y > ball.y - ball.radius && p.y < ball.y + ball.radius &&
                    p.x > ball.x - ball.radius - p.width/2 && p.x < ball.x + ball.radius + p.width/2) {
                    playerHealth--;
                    document.getElementById('health').textContent = playerHealth;
                    createParticles(ball.x, ball.y, '#ff00ff');
                    if (playerHealth <= 0) {
                        showResult('üíÄ DEFEATED!', false);
                        playerHealth = 3;
                        document.getElementById('health').textContent = playerHealth;
                        saves += 3;
                        document.getElementById('saves').textContent = saves;
                    }
                    return false;
                }
                return p.y < 300;
            });
            
            // Player must press SPACE to shoot!
        }
        
        function aiPower() {
            shootPower += powerDir * 3;
            if (shootPower >= 100 || shootPower <= 0) powerDir *= -1;
            
            // Player must release SPACE to shoot with current power!
        }
        
        function shoot() {
            const targetX = 200 + Math.sin(aimAngle) * 90;
            const power = shootPower / 100 * 15 + 5;
            ball.vx = (targetX - ball.x) * 0.08;
            ball.vy = -power;
            gamePhase = 'shooting';
            shots++;
            document.getElementById('shots').textContent = shots;
            
            // Keeper AI reacts
            keeper.targetX = 100 + Math.random() * 200; // Guess!
        }
        
        function update() {
            if (gamePhase === 'aiming') {
                aiAim();
            } else if (gamePhase === 'power') {
                aiPower();
            } else if (gamePhase === 'shooting') {
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vy += 0.2; // Slight curve
            }
            
            // Keeper moves ALL THE TIME - free roaming AI!
            if (gamePhase === 'aiming' || gamePhase === 'power') {
                // Patrol mode: keeper wanders back and forth
                if (Math.random() < 0.02) {
                    keeper.targetX = 100 + Math.random() * 200;
                }
                keeper.x += (keeper.targetX - keeper.x) * 0.04;
            } else if (gamePhase === 'shooting') {
                // Reaction mode: faster movement to intercept
                keeper.x += (keeper.targetX - keeper.x) * 0.15;
                
                // Check if ball reached goal line
                if (ball.y <= goal.y + goal.height) {
                    const inGoalX = ball.x > goal.x && ball.x < goal.x + goal.width;
                    const inGoalY = ball.y > goal.y && ball.y < goal.y + goal.height;
                    const hitKeeper = Math.abs(ball.x - keeper.x) < keeper.width/2 + ball.radius &&
                                     Math.abs(ball.y - keeper.y) < keeper.height/2 + ball.radius;
                    
                    if (inGoalX && !hitKeeper) {
                        goals++;
                        document.getElementById('goals').textContent = goals;
                        createParticles(ball.x, ball.y, '#00ff88');
                        showResult('‚öΩ GOAL!', true);
                    } else {
                        saves++;
                        document.getElementById('saves').textContent = saves;
                        createParticles(ball.x, ball.y, '#ff4757');
                        showResult('üß§ SAVED!', false);
                    }
                    gamePhase = 'result';
                    resultTimer = 60;
                }
                
                // Check defender collision
                defenders.forEach(d => {
                    if (d.alive) {
                        const dx = ball.x - d.x;
                        const dy = ball.y - d.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < ball.radius + d.radius) {
                            saves++;
                            document.getElementById('saves').textContent = saves;
                            createParticles(ball.x, ball.y, '#ff6b35');
                            showResult('üõ°Ô∏è BLOCKED!', false);
                            gamePhase = 'result';
                            resultTimer = 60;
                        }
                    }
                });
                
                // Ball out of bounds
                if (ball.y < 0 || ball.x < 0 || ball.x > 400) {
                    saves++;
                    document.getElementById('saves').textContent = saves;
                    showResult('‚ùå MISS!', false);
                    gamePhase = 'result';
                    resultTimer = 60;
                }
            }
            
            if (gamePhase === 'result') {
                resultTimer--;
                if (resultTimer <= 0) resetBall();
            }
            
            // Update defenders (slow patrol)
            defenders.forEach(d => {
                if (d.alive) {
                    d.x += d.vx;
                    if (d.x < 80 || d.x > 320) d.vx *= -1;
                }
            });
            
            // Player weapon cooldown
            if (playerWeaponCooldown > 0) playerWeaponCooldown--;
            
            // Update player projectiles
            playerProjectiles = playerProjectiles.filter(p => {
                p.y += p.vy;
                
                // Check hit on defenders
                for (let d of defenders) {
                    if (d.alive) {
                        const dx = p.x - d.x;
                        const dy = p.y - d.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < d.radius + 5) {
                            d.alive = false;
                            createParticles(d.x, d.y, '#00ffff');
                            // Set respawn timer (5 seconds = 150 frames at 30fps)
                            defenderRespawnTimers.push({ defender: d, timer: 150 });
                            return false;
                        }
                    }
                }
                return p.y > 0;
            });
            
            // Process defender respawn timers
            defenderRespawnTimers = defenderRespawnTimers.filter(r => {
                r.timer--;
                if (r.timer <= 0) {
                    r.defender.alive = true;
                    r.defender.x = r.defender.spawnX;
                    r.defender.y = r.defender.spawnY;
                    createParticles(r.defender.x, r.defender.y, '#ff6b35');
                    return false;
                }
                return true;
            });
            
            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                return p.life > 0;
            });
        }
        
        function draw() {
            // Pitch background
            ctx.fillStyle = '#1a472a';
            ctx.fillRect(0, 0, 400, 280);
            
            // Pitch lines
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 10, 300, 260);
            
            // Goal area
            ctx.strokeRect(120, 10, 160, 80);
            
            // Penalty spot
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(200, 230, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Goal posts with glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(goal.x, goal.y + goal.height);
            ctx.lineTo(goal.x, goal.y);
            ctx.lineTo(goal.x + goal.width, goal.y);
            ctx.lineTo(goal.x + goal.width, goal.y + goal.height);
            ctx.stroke();
            
            // Goal net
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(goal.x + i * 22, goal.y);
                ctx.lineTo(goal.x + i * 22, goal.y + goal.height);
                ctx.stroke();
            }
            
            // Keeper
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff4757';
            ctx.fillStyle = '#ff4757';
            ctx.fillRect(keeper.x - keeper.width/2, keeper.y - keeper.height/2, keeper.width, keeper.height);
            
            // Keeper gloves
            ctx.fillStyle = '#ffdd57';
            ctx.fillRect(keeper.x - keeper.width/2 - 8, keeper.y - 5, 10, 15);
            ctx.fillRect(keeper.x + keeper.width/2 - 2, keeper.y - 5, 10, 15);
            
            // Draw defenders (slow-moving enemies)
            defenders.forEach(d => {
                if (d.alive) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff6b35';
                    ctx.fillStyle = '#ff6b35';
                    ctx.beginPath();
                    ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Defender body
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath();
                    ctx.arc(d.x, d.y - 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                    // Jersey number
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚õî', d.x, d.y + 4);
                }
            });
            
            // Draw respawn indicators
            defenderRespawnTimers.forEach(r => {
                const d = r.defender;
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 100) * 0.2;
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(d.spawnX, d.spawnY, d.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                // Timer text
                ctx.fillStyle = '#ffdd57';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(r.timer / 30) + 's', d.spawnX, d.spawnY + 4);
                ctx.globalAlpha = 1;
            });
            
            // Draw player projectiles
            playerProjectiles.forEach(p => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();
                // Energy trail
                ctx.fillStyle = 'rgba(0,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(p.x, p.y + 10, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
            
            // Aim indicator
            if (gamePhase === 'aiming' || gamePhase === 'power') {
                const targetX = 200 + Math.sin(aimAngle) * 90;
                ctx.strokeStyle = 'rgba(255, 221, 87, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(targetX, goal.y + goal.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Target reticle
                ctx.strokeStyle = '#ffdd57';
                ctx.beginPath();
                ctx.arc(targetX, goal.y + goal.height, 10, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Power bar
            if (gamePhase === 'power') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(350, 50, 20, 150);
                const powerColor = shootPower < 50 ? '#00ff88' : shootPower < 80 ? '#ffdd57' : '#ff4757';
                ctx.fillStyle = powerColor;
                ctx.fillRect(350, 200 - shootPower * 1.5, 20, shootPower * 1.5);
                ctx.strokeStyle = 'white';
                ctx.strokeRect(350, 50, 20, 150);
            }
            
            // Ball with glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Ball pattern
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(ball.x - 3, ball.y - 3, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ball.x + 5, ball.y + 2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw keeper weapon (cannon)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#8B008B';
            ctx.fillRect(keeper.x - 6, keeper.y + keeper.height/2, 12, 15);
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(keeper.x - 4, keeper.y + keeper.height/2 + 10, 8, 8);
            
            // Draw projectiles
            keeperProjectiles.forEach(p => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                // Energy trail
                ctx.fillStyle = 'rgba(255,0,255,0.3)';
                ctx.fillRect(p.x - p.width/2, p.y - 15, p.width, 15);
            });
            ctx.shadowBlur = 0;
            
            // Player controls hint
            if (gamePhase === 'aiming') {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚¨ÖÔ∏è A/D to AIM ‚Ä¢ SPACE to CHARGE ‚Ä¢ F to FIRE ‚û°Ô∏è', 200, 270);
                
                // Draw player weapon indicator
                const weaponReady = playerWeaponCooldown <= 0;
                ctx.fillStyle = weaponReady ? '#00ffff' : '#666';
                ctx.font = 'bold 10px sans-serif';
                ctx.fillText(weaponReady ? 'üî´ READY' : 'üî´ ' + Math.ceil(playerWeaponCooldown/30) + 's', 50, 260);
            }
            if (gamePhase === 'power') {
                ctx.fillStyle = '#ffdd57';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö° RELEASE SPACE TO SHOOT! ‚ö°', 200, 270);
            }
            
            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        
        function gameLoop() {
            update();
            draw();
        }
        
        setInterval(gameLoop, 1000/30);
        
        // PLAYER CONTROLS - You control the game now!
        let aimDirection = 0; // -1 left, 0 none, 1 right
        let spaceHeld = false;
        
        document.addEventListener('keydown', (e) => {
            if (gamePhase === 'aiming') {
                // Aim left/right
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    aimDirection = -1;
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    aimDirection = 1;
                }
                // Start power charge
                if (e.key === ' ' && !spaceHeld) {
                    spaceHeld = true;
                    gamePhase = 'power';
                    shootPower = 0;
                    powerDir = 1;
                }
                // Fire player weapon
                if ((e.key === 'f' || e.key === 'F') && playerWeaponCooldown <= 0) {
                    playerProjectiles.push({
                        x: ball.x,
                        y: ball.y - ball.radius,
                        vy: -12
                    });
                    playerWeaponCooldown = 20; // Cooldown frames
                    createParticles(ball.x, ball.y - ball.radius, '#00ffff');
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A' ||
                e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                aimDirection = 0;
            }
            // Release space to shoot!
            if (e.key === ' ' && spaceHeld) {
                spaceHeld = false;
                if (gamePhase === 'power') {
                    shoot();
                }
            }
        });
        
        // Update aim based on player input
        setInterval(() => {
            if (gamePhase === 'aiming' && aimDirection !== 0) {
                aimAngle += aimDirection * 0.05;
                aimAngle = Math.max(-1.2, Math.min(1.2, aimAngle));
            }
        }, 33);
        
        // No more auto-dodge - YOU are in control now!
        
        // Background footballs
        function createBgFootball() {
            const container = document.getElementById('bg-container');
            const ball = document.createElement('div');
            ball.className = 'football-bg';
            ball.textContent = '‚öΩ';
            ball.style.left = Math.random() * 100 + 'vw';
            ball.style.top = Math.random() * 100 + 'vh';
            ball.style.animationDelay = Math.random() * 5 + 's';
            container.appendChild(ball);
        }
        
        for(let i = 0; i < 8; i++) createBgFootball();
        
        // To-Do List Functions
        function addTodo() {
            const input = document.getElementById('todoInput');
            const text = input.value.trim();
            if (!text) return;
            
            const list = document.getElementById('todoList');
            const li = document.createElement('li');
            li.className = 'todo-item';
            li.innerHTML = `<input type="checkbox" class="todo-check" onchange="toggleTodo(this)"><span>${text}</span><button class="todo-delete" onclick="deleteTodo(this)">√ó</button>`;
            list.appendChild(li);
            input.value = '';
        }
        
        function toggleTodo(checkbox) {
            checkbox.parentElement.classList.toggle('done', checkbox.checked);
        }
        
        function deleteTodo(btn) {
            btn.parentElement.remove();
        }
        
        document.getElementById('todoInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addTodo();
        });
        
        // LocalDB (localStorage) Task Management
        const taskDB = {
            tasks: JSON.parse(localStorage.getItem('matchTasks') || '[]'),
            save() {
                localStorage.setItem('matchTasks', JSON.stringify(this.tasks));
                document.getElementById('taskCount').textContent = this.tasks.length;
            },
            add(text, recur) {
                this.tasks.push({ id: Date.now(), text, recur, done: false, created: new Date().toISOString() });
                this.save();
            },
            toggle(id) {
                const task = this.tasks.find(t => t.id === id);
                if (task) { task.done = !task.done; this.save(); }
            },
            remove(id) {
                this.tasks = this.tasks.filter(t => t.id !== id);
                this.save();
            },
            processRecurring() {
                const now = new Date();
                this.tasks.forEach(t => {
                    if (t.done && t.recur !== 'none') {
                        const created = new Date(t.created);
                        const daysPassed = (now - created) / (1000*60*60*24);
                        if ((t.recur === 'daily' && daysPassed >= 1) ||
                            (t.recur === 'weekly' && daysPassed >= 7)) {
                            t.done = false;
                            t.created = now.toISOString();
                        }
                    }
                });
                this.save();
            }
        };
        
        // Mini Calendar
        function renderCalendar() {
            const cal = document.getElementById('miniCal');
            const days = ['S','M','T','W','T','F','S'];
            const today = new Date();
            const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
            const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            
            let html = days.map(d => `<div class="cal-header">${d}</div>`).join('');
            
            for (let i = 0; i < firstDay.getDay(); i++) html += '<div class="cal-day"></div>';
            
            for (let d = 1; d <= lastDay.getDate(); d++) {
                const isToday = d === today.getDate();
                const hasTask = taskDB.tasks.some(t => !t.done);
                const classes = ['cal-day'];
                if (isToday) classes.push('today');
                if (hasTask && d >= today.getDate()) classes.push('has-task');
                html += `<div class="${classes.join(' ')}">${d}</div>`;
            }
            cal.innerHTML = html;
        }
        
        // Render stored tasks
        function renderStoredTasks() {
            const list = document.getElementById('todoList');
            list.innerHTML = '';
            taskDB.processRecurring();
            taskDB.tasks.forEach(t => {
                const li = document.createElement('li');
                li.className = 'todo-item' + (t.done ? ' done' : '');
                const recurIcon = t.recur !== 'none' ? `<span class="todo-recur">üîÑ${t.recur[0].toUpperCase()}</span>` : '';
                li.innerHTML = `<input type="checkbox" class="todo-check" ${t.done ? 'checked' : ''} onchange="toggleStoredTodo(${t.id})"><span>${t.text}</span>${recurIcon}<button class="todo-delete" onclick="deleteStoredTodo(${t.id})">√ó</button>`;
                list.appendChild(li);
            });
            document.getElementById('taskCount').textContent = taskDB.tasks.length;
        }
        
        // Override todo functions for DB
        window.addTodo = function() {
            const input = document.getElementById('todoInput');
            const recur = document.getElementById('recurSelect').value;
            const text = input.value.trim();
            if (!text) return;
            taskDB.add(text, recur);
            input.value = '';
            renderStoredTasks();
            renderCalendar();
        };
        
        window.toggleStoredTodo = function(id) {
            taskDB.toggle(id);
            renderStoredTasks();
        };
        
        window.deleteStoredTodo = function(id) {
            taskDB.remove(id);
            renderStoredTasks();
            renderCalendar();
        };
        
        // Init
        renderCalendar();
        renderStoredTasks();
        
        // Leaked Intel System
        const leakedIntel = [
            "The keeper's gloves are filled with magnets. Investigation pending.",
            "VAR operator spotted betting on corners. Match under review.",
            "Ball boy network runs underground trading ring for match balls.",
            "Referee's whistle contains hidden GPS tracker from sponsors.",
            "Goalkeeper's water bottle: 40% energy drink, 60% classified.",
            "Corner flags are actually 5G antennas. Don't ask questions.",
            "Half-time oranges laced with performance algorithms.",
            "The offside line is controlled by an AI named 'Gary'.",
            "Pitch grass grown from seeds blessed by ancient football monks.",
            "Goal nets manufactured by former spy agency operatives.",
            "The fourth official knows everything. EVERYTHING.",
            "Penalty spot contains pressure sensor linked to bookmakers.",
            "Substitution board runs on Windows 95. It's sentient now.",
            "Manager's tactical notepad is actually a portal to dimension X.",
            "The crowd's cheers are 30% AI-generated for atmosphere."
        ];
        
        let lastIntelIndex = -1;
        
        function revealIntel() {
            const btn = document.getElementById('intelBtn');
            const popup = document.getElementById('intelPopup');
            const text = document.getElementById('intelText');
            
            btn.classList.add('flash');
            setTimeout(() => btn.classList.remove('flash'), 500);
            
            let newIndex;
            do { newIndex = Math.floor(Math.random() * leakedIntel.length); } 
            while (newIndex === lastIntelIndex && leakedIntel.length > 1);
            lastIntelIndex = newIndex;
            
            text.textContent = leakedIntel[newIndex];
            popup.classList.add('show');
            
            setTimeout(() => popup.classList.remove('show'), 4000);
        }
        
        // Sync on goal (recurring 'match' tasks)
        const origGoalHandler = () => {
            taskDB.tasks.forEach(t => {
                if (t.recur === 'match' && t.done) {
                    t.done = false;
                }
            });
            taskDB.save();
            renderStoredTasks();
        };
        
        // Fireworks system
        const fireworkColors = ['#ff0055', '#00ff88', '#ffdd57', '#00d4ff', '#ff6b35', '#bf94ff', '#ff4757'];
        
        function launchFirework(x, y) {
            // Trail rising up
            const trail = document.createElement('div');
            trail.className = 'firework-trail';
            const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
            trail.style.setProperty('--color', color);
            trail.style.left = x + 'px';
            trail.style.top = y + 'px';
            document.body.appendChild(trail);
            
            setTimeout(() => {
                trail.remove();
                // Burst at top
                createFireworkBurst(x, y - 150, color);
            }, 600);
        }
        
        function createFireworkBurst(x, y, color) {
            const container = document.createElement('div');
            container.className = 'firework';
            container.style.left = x + 'px';
            container.style.top = y + 'px';
            
            // Glow effect
            const glow = document.createElement('div');
            glow.className = 'firework-glow';
            glow.style.setProperty('--color', color);
            container.appendChild(glow);
            
            // Particles
            const particleCount = 20 + Math.floor(Math.random() * 15);
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                particle.style.background = color;
                particle.style.boxShadow = `0 0 6px ${color}, 0 0 12px ${color}`;
                
                const angle = (i / particleCount) * Math.PI * 2;
                const velocity = 50 + Math.random() * 80;
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity + 30; // gravity
                
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                container.appendChild(particle);
            }
            
            document.body.appendChild(container);
            setTimeout(() => container.remove(), 1500);
        }
        
        function celebrateGoal() {
            // Launch multiple fireworks
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const x = 100 + Math.random() * (window.innerWidth - 200);
                    const y = window.innerHeight * 0.7 + Math.random() * 100;
                    launchFirework(x, y);
                }, i * 150);
            }
            // Add sparkles
            for (let i = 0; i < 15; i++) {
                setTimeout(() => createSparkle(), i * 100);
            }
        }
        
        function createSparkle() {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.textContent = ['‚ú®', '‚≠ê', 'üí´', 'üåü'][Math.floor(Math.random() * 4)];
            sparkle.style.left = Math.random() * window.innerWidth + 'px';
            sparkle.style.top = Math.random() * window.innerHeight * 0.7 + 'px';
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 1000);
        }
        
        function manualFireworks() {
            const btn = document.getElementById('fireworkBtn');
            btn.style.transform = 'scale(0.9)';
            setTimeout(() => btn.style.transform = '', 100);
            
            // Launch a burst of fireworks from random positions
            const burstCount = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < burstCount; i++) {
                setTimeout(() => {
                    const x = 100 + Math.random() * (window.innerWidth - 200);
                    const y = window.innerHeight * 0.6 + Math.random() * 150;
                    launchFirework(x, y);
                }, i * 100);
            }
            
            // Add some sparkles too
            for (let i = 0; i < 8; i++) {
                setTimeout(() => createSparkle(), i * 80);
            }
        }
        
        // Expose to window for onclick handlers
        window.manualFireworks = manualFireworks;
        window.revealIntel = revealIntel;
        
        // Track goals and saves for auto-intel reveal
        let prevGoals = 0;
        let prevSaves = 0;
        
        setInterval(() => {
            const currentGoals = parseInt(document.getElementById('goals').textContent || 0);
            const currentSaves = parseInt(document.getElementById('saves').textContent || 0);
            
            if (currentGoals > prevGoals) {
                origGoalHandler();
                revealIntel(); // Auto-reveal on goal!
                celebrateGoal(); // Launch fireworks!
            }
            if (currentSaves > prevSaves) {
                revealIntel(); // Auto-reveal on save!
            }
            
            prevGoals = currentGoals;
            prevSaves = currentSaves;
        }, 500);
    </script>
</body>
</html>