<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bitcoin Rollercoaster 3D</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            overflow: hidden;
            background: #0a0a0f;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        .hud h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btc-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #f7931a, #ffb84d);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
        }
        .price {
            font-size: 2rem;
            font-weight: bold;
            transition: color 0.3s;
        }
        .price.up { color: #00ff88; text-shadow: 0 0 20px #00ff88; }
        .price.down { color: #ff4444; text-shadow: 0 0 20px #ff4444; }
        .change {
            font-size: 1rem;
            margin-top: 5px;
        }
        .instruction {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 0.8rem;
            text-align: center;
            z-index: 100;
        }
        .instruction code {
            background: rgba(145, 71, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: #bf94ff;
        }
        .audio-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            color: #bf94ff;
            font-size: 0.8rem;
            cursor: pointer;
            background: rgba(145, 71, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(145, 71, 255, 0.4);
            transition: all 0.3s;
        }
        .audio-indicator:hover {
            background: rgba(145, 71, 255, 0.4);
        }
        .audio-indicator.playing {
            color: #00ff88;
            border-color: rgba(0, 255, 136, 0.4);
            text-shadow: 0 0 10px #00ff88;
        }
        .scream {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div id="canvas-container"></div>
<div class="hud">
<h1><span class="btc-icon">‚Çø</span> BITCOIN COASTER</h1>
<div class="price up" id="price">$67,432.18</div>
<div class="change" id="change">‚ñ≤ +2.34%</div>
<div class="track-indicator" id="track-indicator" style="margin-top:8px;font-size:0.7rem;color:#888;">TRACK: MAIN</div>
<div class="torus-indicator" id="torus-indicator" style="margin-top:4px;font-size:0.6rem;color:#bf94ff;">üç© TOROIDAL TOPOLOGY ACTIVE</div>
</div>
<div class="scream" id="scream">üò±</div>
<div class="audio-indicator" id="audio-toggle">üîä Music Auto-Playing</div>
<p class="instruction">
        Type <code>!idea your idea</code> in chat to modify this world
    </p>
<script>
        // Dynamic UPBEAT Audio System - Rhythmic and melodic!
        let audioContext = null;
        let audioStarted = false;
        let masterGain = null;
        let melodySynths = [];
        let bassOsc = null;
        let drumGain = null;
        let currentBeat = 0;
        let bpm = 128;
        let beatInterval = null;
        let currentChord = 0;
        let arpIndex = 0;
        
        // Musical scales and chords for happy vibes
        const chordProgressions = [
            [261.63, 329.63, 392.00, 523.25], // C major
            [293.66, 369.99, 440.00, 587.33], // D major  
            [329.63, 415.30, 493.88, 659.25], // E major
            [349.23, 440.00, 523.25, 698.46], // F major
            [392.00, 493.88, 587.33, 783.99], // G major
            [440.00, 554.37, 659.25, 880.00]  // A major
        ];
        
        function initAudio() {
            if (audioStarted) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.35;
            masterGain.connect(audioContext.destination);
            
            // Compressor for punch
            const compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.value = -20;
            compressor.knee.value = 10;
            compressor.ratio.value = 4;
            compressor.connect(masterGain);
            
            // Create melodic synth voices
            for (let i = 0; i < 4; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = i === 0 ? 'square' : i === 1 ? 'sawtooth' : 'triangle';
                osc.frequency.value = 440;
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 5;
                gain.gain.value = 0;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(compressor);
                osc.start();
                
                melodySynths.push({ osc, gain, filter });
            }
            
            // Punchy bass
            bassOsc = audioContext.createOscillator();
            const bassGain = audioContext.createGain();
            const bassFilter = audioContext.createBiquadFilter();
            bassOsc.type = 'sawtooth';
            bassOsc.frequency.value = 65;
            bassFilter.type = 'lowpass';
            bassFilter.frequency.value = 400;
            bassGain.gain.value = 0.25;
            bassOsc.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(compressor);
            bassOsc.start();
            
            // Drum channel
            drumGain = audioContext.createGain();
            drumGain.gain.value = 0.4;
            drumGain.connect(masterGain);
            
            // Start the beat!
            const beatTime = 60 / bpm;
            beatInterval = setInterval(() => {
                playBeat();
                currentBeat = (currentBeat + 1) % 16;
                if (currentBeat === 0) {
                    currentChord = (currentChord + 1) % chordProgressions.length;
                }
            }, beatTime * 250); // 16th notes
            
            audioStarted = true;
            document.getElementById('audio-toggle').textContent = 'üîä Drop-Synced Music';
            document.getElementById('audio-toggle').classList.add('playing');
        }
        
        function playBeat() {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            const chord = chordProgressions[currentChord];
            
            // Kick on 1, 5, 9, 13
            if (currentBeat % 4 === 0) {
                playKick(now);
            }
            // Snare on 4, 12
            if (currentBeat === 4 || currentBeat === 12) {
                playSnare(now);
            }
            // Hi-hat on every beat, open on off-beats
            playHiHat(now, currentBeat % 2 === 1);
            
            // Arpeggio melody
            if (currentBeat % 2 === 0) {
                const noteIndex = arpIndex % chord.length;
                const freq = chord[noteIndex] * (Math.random() > 0.8 ? 2 : 1);
                playArpNote(freq, now);
                arpIndex++;
            }
        }
        
        function playKick(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
            osc.connect(gain);
            gain.connect(drumGain);
            osc.start(time);
            osc.stop(time + 0.3);
        }
        
        function playSnare(time) {
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = buffer;
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(drumGain);
            noise.start(time);
        }
        
        function playHiHat(time, open) {
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = buffer;
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;
            gain.gain.setValueAtTime(open ? 0.15 : 0.1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + (open ? 0.1 : 0.05));
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(drumGain);
            noise.start(time);
        }
        
        function playArpNote(freq, time) {
            const synth = melodySynths[arpIndex % melodySynths.length];
            synth.osc.frequency.setValueAtTime(freq, time);
            synth.gain.gain.setValueAtTime(0.15, time);
            synth.gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            synth.filter.frequency.setValueAtTime(3000, time);
            synth.filter.frequency.exponentialRampToValueAtTime(800, time + 0.2);
        }
        
        // Drop detection state
        let lastDropTime = 0;
        let dropIntensity = 0;
        let isInDrop = false;
        let dropStartHeight = 0;
        let consecutiveDropFrames = 0;
        
        function triggerDropHit(intensity) {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            
            // MASSIVE synchronized kick on drop
            const dropKick = audioContext.createOscillator();
            const dropKickGain = audioContext.createGain();
            dropKick.type = 'sine';
            dropKick.frequency.setValueAtTime(80 * (1 + intensity), now);
            dropKick.frequency.exponentialRampToValueAtTime(20, now + 0.4);
            dropKickGain.gain.setValueAtTime(0.9 * intensity, now);
            dropKickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            dropKick.connect(dropKickGain);
            dropKickGain.connect(masterGain);
            dropKick.start(now);
            dropKick.stop(now + 0.5);
            
            // Sub bass wobble
            const subBass = audioContext.createOscillator();
            const subGain = audioContext.createGain();
            subBass.type = 'sine';
            subBass.frequency.setValueAtTime(30, now);
            subGain.gain.setValueAtTime(0.6 * intensity, now);
            subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
            subBass.connect(subGain);
            subGain.connect(masterGain);
            subBass.start(now);
            subBass.stop(now + 0.8);
            
            // Crash cymbal
            const crash = audioContext.createBufferSource();
            const crashBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.5, audioContext.sampleRate);
            const crashData = crashBuffer.getChannelData(0);
            for (let i = 0; i < crashData.length; i++) {
                crashData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioContext.sampleRate * 0.5));
            }
            crash.buffer = crashBuffer;
            const crashFilter = audioContext.createBiquadFilter();
            crashFilter.type = 'highpass';
            crashFilter.frequency.value = 3000;
            const crashGain = audioContext.createGain();
            crashGain.gain.setValueAtTime(0.3 * intensity, now);
            crashGain.gain.exponentialRampToValueAtTime(0.01, now + 1);
            crash.connect(crashFilter);
            crashFilter.connect(crashGain);
            crashGain.connect(masterGain);
            crash.start(now);
            
            // Rising synth impact
            const impact = audioContext.createOscillator();
            const impactGain = audioContext.createGain();
            impact.type = 'sawtooth';
            impact.frequency.setValueAtTime(100, now);
            impact.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            impact.frequency.exponentialRampToValueAtTime(50, now + 0.3);
            impactGain.gain.setValueAtTime(0.2 * intensity, now);
            impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            impact.connect(impactGain);
            impactGain.connect(masterGain);
            impact.start(now);
            impact.stop(now + 0.4);
        }
        
        function triggerClimbTension(height) {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            
            // Rising tension synth
            melodySynths.forEach((synth, i) => {
                synth.filter.frequency.linearRampToValueAtTime(
                    1000 + height * 6000,
                    now + 0.05
                );
            });
        }
        
        function updateAudioFromHeight(height, velocity) {
            if (!audioStarted || !audioContext) return;
            
            const now = Date.now();
            const normalizedHeight = (height + 15) / 30;
            const clampedHeight = Math.max(0, Math.min(1, normalizedHeight));
            
            // DROP DETECTION - synchronized hits!
            if (velocity < -0.08) {
                consecutiveDropFrames++;
                if (!isInDrop && consecutiveDropFrames > 3) {
                    isInDrop = true;
                    dropStartHeight = height;
                }
            } else {
                if (isInDrop && consecutiveDropFrames > 5) {
                    // End of drop - calculate intensity based on drop distance
                    const dropDistance = dropStartHeight - height;
                    const intensity = Math.min(1, dropDistance / 15);
                    if (now - lastDropTime > 500 && intensity > 0.2) {
                        triggerDropHit(intensity);
                        lastDropTime = now;
                    }
                }
                isInDrop = false;
                consecutiveDropFrames = 0;
            }
            
            // Continuous velocity-based effects
            if (velocity < -0.15) {
                // Intense drop - pump the volume!
                masterGain.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + 0.02);
                dropIntensity = Math.min(1, dropIntensity + 0.1);
            } else if (velocity > 0.05) {
                // Climbing - build tension
                triggerClimbTension(clampedHeight);
                dropIntensity = Math.max(0, dropIntensity - 0.02);
                masterGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
            } else {
                dropIntensity = Math.max(0, dropIntensity - 0.01);
                masterGain.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.2);
            }
            
            // TEMPO SYNCS WITH HEIGHT - anticipation builds at peaks!
            const targetBpm = 90 + clampedHeight * 80 + dropIntensity * 30;
            if (Math.abs(targetBpm - bpm) > 5) {
                bpm = bpm + (targetBpm - bpm) * 0.1;
            }
            
            // Filter sweep follows height for tension
            melodySynths.forEach((synth, i) => {
                const baseFreq = 600 + clampedHeight * 3000;
                const dropBoost = dropIntensity * 2000;
                synth.filter.frequency.linearRampToValueAtTime(
                    baseFreq + dropBoost,
                    audioContext.currentTime + 0.05
                );
            });
            
            // Bass goes DEEP on drops
            if (bassOsc) {
                const bassFreq = 35 + clampedHeight * 30 - dropIntensity * 15;
                bassOsc.frequency.linearRampToValueAtTime(Math.max(25, bassFreq), audioContext.currentTime + 0.05);
            }
        }
        
        // Auto-start music on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                initAudio();
            }, 500);
        });
        
        // Also start on first user interaction as fallback
        document.addEventListener('click', () => {
            if (!audioStarted) initAudio();
        }, { once: true });
        
        document.getElementById('audio-toggle').addEventListener('click', () => {
            if (!audioStarted) {
                initAudio();
            } else if (audioContext) {
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                    document.getElementById('audio-toggle').textContent = 'üîá Music Paused';
                    document.getElementById('audio-toggle').classList.remove('playing');
                } else {
                    audioContext.resume();
                    document.getElementById('audio-toggle').textContent = 'üîä Drop-Synced Music';
                    document.getElementById('audio-toggle').classList.add('playing');
                }
            }
        });
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0f, 10, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0f);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Generate Bitcoin price data (simulated volatility)
        const priceData = [];
        let price = 50000;
        for (let i = 0; i < 200; i++) {
            const volatility = Math.sin(i * 0.1) * 0.03 + (Math.random() - 0.5) * 0.08;
            price *= (1 + volatility);
            price = Math.max(20000, Math.min(100000, price));
            priceData.push(price);
        }

        // Create track geometry
        const trackPoints = [];
        const minPrice = Math.min(...priceData);
        const maxPrice = Math.max(...priceData);
        
        priceData.forEach((p, i) => {
            const x = (i - 100) * 0.5;
            const y = ((p - minPrice) / (maxPrice - minPrice)) * 20 - 10;
            const z = 0;
            trackPoints.push(new THREE.Vector3(x, y, z));
        });

        const curve = new THREE.CatmullRomCurve3(trackPoints);
        
        // Track rails
        const tubeGeometry = new THREE.TubeGeometry(curve, 500, 0.15, 8, false);
        const trackMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xf7931a,
            emissive: 0xf7931a,
            emissiveIntensity: 0.3,
            shininess: 100
        });
        const track = new THREE.Mesh(tubeGeometry, trackMaterial);
        scene.add(track);

        // Second rail
        const rail2Points = trackPoints.map(p => new THREE.Vector3(p.x, p.y, p.z + 1));
        const curve2 = new THREE.CatmullRomCurve3(rail2Points);
        const tube2 = new THREE.TubeGeometry(curve2, 500, 0.15, 8, false);
        const track2 = new THREE.Mesh(tube2, trackMaterial);
        scene.add(track2);

        // Cross beams
        for (let i = 0; i < 200; i += 5) {
            const beamGeo = new THREE.BoxGeometry(0.1, 0.1, 1.3);
            const beam = new THREE.Mesh(beamGeo, new THREE.MeshPhongMaterial({ color: 0x444444 }));
            const point = curve.getPoint(i / 200);
            beam.position.set(point.x, point.y - 0.2, point.z + 0.5);
            scene.add(beam);
        }

        // VERTICAL LOOP STRUCTURES!
        const loopPositions = [-30, 15, 50]; // X positions for loops
        const loopStructures = [];
        loopPositions.forEach((loopX, loopIdx) => {
            const loopGroup = new THREE.Group();
            const loopRadius = 6;
            const loopSegments = 32;
            const loopPoints = [];
            
            // Create loop track points
            for (let i = 0; i <= loopSegments; i++) {
                const angle = (i / loopSegments) * Math.PI * 2;
                const lx = loopX;
                const ly = Math.sin(angle) * loopRadius + loopRadius + 2;
                const lz = Math.cos(angle) * loopRadius;
                loopPoints.push(new THREE.Vector3(lx, ly, lz));
            }
            
            const loopCurve = new THREE.CatmullRomCurve3(loopPoints);
            const loopTube = new THREE.TubeGeometry(loopCurve, 64, 0.2, 8, false);
            const loopColors = [0xff4444, 0x44ff44, 0x4444ff];
            const loopMesh = new THREE.Mesh(loopTube, new THREE.MeshPhongMaterial({
                color: loopColors[loopIdx],
                emissive: loopColors[loopIdx],
                emissiveIntensity: 0.4,
                shininess: 100
            }));
            loopGroup.add(loopMesh);
            
            // Support structure
            const supportGeo = new THREE.CylinderGeometry(0.3, 0.4, loopRadius * 2 + 4, 8);
            const supportMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
            const support1 = new THREE.Mesh(supportGeo, supportMat);
            support1.position.set(loopX - 0.5, loopRadius + 2, -loopRadius - 1);
            loopGroup.add(support1);
            const support2 = new THREE.Mesh(supportGeo, supportMat);
            support2.position.set(loopX + 0.5, loopRadius + 2, loopRadius + 1);
            loopGroup.add(support2);
            
            scene.add(loopGroup);
            loopStructures.push({ group: loopGroup, curve: loopCurve, x: loopX });
        });

        // ROADSIDE TREES - Pine trees along the track!
        const trees = [];
        const treeColors = [0x228B22, 0x2E8B57, 0x006400, 0x32CD32, 0x90EE90];
        for (let i = 0; i < 150; i++) {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkHeight = 1 + Math.random() * 2;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 8),
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = trunkHeight / 2;
            treeGroup.add(trunk);
            
            // Pine cone layers (3-5 layers)
            const layers = 3 + Math.floor(Math.random() * 3);
            const treeColor = treeColors[Math.floor(Math.random() * treeColors.length)];
            for (let l = 0; l < layers; l++) {
                const coneRadius = 1.5 - l * 0.25;
                const coneHeight = 2 - l * 0.3;
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(coneRadius, coneHeight, 8),
                    new THREE.MeshPhongMaterial({ color: treeColor, emissive: treeColor, emissiveIntensity: 0.1 })
                );
                cone.position.y = trunkHeight + l * 1.2 + 1;
                treeGroup.add(cone);
            }
            
            // Position tree along the track
            const trackT = Math.random();
            const trackPoint = curve.getPoint(trackT);
            const side = Math.random() > 0.5 ? 1 : -1;
            const distance = 5 + Math.random() * 15;
            
            treeGroup.position.set(
                trackPoint.x + (Math.random() - 0.5) * 10,
                -15, // Ground level
                trackPoint.z + side * distance
            );
            treeGroup.scale.setScalar(0.8 + Math.random() * 0.8);
            treeGroup.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(treeGroup);
            trees.push(treeGroup);
        }

        // Cart (the rider)
        const cartGroup = new THREE.Group();
        const cartBody = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.8, 1),
            new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 100 })
        );
        cartGroup.add(cartBody);
        
        // Rider (simple figure)
        const riderBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.25, 0.6, 8),
            new THREE.MeshPhongMaterial({ color: 0x4488ff })
        );
        riderBody.position.y = 0.7;
        cartGroup.add(riderBody);
        
        const riderHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshPhongMaterial({ color: 0xffcc99 })
        );
        riderHead.position.y = 1.2;
        cartGroup.add(riderHead);
        
        scene.add(cartGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(0, 30, 10);
        scene.add(spotLight);

        // Grid floor
        const gridHelper = new THREE.GridHelper(200, 50, 0x00ff88, 0x003322);
        gridHelper.position.y = -15;
        scene.add(gridHelper);

        // UFOs flying around
        const ufos = [];
        for (let i = 0; i < 5; i++) {
            const ufoGroup = new THREE.Group();
            
            // UFO body (disc)
            const ufoBody = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 2, 0.5, 16),
                new THREE.MeshPhongMaterial({ color: 0x88ff88, emissive: 0x22ff22, emissiveIntensity: 0.5, shininess: 150 })
            );
            ufoGroup.add(ufoBody);
            
            // UFO dome
            const ufoDome = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshPhongMaterial({ color: 0xaaffff, transparent: true, opacity: 0.7, shininess: 200 })
            );
            ufoDome.position.y = 0.25;
            ufoGroup.add(ufoDome);
            
            // Alien inside
            const alienHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0x44ff44 })
            );
            alienHead.position.y = 0.4;
            alienHead.scale.set(1, 1.3, 1);
            ufoGroup.add(alienHead);
            
            // Alien eyes
            const eyeGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000, emissive: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 0.45, 0.25);
            ufoGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 0.45, 0.25);
            ufoGroup.add(rightEye);
            
            // UFO lights ring
            for (let j = 0; j < 8; j++) {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff00ff })
                );
                const angle = (j / 8) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 1.7, 0, Math.sin(angle) * 1.7);
                ufoGroup.add(light);
            }
            
            ufoGroup.position.set(
                (Math.random() - 0.5) * 80,
                Math.random() * 20 + 10,
                (Math.random() - 0.5) * 40
            );
            ufoGroup.userData = {
                orbitRadius: 20 + Math.random() * 30,
                orbitSpeed: 0.2 + Math.random() * 0.3,
                orbitOffset: Math.random() * Math.PI * 2,
                hoverOffset: Math.random() * Math.PI * 2
            };
            scene.add(ufoGroup);
            ufos.push(ufoGroup);
        }

        // Mothership watching from above
        const mothershipGroup = new THREE.Group();
        const motherBody = new THREE.Mesh(
            new THREE.CylinderGeometry(8, 12, 3, 32),
            new THREE.MeshPhongMaterial({ color: 0x666688, emissive: 0x222244, shininess: 100 })
        );
        mothershipGroup.add(motherBody);
        const motherDome = new THREE.Mesh(
            new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshPhongMaterial({ color: 0x88ffff, transparent: true, opacity: 0.5 })
        );
        motherDome.position.y = 1.5;
        mothershipGroup.add(motherDome);
        // Mothership beam
        const beamGeo = new THREE.CylinderGeometry(0.5, 4, 30, 16, 1, true);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        beam.position.y = -16.5;
        mothershipGroup.add(beam);
        mothershipGroup.position.set(0, 45, -20);
        scene.add(mothershipGroup);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 1000; i++) {
            starPositions.push((Math.random() - 0.5) * 200);
            starPositions.push((Math.random() - 0.5) * 100 + 20);
            starPositions.push((Math.random() - 0.5) * 200);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const stars = new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
        scene.add(stars);

        // 360 Sphere Background - VIBRANT NEBULA CHAOS
        const sphereGeo = new THREE.SphereGeometry(500, 64, 64);
        sphereGeo.scale(-1, 1, 1); // Invert for inside view
        
        // Create procedural nebula texture with canvas
        const nebulaCanvas = document.createElement('canvas');
        nebulaCanvas.width = 2048;
        nebulaCanvas.height = 1024;
        const ctx = nebulaCanvas.getContext('2d');
        
        // Deep space gradient base
        const bgGrad = ctx.createRadialGradient(1024, 512, 0, 1024, 512, 1024);
        bgGrad.addColorStop(0, '#1a0a2e');
        bgGrad.addColorStop(0.3, '#16213e');
        bgGrad.addColorStop(0.6, '#0f0f23');
        bgGrad.addColorStop(1, '#050510');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, 2048, 1024);
        
        // Add colorful nebula clouds
        const nebulaColors = ['#ff006680', '#00ff8850', '#ff00ff40', '#00ffff50', '#ffaa0040', '#ff440060'];
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * 2048;
            const y = Math.random() * 1024;
            const radius = 50 + Math.random() * 300;
            const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
            const nebGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
            nebGrad.addColorStop(0, color);
            nebGrad.addColorStop(0.5, color.slice(0, 7) + '20');
            nebGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = nebGrad;
            ctx.fillRect(0, 0, 2048, 1024);
        }
        
        // Add bright stars
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * 2048;
            const y = Math.random() * 1024;
            const size = Math.random() * 3;
            const brightness = Math.random();
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + brightness * 0.5})`;
            ctx.fill();
            // Star glow
            if (size > 1.5) {
                const starGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 4);
                starGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                starGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.3)');
                starGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = starGrad;
                ctx.fillRect(x - size * 4, y - size * 4, size * 8, size * 8);
            }
        }
        
        // Add some "inappropriate" fun elements - party vibes!
        const funEmojis = ['üéâ', 'üî•', 'üíé', 'üöÄ', 'üåà', '‚ú®', 'üëΩ', 'üõ∏', 'üí∞', 'üé∞'];
        ctx.font = '40px Arial';
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * 2000;
            const y = Math.random() * 1000;
            ctx.globalAlpha = 0.3 + Math.random() * 0.4;
            ctx.fillText(funEmojis[Math.floor(Math.random() * funEmojis.length)], x, y);
        }
        ctx.globalAlpha = 1;
        
        const sphereTexture = new THREE.CanvasTexture(nebulaCanvas);
        sphereTexture.wrapS = THREE.RepeatWrapping;
        sphereTexture.wrapT = THREE.RepeatWrapping;
        const sphereMat = new THREE.MeshBasicMaterial({ map: sphereTexture, side: THREE.BackSide });
        const skySphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(skySphere);
        
        // Define web center for spider web network
        const webCenter = new THREE.Vector3(0, 5, 0);
        
        // Add a glowing spider at the center of the web!
        const spiderGroup = new THREE.Group();
        const spiderBody = new THREE.Mesh(
            new THREE.SphereGeometry(2, 16, 16),
            new THREE.MeshPhongMaterial({ color: 0x222222, emissive: 0xff0000, emissiveIntensity: 0.3 })
        );
        spiderGroup.add(spiderBody);
        const spiderHead = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 16, 16),
            new THREE.MeshPhongMaterial({ color: 0x111111, emissive: 0xff0000, emissiveIntensity: 0.2 })
        );
        spiderHead.position.set(0, 0, 2.5);
        spiderGroup.add(spiderHead);
        // Spider eyes
        for (let e = 0; e < 8; e++) {
            const eye = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            const eyeAngle = (e / 8) * Math.PI - Math.PI / 2;
            eye.position.set(Math.sin(eyeAngle) * 0.8, 0.3 + (e % 2) * 0.3, 3.2 + Math.cos(eyeAngle) * 0.3);
            spiderGroup.add(eye);
        }
        // Spider legs
        for (let leg = 0; leg < 8; leg++) {
            const legAngle = (leg / 8) * Math.PI * 2;
            const legGroup = new THREE.Group();
            const segment1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.1, 4, 8),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            segment1.rotation.z = Math.PI / 3;
            segment1.position.set(2, 1, 0);
            legGroup.add(segment1);
            const segment2 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.05, 5, 8),
                new THREE.MeshPhongMaterial({ color: 0x222222 })
            );
            segment2.rotation.z = -Math.PI / 4;
            segment2.position.set(4.5, -0.5, 0);
            legGroup.add(segment2);
            legGroup.rotation.y = legAngle;
            spiderGroup.add(legGroup);
        }
        spiderGroup.position.copy(webCenter);
        scene.add(spiderGroup);

        // Rival Carts
        const rivalCarts = [];
        const rivalColors = [0x00ff00, 0xff00ff, 0x00ffff, 0xffff00];
        const riderColors = [0xff8800, 0x8800ff, 0x0088ff, 0xff0088];
        
        for (let r = 0; r < 4; r++) {
            const rivalGroup = new THREE.Group();
            const rivalBody = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.8, 1),
                new THREE.MeshPhongMaterial({ color: rivalColors[r], shininess: 100 })
            );
            rivalGroup.add(rivalBody);
            
            const rivalRiderBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.25, 0.6, 8),
                new THREE.MeshPhongMaterial({ color: riderColors[r] })
            );
            rivalRiderBody.position.y = 0.7;
            rivalGroup.add(rivalRiderBody);
            
            const rivalHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xffcc99 })
            );
            rivalHead.position.y = 1.2;
            rivalGroup.add(rivalHead);
            
            rivalGroup.userData = { offset: (r + 1) * 0.05, zOffset: (r % 2 === 0 ? -3 : 3) + (r > 1 ? 1 : -1) };
            scene.add(rivalGroup);
            rivalCarts.push(rivalGroup);
        }

        // TOROIDAL SPIDER WEB TRACK NETWORK - COSMIC DONUT!
        // webCenter already defined above for spider
        const torusR = 35; // Major radius (center of tube to center of torus)
        const torusr = 12; // Minor radius (radius of the tube)
        const numToroidalTracks = 12; // Tracks going around the donut hole
        const numPoloidalTracks = 8; // Tracks going around the tube
        const allWebCurves = [];
        const webTrackColors = [0xf7931a, 0x00ffff, 0xff00ff, 0x00ff88, 0xff4444, 0xffff00, 0xff8800, 0x88ff00, 0xff0088, 0x0088ff, 0xaa00ff, 0x00ffaa];
        
        // Helper function to get point on torus surface
        function getTorusPoint(u, v, majorR, minorR) {
            // u = angle around the hole (0 to 2œÄ)
            // v = angle around the tube (0 to 2œÄ)
            const x = (majorR + minorR * Math.cos(v)) * Math.cos(u);
            const y = minorR * Math.sin(v);
            const z = (majorR + minorR * Math.cos(v)) * Math.sin(u);
            return new THREE.Vector3(x + webCenter.x, y + webCenter.y, z + webCenter.z);
        }
        
        // Create TOROIDAL tracks (going around the donut hole) - WRAPPING!
        for (let i = 0; i < numToroidalTracks; i++) {
            const v = (i / numToroidalTracks) * Math.PI * 2; // Fixed position on tube circumference
            const toroidalPoints = [];
            for (let j = 0; j <= 100; j++) {
                const u = (j / 100) * Math.PI * 2;
                const wave = Math.sin(u * 6 + i) * 1.5; // Wavy variation
                const point = getTorusPoint(u, v + wave * 0.1, torusR, torusr + wave);
                toroidalPoints.push(point);
            }
            const toroidalCurve = new THREE.CatmullRomCurve3(toroidalPoints, true); // TRUE = closed loop!
            allWebCurves.push(toroidalCurve);
            const toroidalTube = new THREE.TubeGeometry(toroidalCurve, 300, 0.15, 8, false);
            const toroidalMesh = new THREE.Mesh(toroidalTube, new THREE.MeshPhongMaterial({
                color: webTrackColors[i % webTrackColors.length],
                emissive: webTrackColors[i % webTrackColors.length],
                emissiveIntensity: 0.4,
                shininess: 100
            }));
            scene.add(toroidalMesh);
        }
        
        // Create POLOIDAL tracks (going around the tube) - Also wrapping!
        for (let i = 0; i < numPoloidalTracks; i++) {
            const u = (i / numPoloidalTracks) * Math.PI * 2; // Fixed position around hole
            const poloidalPoints = [];
            for (let j = 0; j <= 80; j++) {
                const v = (j / 80) * Math.PI * 2;
                const wave = Math.cos(v * 4 + i * 2) * 1;
                const point = getTorusPoint(u + wave * 0.05, v, torusR + wave, torusr);
                poloidalPoints.push(point);
            }
            const poloidalCurve = new THREE.CatmullRomCurve3(poloidalPoints, true); // Closed loop!
            allWebCurves.push(poloidalCurve);
            const poloidalTube = new THREE.TubeGeometry(poloidalCurve, 200, 0.12, 8, false);
            const poloidalColor = webTrackColors[(i + 6) % webTrackColors.length];
            const poloidalMesh = new THREE.Mesh(poloidalTube, new THREE.MeshPhongMaterial({
                color: poloidalColor,
                emissive: poloidalColor,
                emissiveIntensity: 0.3,
                shininess: 80
            }));
            scene.add(poloidalMesh);
        }
        
        // Create SPIRAL tracks that wind around the torus surface!
        for (let i = 0; i < 6; i++) {
            const spiralPoints = [];
            const spiralTwist = 3 + i; // How many times it wraps around
            for (let t = 0; t <= 200; t++) {
                const progress = t / 200;
                const u = progress * Math.PI * 2 * spiralTwist;
                const v = progress * Math.PI * 2 * 2; // Goes around tube twice per full spiral
                const wave = Math.sin(progress * Math.PI * 8 + i) * 2;
                const point = getTorusPoint(u, v, torusR + wave * 0.5, torusr + wave * 0.3);
                spiralPoints.push(point);
            }
            const spiralCurve = new THREE.CatmullRomCurve3(spiralPoints);
            allWebCurves.push(spiralCurve);
            const spiralTube = new THREE.TubeGeometry(spiralCurve, 400, 0.08, 6, false);
            const spiralMesh = new THREE.Mesh(spiralTube, new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x888888,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.6
            }));
            scene.add(spiralMesh);
        }
        
        // Add a ghostly torus surface for visual reference
        const torusGeo = new THREE.TorusGeometry(torusR, torusr, 32, 100);
        const torusMat = new THREE.MeshPhongMaterial({
            color: 0x220033,
            emissive: 0x110022,
            transparent: true,
            opacity: 0.15,
            wireframe: false,
            side: THREE.DoubleSide
        });
        const torusMesh = new THREE.Mesh(torusGeo, torusMat);
        torusMesh.position.copy(webCenter);
        torusMesh.rotation.x = Math.PI / 2;
        scene.add(torusMesh);
        
        // Add wireframe overlay for that TRON feel
        const torusWireGeo = new THREE.TorusGeometry(torusR, torusr, 16, 48);
        const torusWireMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        const torusWireMesh = new THREE.Mesh(torusWireGeo, torusWireMat);
        torusWireMesh.position.copy(webCenter);
        torusWireMesh.rotation.x = Math.PI / 2;
        scene.add(torusWireMesh)
        
        // Original crossroad curves for compatibility
        const crossroadPoints1 = trackPoints.map((p, i) => {
            const wave = Math.sin(i * 0.08) * 8;
            return new THREE.Vector3(p.x, p.y + Math.sin(i * 0.05) * 3, p.z + wave + 5);
        });
        const crossCurve1 = new THREE.CatmullRomCurve3(crossroadPoints1);
        allWebCurves.push(crossCurve1);
        const crossTube1 = new THREE.TubeGeometry(crossCurve1, 500, 0.12, 8, false);
        const crossTrack1 = new THREE.Mesh(crossTube1, new THREE.MeshPhongMaterial({ 
            color: 0x00ffff, emissive: 0x00aaaa, emissiveIntensity: 0.3 
        }));
        scene.add(crossTrack1);

        const crossroadPoints2 = trackPoints.map((p, i) => {
            const wave = Math.cos(i * 0.06) * 6;
            return new THREE.Vector3(p.x, p.y - Math.cos(i * 0.04) * 4, p.z + wave - 5);
        });
        const crossCurve2 = new THREE.CatmullRomCurve3(crossroadPoints2);
        allWebCurves.push(crossCurve2);
        const crossTube2 = new THREE.TubeGeometry(crossCurve2, 500, 0.12, 8, false);
        const crossTrack2 = new THREE.Mesh(crossTube2, new THREE.MeshPhongMaterial({ 
            color: 0xff00ff, emissive: 0xaa00aa, emissiveIntensity: 0.3 
        }));
        scene.add(crossTrack2);

        // Animation - Endless Track System
        let t = 0;
        let lastY = 0;
        let currentTrackIndex = 0;
        const tracks = [curve, crossCurve1, crossCurve2];
        let activeTrack = curve;
        let transitionProgress = 0;
        let isTransitioning = false;
        let nextTrack = null;
        const transitionDuration = 0.05; // How long the blend takes
        const priceEl = document.getElementById('price');
        const changeEl = document.getElementById('change');
        const screamEl = document.getElementById('scream');

        function animate() {
            requestAnimationFrame(animate);
            
            t += 0.001;
            
            // Endless track logic - switch tracks at crossroads
            if (t > 0.95 && !isTransitioning) {
                isTransitioning = true;
                transitionProgress = 0;
                // Pick a random next track (different from current)
                const availableTracks = tracks.filter(tr => tr !== activeTrack);
                nextTrack = availableTracks[Math.floor(Math.random() * availableTracks.length)];
            }
            
            if (isTransitioning) {
                transitionProgress += 0.02;
                if (transitionProgress >= 1) {
                    activeTrack = nextTrack;
                    t = 0.05; // Start slightly into the new track
                    isTransitioning = false;
                    transitionProgress = 0;
                    currentTrackIndex = tracks.indexOf(activeTrack);
                }
            }
            
            // Wrap t smoothly for endless feel
            if (t > 1 && !isTransitioning) {
                t = 0;
            }

            // Get position with smooth track transitions
            let position, tangent;
            if (isTransitioning && nextTrack) {
                const currentPos = activeTrack.getPoint(Math.min(t, 0.99));
                const nextPos = nextTrack.getPoint(0.05 + transitionProgress * 0.1);
                const currentTan = activeTrack.getTangent(Math.min(t, 0.99));
                const nextTan = nextTrack.getTangent(0.05 + transitionProgress * 0.1);
                
                // Smooth blend between tracks
                const blend = transitionProgress * transitionProgress * (3 - 2 * transitionProgress); // smoothstep
                position = new THREE.Vector3().lerpVectors(currentPos, nextPos, blend);
                tangent = new THREE.Vector3().lerpVectors(currentTan, nextTan, blend).normalize();
            } else {
                position = activeTrack.getPoint(t);
                tangent = activeTrack.getTangent(t);
            }
            
            cartGroup.position.copy(position);
            cartGroup.position.z += 0.5;
            cartGroup.position.y += 0.5;
            
            // Tilt based on slope with LOOPING support!
            const lookAt = position.clone().add(tangent);
            cartGroup.lookAt(lookAt);
            
            // Check if near a loop and add barrel roll effect
            loopStructures.forEach(loop => {
                const distToLoop = Math.abs(position.x - loop.x);
                if (distToLoop < 8) {
                    // Calculate loop progress based on distance
                    const loopProgress = 1 - (distToLoop / 8);
                    const loopAngle = loopProgress * Math.PI * 2 * Math.sign(position.x - loop.x + 0.01);
                    cartGroup.rotation.x += Math.sin(loopAngle) * loopProgress * 0.5;
                    cartGroup.rotation.z += Math.cos(loopAngle * 2) * loopProgress * 0.3;
                }
            });

            // Smooth camera follow with interpolation
            const targetCamX = position.x - tangent.x * 8;
            const targetCamY = position.y + 4;
            const targetCamZ = position.z + 8;
            const lerpFactor = 0.03; // Lower = smoother/slower
            
            camera.position.x += (targetCamX - camera.position.x) * lerpFactor;
            camera.position.y += (targetCamY - camera.position.y) * lerpFactor;
            camera.position.z += (targetCamZ - camera.position.z) * lerpFactor;
            
            // Smooth look-at using a target object
            const targetLook = cartGroup.position.clone();
            if (!camera.userData.lookTarget) camera.userData.lookTarget = targetLook.clone();
            camera.userData.lookTarget.lerp(targetLook, lerpFactor * 2);
            camera.lookAt(camera.userData.lookTarget);

            // Update price display - continuous price evolution
            const currentPriceIndex = Math.floor(t * priceData.length);
            let currentPrice = priceData[currentPriceIndex] || priceData[0];
            // Add track-based price modifier for variety
            const trackModifier = 1 + (currentTrackIndex * 0.1) * Math.sin(Date.now() * 0.001);
            currentPrice *= trackModifier;
            priceEl.textContent = '$' + currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            
            const changePercent = ((currentPrice - priceData[0]) / priceData[0] * 100);
            const isUp = changePercent >= 0;
            changeEl.textContent = (isUp ? '‚ñ≤ +' : '‚ñº ') + changePercent.toFixed(2) + '%';
            changeEl.style.color = isUp ? '#00ff88' : '#ff4444';
            priceEl.className = 'price ' + (isUp ? 'up' : 'down');
            
            // Update track indicator
            const trackNames = ['MAIN LOOP', 'CYAN SPIRAL', 'MAGENTA TWIST'];
            const trackIndicator = document.getElementById('track-indicator');
            if (isTransitioning) {
                trackIndicator.textContent = '‚ö° SWITCHING TRACKS...';
                trackIndicator.style.color = '#ffff00';
            } else {
                trackIndicator.textContent = 'TRACK: ' + trackNames[currentTrackIndex];
                trackIndicator.style.color = [0x00ff88, 0x00ffff, 0xff00ff][currentTrackIndex] ? '#' + [0x00ff88, 0x00ffff, 0xff00ff][currentTrackIndex].toString(16).padStart(6, '0') : '#888';
            }

            // Animate UFOs
            ufos.forEach((ufo, i) => {
                const data = ufo.userData;
                const time = Date.now() * 0.001;
                ufo.position.x = Math.cos(time * data.orbitSpeed + data.orbitOffset) * data.orbitRadius;
                ufo.position.z = Math.sin(time * data.orbitSpeed + data.orbitOffset) * data.orbitRadius * 0.5 - 10;
                ufo.position.y = 15 + Math.sin(time * 2 + data.hoverOffset) * 3;
                ufo.rotation.y = time * 2;
                // UFO looks at the cart
                ufo.lookAt(cartGroup.position);
                ufo.rotation.x = 0;
                ufo.rotation.z = 0;
            });
            
            // Mothership slow rotation and beam pulse
            mothershipGroup.rotation.y += 0.002;
            beam.material.opacity = 0.1 + Math.sin(Date.now() * 0.003) * 0.1;

            // Update audio based on height
            const yDiff = position.y - lastY;
            updateAudioFromHeight(position.y, yDiff);
            
            // Scream on big drops
            if (yDiff < -0.15) {
                screamEl.style.opacity = '1';
                screamEl.textContent = ['üò±', 'üé¢', 'üìâ', 'üíÄ', 'üëΩ', 'üõ∏', '‚àû', 'üîÄ'][Math.floor(Math.random() * 8)];
            } else {
                screamEl.style.opacity = '0';
            }
            lastY = position.y;

            // Animate rival carts on crossroads
            rivalCarts.forEach((rival, idx) => {
                const rivalT = (t + rival.userData.offset) % 1;
                const useCurve = idx < 2 ? crossCurve1 : crossCurve2;
                const rivalPos = useCurve.getPoint(rivalT);
                const rivalTan = useCurve.getTangent(rivalT);
                rival.position.copy(rivalPos);
                rival.position.z += rival.userData.zOffset;
                rival.position.y += 0.5;
                const rivalLook = rivalPos.clone().add(rivalTan);
                rival.lookAt(rivalLook);
            });

            // Rotate sky sphere slowly for trippy effect
            skySphere.rotation.y += 0.0003;
            skySphere.rotation.x += 0.0001;
            
            // Animate the spider at the center of the web
            if (spiderGroup) {
                spiderGroup.rotation.y += 0.005;
                spiderGroup.position.y = webCenter.y + Math.sin(Date.now() * 0.002) * 2;
                // Animate spider legs
                spiderGroup.children.forEach((child, i) => {
                    if (i > 9) { // Leg groups
                        child.rotation.x = Math.sin(Date.now() * 0.005 + i) * 0.2;
                    }
                });
            }
            
            // Animate toroidal structures
            if (torusMesh) {
                torusMesh.rotation.z += 0.001;
                torusWireMesh.rotation.z += 0.001;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>