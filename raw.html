<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Minecraft 3D Simulator</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        canvas { display: block; }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }
        
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            z-index: 100;
        }
        
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.7);
            border: 3px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .hotbar-slot.active {
            border-color: #fff;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            mix-blend-mode: difference;
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        #title-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            animation: fadeOut 3s ease-out 2s forwards;
        }
        
        #title-overlay h1 {
            font-size: 48px;
            color: #fff;
            text-shadow: 4px 4px 0 #3f3f3f, -2px -2px 0 #000;
            letter-spacing: 4px;
        }
        
        #title-overlay p {
            font-size: 18px;
            color: #ffff00;
            text-shadow: 2px 2px 0 #000;
            margin-top: 10px;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; pointer-events: none; }
        }
        
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="hud">
<div>‚õèÔ∏è Minecraft Simulator</div>
<div id="coords">X: 0 Y: 64 Z: 0</div>
<div id="time-display">‚òÄÔ∏è Day</div>
</div>
<div id="hotbar">
<div class="hotbar-slot active">üü´</div>
<div class="hotbar-slot">üü©</div>
<div class="hotbar-slot">‚¨ú</div>
<div class="hotbar-slot">ü™®</div>
<div class="hotbar-slot">ü™µ</div>
<div class="hotbar-slot">üå≥</div>
<div class="hotbar-slot">üíé</div>
<div class="hotbar-slot">üî•</div>
<div class="hotbar-slot">üíß</div>
</div>
<div id="crosshair"></div>
<div id="title-overlay">
<h1>MINECRAFT</h1>
<p>üéÆ Auto-Exploring World...</p>
<p style="color:#E52521;margin-top:5px;">üçÑ SUPER MARIO MINECRAFT!</p>
<p style="color:#FFD700;margin-top:5px;">Arrow Keys/WASD: Move | Space: Jump</p>
</div>
<div id="mode-indicator">üéÆ SUPER MARIO MODE - Arrow Keys + Space</div>
<div id="mario-hud" style="position:absolute;top:50px;left:10px;background:rgba(0,0,0,0.8);color:#fff;padding:10px 15px;border-radius:5px;font-size:16px;z-index:100;font-family:'Courier New',monospace;">
<div>ü™ô COINS: <span id="coin-count">0</span></div>
<div>‚≠ê SCORE: <span id="score-count">0</span></div>
<div>‚ù§Ô∏è LIVES: <span id="lives-count">3</span></div>
</div>
<div id="controls-help" style="position:absolute;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#fff;padding:10px 20px;border-radius:5px;font-size:12px;z-index:100;text-align:center;">W/A/S/D: Move | Mouse: Look | Space: Jump | Shift: Descend</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/simplex-noise@2.4.0/simplex-noise.js"></script>
<script>
        // Minecraft 3D Simulator - Vanilla Edition
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        // Simplex noise for terrain
        const simplex = new SimplexNoise();
        
        // Block textures (procedural)
        function createBlockTexture(baseColor, variation = 0.1) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);
            
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    const noise = (Math.random() - 0.5) * variation * 255;
                    const pr = Math.max(0, Math.min(255, r + noise));
                    const pg = Math.max(0, Math.min(255, g + noise));
                    const pb = Math.max(0, Math.min(255, b + noise));
                    ctx.fillStyle = `rgb(${pr},${pg},${pb})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Block materials
        const materials = {
            grass_top: new THREE.MeshLambertMaterial({ map: createBlockTexture('#5D8C3D', 0.15) }),
            grass_side: new THREE.MeshLambertMaterial({ map: createBlockTexture('#8B6914', 0.1) }),
            dirt: new THREE.MeshLambertMaterial({ map: createBlockTexture('#8B6914', 0.12) }),
            stone: new THREE.MeshLambertMaterial({ map: createBlockTexture('#808080', 0.15) }),
            water: new THREE.MeshLambertMaterial({ color: 0x3399ff, transparent: true, opacity: 0.7 }),
            wood: new THREE.MeshLambertMaterial({ map: createBlockTexture('#6B4423', 0.1) }),
            leaves: new THREE.MeshLambertMaterial({ map: createBlockTexture('#228B22', 0.2), transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ map: createBlockTexture('#C2B280', 0.08) }),
            bedrock: new THREE.MeshLambertMaterial({ map: createBlockTexture('#1a1a1a', 0.2) })
        };
        
        // Grass block with different top/sides
        const grassMaterials = [
            materials.grass_side, materials.grass_side,
            materials.grass_top, materials.dirt,
            materials.grass_side, materials.grass_side
        ];
        
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        const blocks = [];
        
        // World generation
        const WORLD_SIZE = 32;
        const WATER_LEVEL = 62;
        
        function getHeight(x, z) {
            const scale1 = 0.05;
            const scale2 = 0.1;
            const noise1 = simplex.noise2D(x * scale1, z * scale1) * 15;
            const noise2 = simplex.noise2D(x * scale2, z * scale2) * 5;
            return Math.floor(60 + noise1 + noise2);
        }
        
        function generateWorld() {
            for (let x = -WORLD_SIZE; x < WORLD_SIZE; x++) {
                for (let z = -WORLD_SIZE; z < WORLD_SIZE; z++) {
                    const height = getHeight(x, z);
                    
                    // Bedrock
                    const bedrock = new THREE.Mesh(blockGeometry, materials.bedrock);
                    bedrock.position.set(x, 0, z);
                    scene.add(bedrock);
                    
                    // Stone layers
                    for (let y = 1; y < height - 4; y++) {
                        if (Math.random() > 0.7) continue; // Skip some for performance
                        const stone = new THREE.Mesh(blockGeometry, materials.stone);
                        stone.position.set(x, y, z);
                        scene.add(stone);
                    }
                    
                    // Dirt layers
                    for (let y = Math.max(1, height - 4); y < height; y++) {
                        const dirt = new THREE.Mesh(blockGeometry, materials.dirt);
                        dirt.position.set(x, y, z);
                        scene.add(dirt);
                    }
                    
                    // Top layer
                    if (height > WATER_LEVEL) {
                        const grass = new THREE.Mesh(blockGeometry, grassMaterials);
                        grass.position.set(x, height, z);
                        scene.add(grass);
                        blocks.push(grass);
                        
                        // Trees
                        if (Math.random() < 0.02 && height > WATER_LEVEL + 2) {
                            generateTree(x, height + 1, z);
                        }
                    } else if (height === WATER_LEVEL) {
                        const sand = new THREE.Mesh(blockGeometry, materials.sand);
                        sand.position.set(x, height, z);
                        scene.add(sand);
                    } else {
                        const sand = new THREE.Mesh(blockGeometry, materials.sand);
                        sand.position.set(x, height, z);
                        scene.add(sand);
                    }
                    
                    // Water
                    if (height < WATER_LEVEL) {
                        const water = new THREE.Mesh(blockGeometry, materials.water);
                        water.position.set(x, WATER_LEVEL, z);
                        scene.add(water);
                    }
                }
            }
        }
        
        function generateTree(x, y, z) {
            // Trunk
            for (let i = 0; i < 5; i++) {
                const trunk = new THREE.Mesh(blockGeometry, materials.wood);
                trunk.position.set(x, y + i, z);
                scene.add(trunk);
            }
            
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 3; ly <= 5; ly++) {
                        if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly < 5) continue;
                        if (ly === 5 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue;
                        if (lx === 0 && lz === 0 && ly < 5) continue;
                        
                        const leaf = new THREE.Mesh(blockGeometry, materials.leaves);
                        leaf.position.set(x + lx, y + ly, z + lz);
                        scene.add(leaf);
                    }
                }
            }
        }
        
        generateWorld();
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffcc, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        scene.add(sunLight);
        
        // Fog for atmosphere
        scene.fog = new THREE.Fog(0x87CEEB, 30, 80);
        
        // Camera setup
        camera.position.set(0, 75, 20);
        camera.lookAt(0, 65, 0);
        
        // Player controls
        let playerPos = { x: 0, y: 75, z: 20 };
        let playerVel = { x: 0, y: 0, z: 0 };
        let yaw = 0;
        let pitch = 0;
        const moveSpeed = 0.15;
        const jumpForce = 0.3;
        const gravity = 0.01;
        let isJumping = false;
        let isPointerLocked = false;
        
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (key === ' ') keys.space = true;
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (key === ' ') keys.space = false;
        });
        
        document.getElementById('game-container').addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('mode-indicator').textContent = isPointerLocked ? 'üéÆ PLAYING - ESC to exit' : 'üéÆ CLICK TO PLAY - WASD + Mouse';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        });
        
        function updatePlayer() {
            // Movement direction based on yaw
            let moveX = 0, moveZ = 0;
            
            if (keys.w) { moveX += Math.sin(yaw); moveZ += Math.cos(yaw); }
            if (keys.s) { moveX -= Math.sin(yaw); moveZ -= Math.cos(yaw); }
            if (keys.a) { moveX += Math.cos(yaw); moveZ -= Math.sin(yaw); }
            if (keys.d) { moveX -= Math.cos(yaw); moveZ += Math.sin(yaw); }
            
            // Normalize diagonal movement
            const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (len > 0) {
                moveX = (moveX / len) * moveSpeed;
                moveZ = (moveZ / len) * moveSpeed;
            }
            
            playerPos.x += moveX;
            playerPos.z += moveZ;
            
            // Vertical movement
            if (keys.space) playerVel.y = jumpForce;
            if (keys.shift) playerVel.y = -jumpForce;
            
            playerVel.y -= gravity;
            playerPos.y += playerVel.y;
            
            // Ground collision (simple)
            const groundHeight = getHeight(Math.floor(playerPos.x), Math.floor(playerPos.z)) + 3;
            if (playerPos.y < groundHeight) {
                playerPos.y = groundHeight;
                playerVel.y = 0;
            }
            if (playerPos.y > 120) playerPos.y = 120;
            
            // Update camera
            camera.position.set(playerPos.x, playerPos.y, playerPos.z);
            
            // Camera look direction
            const lookX = playerPos.x + Math.sin(yaw) * Math.cos(pitch);
            const lookY = playerPos.y + Math.sin(pitch);
            const lookZ = playerPos.z + Math.cos(yaw) * Math.cos(pitch);
            camera.lookAt(lookX, lookY, lookZ);
        }
        
        // Day/night cycle
        let dayTime = 0;
        const DAY_LENGTH = 120; // seconds
        
        function updateDayNight() {
            dayTime += 0.016;
            const cycle = (dayTime % DAY_LENGTH) / DAY_LENGTH;
            const sunAngle = cycle * Math.PI * 2;
            
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 100;
            
            const isDay = Math.sin(sunAngle) > -0.2;
            const brightness = Math.max(0.2, Math.sin(sunAngle) * 0.5 + 0.5);
            
            ambientLight.intensity = brightness * 0.8;
            sunLight.intensity = brightness;
            
            const skyColor = isDay ? 
                new THREE.Color(0.53 * brightness, 0.81 * brightness, 0.92 * brightness) :
                new THREE.Color(0.05, 0.05, 0.15);
            
            renderer.setClearColor(skyColor);
            scene.fog.color = skyColor;
            
            document.getElementById('time-display').textContent = isDay ? '‚òÄÔ∏è Day' : 'üåô Night';
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Player movement update
            updatePlayer();
            
            // Update HUD
            document.getElementById('coords').textContent = 
                `X: ${Math.floor(playerPos.x)} Y: ${Math.floor(playerPos.y)} Z: ${Math.floor(playerPos.z)}`;
            
            updateDayNight();
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mario NPC - A blocky visitor from another game!
        const marioGroup = new THREE.Group();
        
        // Mario colors
        const marioRed = new THREE.MeshLambertMaterial({ color: 0xE52521 });
        const marioBlue = new THREE.MeshLambertMaterial({ color: 0x1560BD });
        const marioSkin = new THREE.MeshLambertMaterial({ color: 0xFEB57A });
        const marioBrown = new THREE.MeshLambertMaterial({ color: 0x6B3E26 });
        const marioYellow = new THREE.MeshLambertMaterial({ color: 0xFBD000 });
        
        const smallBlock = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const medBlock = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        
        // Mario's body (blocky style)
        // Legs (blue)
        const leftLeg = new THREE.Mesh(medBlock, marioBlue);
        leftLeg.position.set(-0.15, 0.2, 0);
        marioGroup.add(leftLeg);
        const rightLeg = new THREE.Mesh(medBlock, marioBlue);
        rightLeg.position.set(0.15, 0.2, 0);
        marioGroup.add(rightLeg);
        
        // Torso (red)
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.4), marioRed);
        torso.position.set(0, 0.65, 0);
        marioGroup.add(torso);
        
        // Arms (red)
        const leftArm = new THREE.Mesh(smallBlock, marioSkin);
        leftArm.position.set(-0.4, 0.6, 0);
        marioGroup.add(leftArm);
        const rightArm = new THREE.Mesh(smallBlock, marioSkin);
        rightArm.position.set(0.4, 0.6, 0);
        marioGroup.add(rightArm);
        
        // Head (skin)
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), marioSkin);
        head.position.set(0, 1.15, 0);
        marioGroup.add(head);
        
        // Hat (red)
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.55), marioRed);
        hat.position.set(0, 1.45, 0);
        marioGroup.add(hat);
        const hatBrim = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.1, 0.3), marioRed);
        hatBrim.position.set(0, 1.35, 0.2);
        marioGroup.add(hatBrim);
        
        // Mustache (brown)
        const mustache = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), marioBrown);
        mustache.position.set(0, 1.0, 0.25);
        marioGroup.add(mustache);
        
        // Eyes (white dots)
        const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
        leftEye.position.set(-0.12, 1.2, 0.26);
        marioGroup.add(leftEye);
        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
        rightEye.position.set(0.12, 1.2, 0.26);
        marioGroup.add(rightEye);
        
        // Position Mario in the world
        marioGroup.position.set(5, getHeight(5, 5) + 1, 5);
        scene.add(marioGroup);
        
        // Mario walking AI
        let marioAngle = 0;
        let marioWalkTime = 0;
        const marioSpeed = 0.03;
        
        function updateMario() {
            marioWalkTime += 0.05;
            
            // Change direction occasionally
            if (Math.random() < 0.01) {
                marioAngle += (Math.random() - 0.5) * Math.PI;
            }
            
            // Move Mario
            const newX = marioGroup.position.x + Math.sin(marioAngle) * marioSpeed;
            const newZ = marioGroup.position.z + Math.cos(marioAngle) * marioSpeed;
            
            // Keep in bounds
            if (Math.abs(newX) < WORLD_SIZE - 5 && Math.abs(newZ) < WORLD_SIZE - 5) {
                marioGroup.position.x = newX;
                marioGroup.position.z = newZ;
            } else {
                marioAngle += Math.PI; // Turn around at edges
            }
            
            // Terrain following
            const groundY = getHeight(Math.floor(marioGroup.position.x), Math.floor(marioGroup.position.z)) + 1;
            marioGroup.position.y = groundY;
            
            // Face walking direction
            marioGroup.rotation.y = -marioAngle;
            
            // Walking animation (leg bob)
            leftLeg.position.y = 0.2 + Math.sin(marioWalkTime * 3) * 0.1;
            rightLeg.position.y = 0.2 + Math.sin(marioWalkTime * 3 + Math.PI) * 0.1;
            leftArm.position.y = 0.6 + Math.sin(marioWalkTime * 3 + Math.PI) * 0.1;
            rightArm.position.y = 0.6 + Math.sin(marioWalkTime * 3) * 0.1;
        }
        
        // Add Mario update to animation loop
        const originalAnimate = animate;
        function animateWithMario() {
            updateMario();
        }
        setInterval(animateWithMario, 16);
        
        console.log('üçÑ It\'s-a me, Mario! Walking around the Minecraft world!');
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SUPER MARIO BROS MODE - Transform Minecraft into Mario!
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let marioCoins = 0;
        let marioScore = 0;
        let marioLives = 3;
        let marioVelY = 0;
        let marioOnGround = true;
        let marioControlled = true;
        const MARIO_JUMP = 0.35;
        const MARIO_GRAVITY = 0.015;
        const MARIO_SPEED = 0.12;
        
        // Mario Bros color palette
        const brickMat = new THREE.MeshLambertMaterial({ map: createBlockTexture('#8B4513', 0.15) });
        const questionMat = new THREE.MeshLambertMaterial({ map: createBlockTexture('#FFD700', 0.1) });
        const pipeMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const coinMat = new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 });
        const goombaMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        
        // Arrays to track collectibles and enemies
        const coins = [];
        const goombas = [];
        const questionBlocks = [];
        
        // Create Mario-style platforms and objects
        function createMarioPlatform(x, y, z, length) {
            for (let i = 0; i < length; i++) {
                const brick = new THREE.Mesh(blockGeometry, brickMat);
                brick.position.set(x + i, y, z);
                brick.userData.type = 'brick';
                scene.add(brick);
            }
        }
        
        function createQuestionBlock(x, y, z) {
            const qBlock = new THREE.Mesh(blockGeometry, questionMat);
            qBlock.position.set(x, y, z);
            qBlock.userData.type = 'question';
            qBlock.userData.hasItem = true;
            scene.add(qBlock);
            questionBlocks.push(qBlock);
            
            // Add ? symbol
            const qGeom = new THREE.BoxGeometry(0.3, 0.4, 0.1);
            const qMark = new THREE.Mesh(qGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
            qMark.position.set(x, y, z + 0.46);
            scene.add(qMark);
        }
        
        function createCoin(x, y, z) {
            const coinGeom = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
            const coin = new THREE.Mesh(coinGeom, coinMat);
            coin.position.set(x, y, z);
            coin.rotation.x = Math.PI / 2;
            coin.userData.type = 'coin';
            scene.add(coin);
            coins.push(coin);
        }
        
        function createPipe(x, y, z, height = 2) {
            const pipeGeom = new THREE.CylinderGeometry(0.7, 0.7, height, 8);
            const pipe = new THREE.Mesh(pipeGeom, pipeMat);
            pipe.position.set(x, y + height/2, z);
            scene.add(pipe);
            
            // Pipe rim
            const rimGeom = new THREE.CylinderGeometry(0.85, 0.85, 0.3, 8);
            const rim = new THREE.Mesh(rimGeom, pipeMat);
            rim.position.set(x, y + height + 0.15, z);
            scene.add(rim);
        }
        
        function createGoomba(x, y, z) {
            const goombaGroup = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.6), goombaMat);
            body.position.y = 0.25;
            goombaGroup.add(body);
            
            // Head
            const headMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
            const goombaHead = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.7), headMat);
            goombaHead.position.y = 0.7;
            goombaGroup.add(goombaHead);
            
            // Eyes (angry)
            const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const eyeBlack = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEyeG = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeWhite);
            leftEyeG.position.set(-0.15, 0.75, 0.35);
            goombaGroup.add(leftEyeG);
            const rightEyeG = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeWhite);
            rightEyeG.position.set(0.15, 0.75, 0.35);
            goombaGroup.add(rightEyeG);
            
            // Feet
            const footMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftFoot = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.3), footMat);
            leftFoot.position.set(-0.2, 0.075, 0);
            goombaGroup.add(leftFoot);
            const rightFoot = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.3), footMat);
            rightFoot.position.set(0.2, 0.075, 0);
            goombaGroup.add(rightFoot);
            
            goombaGroup.position.set(x, y, z);
            goombaGroup.userData.direction = Math.random() > 0.5 ? 1 : -1;
            goombaGroup.userData.alive = true;
            scene.add(goombaGroup);
            goombas.push(goombaGroup);
        }
        
        // Build Mario level elements around spawn
        const levelBaseY = getHeight(0, 0) + 1;
        
        // Floating brick platforms
        createMarioPlatform(-5, levelBaseY + 4, 0, 5);
        createMarioPlatform(8, levelBaseY + 6, 2, 4);
        createMarioPlatform(-10, levelBaseY + 8, -5, 6);
        createMarioPlatform(3, levelBaseY + 10, -8, 3);
        
        // Question blocks with coins
        createQuestionBlock(-3, levelBaseY + 4, 0);
        createQuestionBlock(0, levelBaseY + 4, 0);
        createQuestionBlock(10, levelBaseY + 6, 2);
        createQuestionBlock(-7, levelBaseY + 8, -5);
        createQuestionBlock(4, levelBaseY + 10, -8);
        
        // Floating coins
        for (let i = 0; i < 20; i++) {
            const cx = (Math.random() - 0.5) * 40;
            const cz = (Math.random() - 0.5) * 40;
            const cy = getHeight(Math.floor(cx), Math.floor(cz)) + 2 + Math.random() * 5;
            createCoin(cx, cy, cz);
        }
        
        // Pipes
        createPipe(-8, getHeight(-8, 8), 8, 2);
        createPipe(12, getHeight(12, -5), -5, 3);
        createPipe(-15, getHeight(-15, -10), -10, 4);
        
        // Goombas
        for (let i = 0; i < 8; i++) {
            const gx = (Math.random() - 0.5) * 30;
            const gz = (Math.random() - 0.5) * 30;
            const gy = getHeight(Math.floor(gx), Math.floor(gz)) + 1;
            createGoomba(gx, gy, gz);
        }
        
        // Mario controls - override the walking AI
        marioControlled = true;
        let marioFacing = 1;
        
        const marioKeys = { left: false, right: false, up: false, down: false, jump: false };
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') marioKeys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') marioKeys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w') marioKeys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') marioKeys.down = true;
            if (e.key === ' ') marioKeys.jump = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') marioKeys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') marioKeys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w') marioKeys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') marioKeys.down = false;
            if (e.key === ' ') marioKeys.jump = false;
        });
        
        // Override Mario update for platformer controls
        function updateMarioPlayer() {
            // Horizontal movement
            if (marioKeys.left) {
                marioGroup.position.x -= MARIO_SPEED;
                marioFacing = -1;
                marioGroup.rotation.y = Math.PI / 2;
            }
            if (marioKeys.right) {
                marioGroup.position.x += MARIO_SPEED;
                marioFacing = 1;
                marioGroup.rotation.y = -Math.PI / 2;
            }
            if (marioKeys.up) {
                marioGroup.position.z -= MARIO_SPEED;
                marioGroup.rotation.y = 0;
            }
            if (marioKeys.down) {
                marioGroup.position.z += MARIO_SPEED;
                marioGroup.rotation.y = Math.PI;
            }
            
            // Jumping
            if (marioKeys.jump && marioOnGround) {
                marioVelY = MARIO_JUMP;
                marioOnGround = false;
            }
            
            // Gravity
            marioVelY -= MARIO_GRAVITY;
            marioGroup.position.y += marioVelY;
            
            // Ground collision
            const groundY = getHeight(Math.floor(marioGroup.position.x), Math.floor(marioGroup.position.z)) + 1;
            if (marioGroup.position.y <= groundY) {
                marioGroup.position.y = groundY;
                marioVelY = 0;
                marioOnGround = true;
            }
            
            // Walking animation
            marioWalkTime += 0.1;
            if (marioKeys.left || marioKeys.right || marioKeys.up || marioKeys.down) {
                leftLeg.position.y = 0.2 + Math.sin(marioWalkTime * 5) * 0.15;
                rightLeg.position.y = 0.2 + Math.sin(marioWalkTime * 5 + Math.PI) * 0.15;
            }
            
            // Coin collection
            coins.forEach((coin, i) => {
                if (coin.visible && marioGroup.position.distanceTo(coin.position) < 1) {
                    coin.visible = false;
                    marioCoins++;
                    marioScore += 100;
                    document.getElementById('coin-count').textContent = marioCoins;
                    document.getElementById('score-count').textContent = marioScore;
                }
            });
            
            // Rotate visible coins
            coins.forEach(coin => {
                if (coin.visible) coin.rotation.y += 0.05;
            });
            
            // Goomba AI and collision
            goombas.forEach(goomba => {
                if (!goomba.userData.alive) return;
                
                // Move goomba
                goomba.position.x += goomba.userData.direction * 0.02;
                
                // Terrain follow
                const goombaGround = getHeight(Math.floor(goomba.position.x), Math.floor(goomba.position.z)) + 0.5;
                goomba.position.y = goombaGround;
                
                // Turn around at edges
                if (Math.abs(goomba.position.x) > WORLD_SIZE - 3) {
                    goomba.userData.direction *= -1;
                }
                
                // Collision with Mario
                const dist = marioGroup.position.distanceTo(goomba.position);
                if (dist < 1 && goomba.userData.alive) {
                    // Check if Mario is above (stomping)
                    if (marioGroup.position.y > goomba.position.y + 0.5 && marioVelY < 0) {
                        // Stomp!
                        goomba.userData.alive = false;
                        goomba.scale.y = 0.2;
                        marioScore += 200;
                        marioVelY = 0.2; // Bounce
                        document.getElementById('score-count').textContent = marioScore;
                    } else {
                        // Hit by goomba
                        marioLives--;
                        document.getElementById('lives-count').textContent = marioLives;
                        // Knockback
                        marioGroup.position.y += 2;
                        marioVelY = 0.2;
                        if (marioLives <= 0) {
                            alert('Game Over! Score: ' + marioScore);
                            marioLives = 3;
                            marioCoins = 0;
                            marioScore = 0;
                            document.getElementById('lives-count').textContent = marioLives;
                            document.getElementById('coin-count').textContent = marioCoins;
                            document.getElementById('score-count').textContent = marioScore;
                        }
                    }
                }
            });
            
            // Camera follows Mario (side-scrolling style with some freedom)
            camera.position.x = marioGroup.position.x - 8;
            camera.position.y = marioGroup.position.y + 5;
            camera.position.z = marioGroup.position.z + 12;
            camera.lookAt(marioGroup.position.x, marioGroup.position.y + 1, marioGroup.position.z);
            
            // Update coords to Mario position
            document.getElementById('coords').textContent = 
                `X: ${Math.floor(marioGroup.position.x)} Y: ${Math.floor(marioGroup.position.y)} Z: ${Math.floor(marioGroup.position.z)}`;
        }
        
        // Replace the original Mario update
        setInterval(updateMarioPlayer, 16);
        
        // Add classic Mario sound effect simulation (visual feedback)
        function showCoinEffect(x, y, z) {
            const effect = document.createElement('div');
            effect.textContent = '+100';
            effect.style.cssText = 'position:fixed;color:#FFD700;font-size:24px;font-weight:bold;pointer-events:none;z-index:1000;text-shadow:2px 2px #000;';
            effect.style.left = '50%';
            effect.style.top = '40%';
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 500);
        }
        
        console.log('üéÆ Super Mario Minecraft Mode Activated!');
        console.log('Use Arrow Keys or WASD to move, Space to jump!');
        console.log('Collect coins, stomp goombas, and explore!');
        
        // Chat integration for future interactivity
        try {
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const pathBase = location.pathname.includes('/twitch_plays_code') ? '/twitch_plays_code' : 
                           location.pathname.includes('/tpc') ? '/twitch_plays_code' : '';
            const chatWs = new WebSocket(`${wsProtocol}//${location.host}${pathBase}/ws/chat`);
            
            chatWs.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'chat_message') {
                    console.log(`üí¨ ${msg.username}: ${msg.message}`);
                }
            };
        } catch(e) {
            console.log('Chat WebSocket not available');
        }
    </script>
</body>
</html>