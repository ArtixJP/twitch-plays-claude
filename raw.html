<!DOCTYPE html>

<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<title>VoxelCraft - A Minecraft Clone</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            max-width: 250px;
        }
        #ui h1 {
            font-size: 1.5rem;
            color: #7CFC00;
            margin-bottom: 10px;
        }
        #ui p {
            font-size: 0.85rem;
            margin: 5px 0;
            opacity: 0.9;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.6);
            border: 3px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
        }
        .hotbar-slot.selected {
            border-color: #fff;
            background: rgba(255,255,255,0.2);
        }
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #7CFC00;
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 100;
            font-size: 0.9rem;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
            background: rgba(0,0,0,0.8);
            padding: 30px 50px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="loading">‚õèÔ∏è Generating World...</div>
<div id="ui">
<h1>‚õèÔ∏è VoxelCraft</h1>
<p>üéÆ WASD - Move</p>
<p>üñ±Ô∏è Mouse - Look</p>
<p>üî¢ 1-5 - Select Block</p>
<p>üëÜ Click - Place/Break</p>
<p>‚éµ Space - Jump</p>
</div>
<div id="crosshair"></div>
<div id="mode-indicator">üé¨ AUTO-CAM MODE<br/><small>Click to play</small></div>
<div id="hotbar">
<div class="hotbar-slot selected">üü´</div>
<div class="hotbar-slot">üü©</div>
<div class="hotbar-slot">‚¨ú</div>
<div class="hotbar-slot">ü™®</div>
<div class="hotbar-slot">ü™µ</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    (function() {
        // Game state
        let isAutoMode = true;
        let autoTime = 0;
        const blocks = {};
        const CHUNK_SIZE = 32;
        const WORLD_HEIGHT = 20;
        let selectedSlot = 0;
        const blockTypes = ['dirt', 'grass', 'stone', 'cobble', 'wood'];
        const blockColors = {
            dirt: 0x8B4513,
            grass: 0x228B22,
            stone: 0x808080,
            cobble: 0x696969,
            wood: 0x8B4513,
            leaves: 0x228B22,
            bedrock: 0x1a1a1a
        };

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(CHUNK_SIZE/2, 30, CHUNK_SIZE/2);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Block geometry (reusable)
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = {};
        for (let type in blockColors) {
            materials[type] = new THREE.MeshLambertMaterial({ color: blockColors[type] });
        }

        // Create instanced meshes for performance
        const instancedMeshes = {};
        const maxInstances = 50000;
        
        function getBlockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        // Terrain generation with Perlin-like noise
        function noise2D(x, z) {
            const X = Math.floor(x) & 255;
            const Z = Math.floor(z) & 255;
            return (Math.sin(X * 0.1 + Z * 0.15) * 0.5 + 
                    Math.cos(X * 0.08 - Z * 0.12) * 0.3 +
                    Math.sin((X + Z) * 0.05) * 0.2) * 0.5 + 0.5;
        }

        function getHeight(x, z) {
            const scale1 = 0.05;
            const scale2 = 0.1;
            const n1 = noise2D(x * scale1, z * scale1);
            const n2 = noise2D(x * scale2 + 100, z * scale2 + 100) * 0.5;
            return Math.floor((n1 + n2) * 8) + 5;
        }

        // Generate world
        function generateWorld() {
            const blockData = [];
            
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const height = getHeight(x, z);
                    
                    for (let y = 0; y <= height; y++) {
                        let type;
                        if (y === 0) type = 'bedrock';
                        else if (y === height) type = 'grass';
                        else if (y > height - 3) type = 'dirt';
                        else type = 'stone';
                        
                        blocks[getBlockKey(x, y, z)] = type;
                        blockData.push({ x, y, z, type });
                    }
                    
                    // Add trees randomly
                    if (height > 6 && Math.random() < 0.02) {
                        const treeHeight = 4 + Math.floor(Math.random() * 3);
                        for (let ty = 1; ty <= treeHeight; ty++) {
                            blocks[getBlockKey(x, height + ty, z)] = 'wood';
                            blockData.push({ x, y: height + ty, z, type: 'wood' });
                        }
                        // Leaves
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = treeHeight - 1; ly <= treeHeight + 2; ly++) {
                                    if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - treeHeight) < 5) {
                                        const key = getBlockKey(x + lx, height + ly, z + lz);
                                        if (!blocks[key]) {
                                            blocks[key] = 'leaves';
                                            blockData.push({ x: x + lx, y: height + ly, z: z + lz, type: 'leaves' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create instanced meshes
            const typeGroups = {};
            blockData.forEach(b => {
                if (!typeGroups[b.type]) typeGroups[b.type] = [];
                typeGroups[b.type].push(b);
            });
            
            for (let type in typeGroups) {
                const group = typeGroups[type];
                const mesh = new THREE.InstancedMesh(blockGeometry, materials[type], group.length);
                const matrix = new THREE.Matrix4();
                
                group.forEach((b, i) => {
                    matrix.setPosition(b.x, b.y, b.z);
                    mesh.setMatrixAt(i, matrix);
                });
                
                mesh.instanceMatrix.needsUpdate = true;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                instancedMeshes[type] = mesh;
            }
        }

        // Player physics
        const player = {
            position: new THREE.Vector3(CHUNK_SIZE/2, 20, CHUNK_SIZE/2),
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: false,
            yaw: 0,
            pitch: 0
        };

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            // Number keys for hotbar
            if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                selectedSlot = parseInt(e.code.replace('Digit', '')) - 1;
                updateHotbar();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        function updateHotbar() {
            document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
                slot.classList.toggle('selected', i === selectedSlot);
            });
        }

        // Mouse look
        let isLocked = false;
        document.addEventListener('click', () => {
            if (!isLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === renderer.domElement;
            if (isLocked) {
                isAutoMode = false;
                document.getElementById('mode-indicator').innerHTML = 'üéÆ PLAYER MODE<br><small>ESC to exit</small>';
            } else {
                isAutoMode = true;
                document.getElementById('mode-indicator').innerHTML = 'üé¨ AUTO-CAM MODE<br><small>Click to play</small>';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isLocked) {
                player.yaw -= e.movementX * 0.002;
                player.pitch -= e.movementY * 0.002;
                player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
            }
        });

        // Game loop
        function update(delta) {
            if (isAutoMode) {
                // Auto camera mode - fly around the world
                autoTime += delta * 0.3;
                const radius = 40;
                const height = 25 + Math.sin(autoTime * 0.5) * 10;
                camera.position.x = CHUNK_SIZE/2 + Math.cos(autoTime) * radius;
                camera.position.z = CHUNK_SIZE/2 + Math.sin(autoTime) * radius;
                camera.position.y = height;
                camera.lookAt(CHUNK_SIZE/2, 10, CHUNK_SIZE/2);
            } else {
                // Player control mode
                const moveSpeed = 0.15;
                const direction = new THREE.Vector3();
                
                if (keys['KeyW']) direction.z -= 1;
                if (keys['KeyS']) direction.z += 1;
                if (keys['KeyA']) direction.x -= 1;
                if (keys['KeyD']) direction.x += 1;
                
                direction.normalize();
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.yaw);
                
                player.position.x += direction.x * moveSpeed;
                player.position.z += direction.z * moveSpeed;
                
                // Gravity and jumping
                player.velocity.y -= 0.02;
                if (keys['Space'] && player.onGround) {
                    player.velocity.y = 0.3;
                    player.onGround = false;
                }
                
                player.position.y += player.velocity.y;
                
                // Simple ground collision
                const groundHeight = getHeight(Math.floor(player.position.x), Math.floor(player.position.z)) + 2;
                if (player.position.y < groundHeight) {
                    player.position.y = groundHeight;
                    player.velocity.y = 0;
                    player.onGround = true;
                }
                
                // Update camera
                camera.position.copy(player.position);
                camera.rotation.order = 'YXZ';
                camera.rotation.y = player.yaw;
                camera.rotation.x = player.pitch;
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 16;
            lastTime = time;
            
            update(delta);
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        generateWorld();
        document.getElementById('loading').style.display = 'none';
        animate(0);
    })();
    </script>
</body>
</html>