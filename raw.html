<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Minecraft 3D Simulator</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        canvas { display: block; }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }
        
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            z-index: 100;
        }
        
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.7);
            border: 3px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .hotbar-slot.active {
            border-color: #fff;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            mix-blend-mode: difference;
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        #title-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            animation: fadeOut 3s ease-out 2s forwards;
        }
        
        #title-overlay h1 {
            font-size: 48px;
            color: #fff;
            text-shadow: 4px 4px 0 #3f3f3f, -2px -2px 0 #000;
            letter-spacing: 4px;
        }
        
        #title-overlay p {
            font-size: 18px;
            color: #ffff00;
            text-shadow: 2px 2px 0 #000;
            margin-top: 10px;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; pointer-events: none; }
        }
        
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="hud">
<div>‚õèÔ∏è Minecraft Simulator</div>
<div id="coords">X: 0 Y: 64 Z: 0</div>
<div id="time-display">‚òÄÔ∏è Day</div>
</div>
<div id="hotbar">
<div class="hotbar-slot active">üü´</div>
<div class="hotbar-slot">üü©</div>
<div class="hotbar-slot">‚¨ú</div>
<div class="hotbar-slot">ü™®</div>
<div class="hotbar-slot">ü™µ</div>
<div class="hotbar-slot">üå≥</div>
<div class="hotbar-slot">üíé</div>
<div class="hotbar-slot">üî•</div>
<div class="hotbar-slot">üíß</div>
</div>
<div id="crosshair"></div>
<div id="title-overlay">
<h1>MINECRAFT</h1>
<p>üéÆ Auto-Exploring World...</p>
</div>
<div id="mode-indicator">üéÆ CLICK TO PLAY - WASD + Mouse</div>
<div id="controls-help" style="position:absolute;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#fff;padding:10px 20px;border-radius:5px;font-size:12px;z-index:100;text-align:center;">W/A/S/D: Move | Mouse: Look | Space: Jump | Shift: Descend</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/simplex-noise@2.4.0/simplex-noise.js"></script>
<script>
        // Minecraft 3D Simulator - Vanilla Edition
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        // Simplex noise for terrain
        const simplex = new SimplexNoise();
        
        // Block textures (procedural)
        function createBlockTexture(baseColor, variation = 0.1) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);
            
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    const noise = (Math.random() - 0.5) * variation * 255;
                    const pr = Math.max(0, Math.min(255, r + noise));
                    const pg = Math.max(0, Math.min(255, g + noise));
                    const pb = Math.max(0, Math.min(255, b + noise));
                    ctx.fillStyle = `rgb(${pr},${pg},${pb})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Block materials
        const materials = {
            grass_top: new THREE.MeshLambertMaterial({ map: createBlockTexture('#5D8C3D', 0.15) }),
            grass_side: new THREE.MeshLambertMaterial({ map: createBlockTexture('#8B6914', 0.1) }),
            dirt: new THREE.MeshLambertMaterial({ map: createBlockTexture('#8B6914', 0.12) }),
            stone: new THREE.MeshLambertMaterial({ map: createBlockTexture('#808080', 0.15) }),
            water: new THREE.MeshLambertMaterial({ color: 0x3399ff, transparent: true, opacity: 0.7 }),
            wood: new THREE.MeshLambertMaterial({ map: createBlockTexture('#6B4423', 0.1) }),
            leaves: new THREE.MeshLambertMaterial({ map: createBlockTexture('#228B22', 0.2), transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ map: createBlockTexture('#C2B280', 0.08) }),
            bedrock: new THREE.MeshLambertMaterial({ map: createBlockTexture('#1a1a1a', 0.2) })
        };
        
        // Grass block with different top/sides
        const grassMaterials = [
            materials.grass_side, materials.grass_side,
            materials.grass_top, materials.dirt,
            materials.grass_side, materials.grass_side
        ];
        
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        const blocks = [];
        
        // World generation
        const WORLD_SIZE = 32;
        const WATER_LEVEL = 62;
        
        function getHeight(x, z) {
            const scale1 = 0.05;
            const scale2 = 0.1;
            const noise1 = simplex.noise2D(x * scale1, z * scale1) * 15;
            const noise2 = simplex.noise2D(x * scale2, z * scale2) * 5;
            return Math.floor(60 + noise1 + noise2);
        }
        
        function generateWorld() {
            for (let x = -WORLD_SIZE; x < WORLD_SIZE; x++) {
                for (let z = -WORLD_SIZE; z < WORLD_SIZE; z++) {
                    const height = getHeight(x, z);
                    
                    // Bedrock
                    const bedrock = new THREE.Mesh(blockGeometry, materials.bedrock);
                    bedrock.position.set(x, 0, z);
                    scene.add(bedrock);
                    
                    // Stone layers
                    for (let y = 1; y < height - 4; y++) {
                        if (Math.random() > 0.7) continue; // Skip some for performance
                        const stone = new THREE.Mesh(blockGeometry, materials.stone);
                        stone.position.set(x, y, z);
                        scene.add(stone);
                    }
                    
                    // Dirt layers
                    for (let y = Math.max(1, height - 4); y < height; y++) {
                        const dirt = new THREE.Mesh(blockGeometry, materials.dirt);
                        dirt.position.set(x, y, z);
                        scene.add(dirt);
                    }
                    
                    // Top layer
                    if (height > WATER_LEVEL) {
                        const grass = new THREE.Mesh(blockGeometry, grassMaterials);
                        grass.position.set(x, height, z);
                        scene.add(grass);
                        blocks.push(grass);
                        
                        // Trees
                        if (Math.random() < 0.02 && height > WATER_LEVEL + 2) {
                            generateTree(x, height + 1, z);
                        }
                    } else if (height === WATER_LEVEL) {
                        const sand = new THREE.Mesh(blockGeometry, materials.sand);
                        sand.position.set(x, height, z);
                        scene.add(sand);
                    } else {
                        const sand = new THREE.Mesh(blockGeometry, materials.sand);
                        sand.position.set(x, height, z);
                        scene.add(sand);
                    }
                    
                    // Water
                    if (height < WATER_LEVEL) {
                        const water = new THREE.Mesh(blockGeometry, materials.water);
                        water.position.set(x, WATER_LEVEL, z);
                        scene.add(water);
                    }
                }
            }
        }
        
        function generateTree(x, y, z) {
            // Trunk
            for (let i = 0; i < 5; i++) {
                const trunk = new THREE.Mesh(blockGeometry, materials.wood);
                trunk.position.set(x, y + i, z);
                scene.add(trunk);
            }
            
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 3; ly <= 5; ly++) {
                        if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly < 5) continue;
                        if (ly === 5 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue;
                        if (lx === 0 && lz === 0 && ly < 5) continue;
                        
                        const leaf = new THREE.Mesh(blockGeometry, materials.leaves);
                        leaf.position.set(x + lx, y + ly, z + lz);
                        scene.add(leaf);
                    }
                }
            }
        }
        
        generateWorld();
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffcc, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        scene.add(sunLight);
        
        // Fog for atmosphere
        scene.fog = new THREE.Fog(0x87CEEB, 30, 80);
        
        // Camera setup
        camera.position.set(0, 75, 20);
        camera.lookAt(0, 65, 0);
        
        // Player controls
        let playerPos = { x: 0, y: 75, z: 20 };
        let playerVel = { x: 0, y: 0, z: 0 };
        let yaw = 0;
        let pitch = 0;
        const moveSpeed = 0.15;
        const jumpForce = 0.3;
        const gravity = 0.01;
        let isJumping = false;
        let isPointerLocked = false;
        
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (key === ' ') keys.space = true;
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (key === ' ') keys.space = false;
        });
        
        document.getElementById('game-container').addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('mode-indicator').textContent = isPointerLocked ? 'üéÆ PLAYING - ESC to exit' : 'üéÆ CLICK TO PLAY - WASD + Mouse';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        });
        
        function updatePlayer() {
            // Movement direction based on yaw
            let moveX = 0, moveZ = 0;
            
            if (keys.w) { moveX += Math.sin(yaw); moveZ += Math.cos(yaw); }
            if (keys.s) { moveX -= Math.sin(yaw); moveZ -= Math.cos(yaw); }
            if (keys.a) { moveX += Math.cos(yaw); moveZ -= Math.sin(yaw); }
            if (keys.d) { moveX -= Math.cos(yaw); moveZ += Math.sin(yaw); }
            
            // Normalize diagonal movement
            const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (len > 0) {
                moveX = (moveX / len) * moveSpeed;
                moveZ = (moveZ / len) * moveSpeed;
            }
            
            playerPos.x += moveX;
            playerPos.z += moveZ;
            
            // Vertical movement
            if (keys.space) playerVel.y = jumpForce;
            if (keys.shift) playerVel.y = -jumpForce;
            
            playerVel.y -= gravity;
            playerPos.y += playerVel.y;
            
            // Ground collision (simple)
            const groundHeight = getHeight(Math.floor(playerPos.x), Math.floor(playerPos.z)) + 3;
            if (playerPos.y < groundHeight) {
                playerPos.y = groundHeight;
                playerVel.y = 0;
            }
            if (playerPos.y > 120) playerPos.y = 120;
            
            // Update camera
            camera.position.set(playerPos.x, playerPos.y, playerPos.z);
            
            // Camera look direction
            const lookX = playerPos.x + Math.sin(yaw) * Math.cos(pitch);
            const lookY = playerPos.y + Math.sin(pitch);
            const lookZ = playerPos.z + Math.cos(yaw) * Math.cos(pitch);
            camera.lookAt(lookX, lookY, lookZ);
        }
        
        // Day/night cycle
        let dayTime = 0;
        const DAY_LENGTH = 120; // seconds
        
        function updateDayNight() {
            dayTime += 0.016;
            const cycle = (dayTime % DAY_LENGTH) / DAY_LENGTH;
            const sunAngle = cycle * Math.PI * 2;
            
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 100;
            
            const isDay = Math.sin(sunAngle) > -0.2;
            const brightness = Math.max(0.2, Math.sin(sunAngle) * 0.5 + 0.5);
            
            ambientLight.intensity = brightness * 0.8;
            sunLight.intensity = brightness;
            
            const skyColor = isDay ? 
                new THREE.Color(0.53 * brightness, 0.81 * brightness, 0.92 * brightness) :
                new THREE.Color(0.05, 0.05, 0.15);
            
            renderer.setClearColor(skyColor);
            scene.fog.color = skyColor;
            
            document.getElementById('time-display').textContent = isDay ? '‚òÄÔ∏è Day' : 'üåô Night';
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Player movement update
            updatePlayer();
            
            // Update HUD
            document.getElementById('coords').textContent = 
                `X: ${Math.floor(playerPos.x)} Y: ${Math.floor(playerPos.y)} Z: ${Math.floor(playerPos.z)}`;
            
            updateDayNight();
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Chat integration for future interactivity
        try {
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const pathBase = location.pathname.includes('/twitch_plays_code') ? '/twitch_plays_code' : 
                           location.pathname.includes('/tpc') ? '/twitch_plays_code' : '';
            const chatWs = new WebSocket(`${wsProtocol}//${location.host}${pathBase}/ws/chat`);
            
            chatWs.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'chat_message') {
                    console.log(`üí¨ ${msg.username}: ${msg.message}`);
                }
            };
        } catch(e) {
            console.log('Chat WebSocket not available');
        }
    </script>
</body>
</html>