<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Voxel World - Twitch Plays</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 100;
            text-align: center;
        }
        .key {
            display: inline-block;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 5px 12px;
            margin: 2px;
            min-width: 30px;
            text-align: center;
        }
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #ffcc00;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #ffcc00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #inventory {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
            border: 2px solid #555;
        }
        .inv-slot {
            width: 50px;
            height: 50px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inv-slot:hover, .inv-slot.selected {
            border-color: #fff;
            transform: scale(1.1);
        }
        .inv-slot.selected {
            border-color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        .block-preview {
            width: 35px;
            height: 35px;
            border-radius: 3px;
        }
        #action-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 101;
        }
        #cinema-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            flex-direction: column;
        }
        #cinema-canvas {
            border: 8px solid #333;
            box-shadow: 0 0 50px rgba(255,200,0,0.5);
            image-rendering: pixelated;
        }
        #cinema-text {
            color: #FFD700;
            font-size: 24px;
            margin-top: 20px;
            text-align: center;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #FFD700;
        }
        #cinema-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 30px;
            cursor: pointer;
        }
        #screen-prompt {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 100;
            display: none;
            border: 2px solid #FFD700;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
<div id="game-container">
<div id="hud">
<div>üéÆ VOXEL WORLD</div>
<div>Position: <span id="pos">0, 0, 0</span></div>
<div>Blocks: <span id="block-count">0</span></div>
<div>Characters: <span id="char-count">21</span> üßë‚Äçüåæüêëüê∑üßôüçÑ</div>
<div>Buildings: <span id="building-count">5</span> üè†üçî‚õ≤üè∞üéâ</div>
</div>
<div id="mode-indicator">ü§ñ AUTO-EXPLORE MODE</div>
<div id="crosshair"></div>
<div id="inventory">
<div class="inv-slot selected" data-block="grass"><div class="block-preview" style="background: #4CAF50;"></div></div>
<div class="inv-slot" data-block="dirt"><div class="block-preview" style="background: #8B4513;"></div></div>
<div class="inv-slot" data-block="stone"><div class="block-preview" style="background: #808080;"></div></div>
<div class="inv-slot" data-block="wood"><div class="block-preview" style="background: #8B5A2B;"></div></div>
<div class="inv-slot" data-block="sand"><div class="block-preview" style="background: #F4D03F;"></div></div>
<div class="inv-slot" data-block="snow"><div class="block-preview" style="background: #FFFFFF;"></div></div>
<div class="inv-slot" data-block="gold"><div class="block-preview" style="background: #FFD700;"></div></div>
</div>
<div id="action-hint"></div>
<div id="screen-prompt">üé¨ Press F to watch the movie!</div>
<div id="cinema-overlay">
<span id="cinema-close">‚úï ESC to close</span>
<canvas height="360" id="cinema-canvas" width="640"></canvas>
<div id="cinema-text">üé¨ MARIO SAVES THE PRINCESS üé¨</div>
</div>
<div id="controls-hint">
<span class="key">‚Üë</span> Forward
            <span class="key">‚Üì</span> Back
            <span class="key">‚Üê</span> Left
            <span class="key">‚Üí</span> Right
            <span class="key">SPACE</span> Up
            <span class="key">SHIFT</span> Down
            <span class="key">CLICK</span> Mine
            <span class="key">M</span> Place
        </div>
</div>
<script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Block materials (Minecraft-style colors)
        const materials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8B5A2B }),
            leaves: new THREE.MeshLambertMaterial({ color: 0x228B22, transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ color: 0xF4D03F }),
            water: new THREE.MeshLambertMaterial({ color: 0x3498DB, transparent: true, opacity: 0.7 }),
            snow: new THREE.MeshLambertMaterial({ color: 0xFFFFFF }),
            coal: new THREE.MeshLambertMaterial({ color: 0x2C2C2C }),
            gold: new THREE.MeshLambertMaterial({ color: 0xFFD700 }),
            brick: new THREE.MeshLambertMaterial({ color: 0xB22222 }),
            glass: new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 }),
            roof: new THREE.MeshLambertMaterial({ color: 0x8B0000 }),
            sign: new THREE.MeshLambertMaterial({ color: 0xFFFFE0 }),
            fountain: new THREE.MeshLambertMaterial({ color: 0xD3D3D3 }),
        };

        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let blockCount = 0;

        // Simple noise function for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 + 
                   Math.sin(x * 0.05 + 1) * Math.cos(z * 0.07) * 5 +
                   Math.sin(x * 0.02) * Math.sin(z * 0.02) * 8;
        }

        // Generate terrain
        const worldSize = 40;
        const blocks = [];

        function createBlock(x, y, z, material) {
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.push(block);
            blockCount++;
        }

        // Generate world
        for (let x = -worldSize; x < worldSize; x++) {
            for (let z = -worldSize; z < worldSize; z++) {
                const height = Math.floor(noise(x, z)) + 5;
                
                // Bedrock/stone layers
                for (let y = 0; y < height - 3; y++) {
                    if (Math.random() < 0.02) {
                        createBlock(x, y, z, materials.gold);
                    } else if (Math.random() < 0.05) {
                        createBlock(x, y, z, materials.coal);
                    } else {
                        createBlock(x, y, z, materials.stone);
                    }
                }
                
                // Dirt layers
                for (let y = Math.max(0, height - 3); y < height; y++) {
                    createBlock(x, y, z, materials.dirt);
                }
                
                // Surface layer
                if (height > 8) {
                    createBlock(x, height, z, materials.snow);
                } else if (height < 3) {
                    createBlock(x, height, z, materials.sand);
                    // Water
                    for (let y = height + 1; y <= 3; y++) {
                        createBlock(x, y, z, materials.water);
                    }
                } else {
                    createBlock(x, height, z, materials.grass);
                    
                    // Trees
                    if (Math.random() < 0.02 && height > 3) {
                        const treeHeight = 4 + Math.floor(Math.random() * 3);
                        for (let ty = 1; ty <= treeHeight; ty++) {
                            createBlock(x, height + ty, z, materials.wood);
                        }
                        // Leaves
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = treeHeight - 1; ly <= treeHeight + 2; ly++) {
                                    if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - treeHeight) < 4) {
                                        if (lx !== 0 || lz !== 0 || ly > treeHeight) {
                                            createBlock(x + lx, height + ly, z + lz, materials.leaves);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        document.getElementById('block-count').textContent = blockCount;

        // === RESTAURANTS ===
        function createRestaurant(baseX, baseZ, name, signColor) {
            const terrainY = Math.floor(noise(baseX, baseZ)) + 6;
            
            // Foundation and floor
            for (let x = -3; x <= 3; x++) {
                for (let z = -3; z <= 3; z++) {
                    createBlock(baseX + x, terrainY, baseZ + z, materials.stone);
                }
            }
            
            // Walls
            for (let y = 1; y <= 4; y++) {
                for (let x = -3; x <= 3; x++) {
                    // Front and back walls
                    if (!(x >= -1 && x <= 1 && y <= 2)) { // Door opening
                        createBlock(baseX + x, terrainY + y, baseZ - 3, materials.brick);
                    }
                    createBlock(baseX + x, terrainY + y, baseZ + 3, materials.brick);
                }
                for (let z = -2; z <= 2; z++) {
                    // Side walls with windows
                    if (y === 2 || y === 3) {
                        createBlock(baseX - 3, terrainY + y, baseZ + z, materials.glass);
                        createBlock(baseX + 3, terrainY + y, baseZ + z, materials.glass);
                    } else {
                        createBlock(baseX - 3, terrainY + y, baseZ + z, materials.brick);
                        createBlock(baseX + 3, terrainY + y, baseZ + z, materials.brick);
                    }
                }
            }
            
            // Roof
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    createBlock(baseX + x, terrainY + 5, baseZ + z, materials.roof);
                }
            }
            
            // Sign above door
            const signMat = new THREE.MeshBasicMaterial({ color: signColor });
            const signGeo = new THREE.BoxGeometry(5, 1.5, 0.2);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(baseX, terrainY + 5.5, baseZ - 3.5);
            scene.add(signMesh);
            
            // Sign text using canvas texture
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 256;
            textCanvas.height = 64;
            const textCtx = textCanvas.getContext('2d');
            textCtx.fillStyle = signColor === 0xFFD700 ? '#8B0000' : '#FFFFFF';
            textCtx.fillRect(0, 0, 256, 64);
            textCtx.fillStyle = signColor === 0xFFD700 ? '#FFD700' : '#000000';
            textCtx.font = 'bold 28px Arial';
            textCtx.textAlign = 'center';
            textCtx.fillText(name, 128, 42);
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMat = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(5, 1.2), textMat);
            textMesh.position.set(baseX, terrainY + 5.5, baseZ - 3.6);
            scene.add(textMesh);
            
            // Tables inside
            for (let tx = -1; tx <= 1; tx += 2) {
                const table = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 1), materials.wood);
                table.position.set(baseX + tx, terrainY + 1.5, baseZ);
                scene.add(table);
                const tableLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), materials.wood);
                tableLeg.position.set(baseX + tx, terrainY + 1.2, baseZ);
                scene.add(tableLeg);
            }
        }
        
        // Create restaurants at different locations
        createRestaurant(20, 15, 'üçî BURGER HUT', 0xFFD700);
        createRestaurant(-25, 20, 'üçï PIZZA PALACE', 0xFF4500);
        createRestaurant(15, -25, 'üçú NOODLE HOUSE', 0x00FF00);
        
        // === MARIO'S CASTLE (Peach's Castle) ===
        function createMarioCastle() {
            const cx = 30, cz = -10;
            const baseY = Math.floor(noise(cx, cz)) + 6;
            
            // Castle materials
            const pinkWall = new THREE.MeshLambertMaterial({color: 0xFFB6C1});
            const redRoof = new THREE.MeshLambertMaterial({color: 0xCC0000});
            const blueRoof = new THREE.MeshLambertMaterial({color: 0x4169E1});
            const goldTrim = new THREE.MeshLambertMaterial({color: 0xFFD700});
            const whiteTrim = new THREE.MeshLambertMaterial({color: 0xFFFFF0});
            const stainedGlass = new THREE.MeshLambertMaterial({color: 0xFF69B4, transparent: true, opacity: 0.7});
            const darkWood = new THREE.MeshLambertMaterial({color: 0x4A2810});
            
            // Foundation platform
            for (let x = -8; x <= 8; x++) {
                for (let z = -8; z <= 8; z++) {
                    createBlock(cx + x, baseY, cz + z, materials.stone);
                    createBlock(cx + x, baseY - 1, cz + z, materials.stone);
                }
            }
            
            // Main castle body
            for (let y = 1; y <= 8; y++) {
                for (let x = -6; x <= 6; x++) {
                    for (let z = -6; z <= 6; z++) {
                        // Walls only (hollow inside)
                        if (Math.abs(x) >= 5 || Math.abs(z) >= 5) {
                            // Windows on upper floors
                            if (y >= 4 && y <= 6 && (x % 3 === 0 || z % 3 === 0) && Math.abs(x) < 6 && Math.abs(z) < 6) {
                                createBlock(cx + x, baseY + y, cz + z, stainedGlass);
                            } else {
                                createBlock(cx + x, baseY + y, cz + z, pinkWall);
                            }
                        }
                    }
                }
            }
            
            // Grand entrance (front)
            for (let x = -2; x <= 2; x++) {
                for (let y = 1; y <= 5; y++) {
                    // Create archway
                    if (y <= 3 && Math.abs(x) <= 1) {
                        // Door opening - remove blocks
                    } else if (y === 4 && Math.abs(x) <= 1) {
                        createBlock(cx + x, baseY + y, cz + 6, goldTrim);
                    } else {
                        createBlock(cx + x, baseY + y, cz + 6, whiteTrim);
                    }
                }
            }
            
            // Main roof (red)
            for (let y = 0; y <= 3; y++) {
                const size = 7 - y;
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        createBlock(cx + x, baseY + 9 + y, cz + z, redRoof);
                    }
                }
            }
            
            // Four corner towers
            const towerPositions = [[-7, -7], [7, -7], [-7, 7], [7, 7]];
            towerPositions.forEach(([tx, tz]) => {
                // Tower body
                for (let y = 1; y <= 12; y++) {
                    for (let x = -1; x <= 1; x++) {
                        for (let z = -1; z <= 1; z++) {
                            if (Math.abs(x) === 1 || Math.abs(z) === 1) {
                                createBlock(cx + tx + x, baseY + y, cz + tz + z, pinkWall);
                            }
                        }
                    }
                }
                // Tower windows
                for (let y = 6; y <= 10; y += 2) {
                    createBlock(cx + tx, baseY + y, cz + tz + 1, stainedGlass);
                    createBlock(cx + tx, baseY + y, cz + tz - 1, stainedGlass);
                }
                // Tower roof (cone shape with blue)
                for (let y = 0; y <= 4; y++) {
                    const rs = 2 - Math.floor(y / 2);
                    for (let x = -rs; x <= rs; x++) {
                        for (let z = -rs; z <= rs; z++) {
                            createBlock(cx + tx + x, baseY + 13 + y, cz + tz + z, blueRoof);
                        }
                    }
                }
                // Gold flag pole and flag
                createBlock(cx + tx, baseY + 18, cz + tz, goldTrim);
                createBlock(cx + tx, baseY + 19, cz + tz, goldTrim);
                // Red flag
                const flagGeo = new THREE.PlaneGeometry(1.5, 1);
                const flagMat = new THREE.MeshLambertMaterial({color: 0xFF0000, side: THREE.DoubleSide});
                const flag = new THREE.Mesh(flagGeo, flagMat);
                flag.position.set(cx + tx + 0.8, baseY + 19, cz + tz);
                scene.add(flag);
            });
            
            // Central tall tower
            for (let y = 1; y <= 15; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        if (Math.abs(x) >= 1 || Math.abs(z) >= 1) {
                            createBlock(cx + x, baseY + y, cz + z, whiteTrim);
                        }
                    }
                }
            }
            // Central tower dome
            for (let y = 0; y <= 5; y++) {
                const ds = 3 - Math.floor(y / 1.5);
                for (let x = -ds; x <= ds; x++) {
                    for (let z = -ds; z <= ds; z++) {
                        if (Math.abs(x) + Math.abs(z) <= ds + 1) {
                            createBlock(cx + x, baseY + 16 + y, cz + z, blueRoof);
                        }
                    }
                }
            }
            // Star on top
            const starGeo = new THREE.OctahedronGeometry(0.8);
            const starMat = new THREE.MeshBasicMaterial({color: 0xFFD700});
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(cx, baseY + 23, cz);
            star.name = 'castleStar';
            scene.add(star);
            
            // Stained glass window (large, front)
            const windowGeo = new THREE.CircleGeometry(2, 8);
            const windowMat = new THREE.MeshBasicMaterial({color: 0xFF69B4, transparent: true, opacity: 0.8, side: THREE.DoubleSide});
            const bigWindow = new THREE.Mesh(windowGeo, windowMat);
            bigWindow.position.set(cx, baseY + 6, cz + 6.1);
            scene.add(bigWindow);
            
            // Peach portrait above entrance
            const portraitCanvas = document.createElement('canvas');
            portraitCanvas.width = 128;
            portraitCanvas.height = 128;
            const pCtx = portraitCanvas.getContext('2d');
            pCtx.fillStyle = '#FFB6C1';
            pCtx.fillRect(0, 0, 128, 128);
            pCtx.fillStyle = '#FFD700';
            pCtx.beginPath();
            pCtx.arc(64, 50, 25, 0, Math.PI * 2);
            pCtx.fill();
            pCtx.fillStyle = '#FFDBAC';
            pCtx.beginPath();
            pCtx.arc(64, 60, 20, 0, Math.PI * 2);
            pCtx.fill();
            pCtx.fillStyle = '#FF69B4';
            pCtx.fillRect(44, 80, 40, 40);
            pCtx.fillStyle = '#000';
            pCtx.font = 'bold 14px Arial';
            pCtx.textAlign = 'center';
            pCtx.fillText('üë∏ PEACH', 64, 120);
            const portraitTex = new THREE.CanvasTexture(portraitCanvas);
            const portraitMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 3),
                new THREE.MeshBasicMaterial({map: portraitTex})
            );
            portraitMesh.position.set(cx, baseY + 10, cz + 6.2);
            scene.add(portraitMesh);
            
            // Castle sign
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 256;
            signCanvas.height = 64;
            const sCtx = signCanvas.getContext('2d');
            sCtx.fillStyle = '#FFD700';
            sCtx.fillRect(0, 0, 256, 64);
            sCtx.fillStyle = '#CC0000';
            sCtx.font = 'bold 24px Arial';
            sCtx.textAlign = 'center';
            sCtx.fillText('üè∞ PEACH\'S CASTLE üè∞', 128, 42);
            const signTex = new THREE.CanvasTexture(signCanvas);
            const signMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 2),
                new THREE.MeshBasicMaterial({map: signTex})
            );
            signMesh.position.set(cx, baseY + 14, cz + 8);
            scene.add(signMesh);
            
            // Garden path to castle
            for (let pz = 7; pz <= 15; pz++) {
                for (let px = -1; px <= 1; px++) {
                    createBlock(cx + px, baseY, cz + pz, materials.sand);
                }
            }
            
            // Decorative flowers around castle
            const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB];
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const radius = 10 + Math.random() * 3;
                const fx = cx + Math.cos(angle) * radius;
                const fz = cz + Math.sin(angle) * radius;
                const fy = Math.floor(noise(fx, fz)) + 6;
                const flowerGeo = new THREE.SphereGeometry(0.3, 6, 6);
                const flowerMat = new THREE.MeshLambertMaterial({color: flowerColors[i % 4]});
                const flower = new THREE.Mesh(flowerGeo, flowerMat);
                flower.position.set(fx, fy + 0.5, fz);
                scene.add(flower);
            }
            
            return {x: cx, z: cz, baseY: baseY};
        }
        
        const marioCastle = createMarioCastle();
        
        // === PARTY ZONE ===
        function createPartyZone() {
            const px = -8, pz = 8;
            const terrainY = Math.floor(noise(px, pz)) + 6;
            
            // Dance floor (colorful blocks)
            const danceColors = [0xFF0080, 0x00FFFF, 0xFFFF00, 0xFF00FF, 0x00FF00];
            for (let x = -3; x <= 3; x++) {
                for (let z = -3; z <= 3; z++) {
                    const colorMat = new THREE.MeshLambertMaterial({color: danceColors[(x+z+6) % 5]});
                    const tile = new THREE.Mesh(blockGeometry, colorMat);
                    tile.position.set(px + x, terrainY, pz + z);
                    tile.userData.isDanceFloor = true;
                    tile.userData.originalColor = danceColors[(x+z+6) % 5];
                    scene.add(tile);
                    blocks.push(tile);
                }
            }
            
            // DJ Booth
            const boothMat = new THREE.MeshLambertMaterial({color: 0x1a1a1a});
            for (let x = -1; x <= 1; x++) {
                createBlock(px + x, terrainY + 1, pz - 4, boothMat);
                createBlock(px + x, terrainY + 2, pz - 4, boothMat);
            }
            
            // DJ turntables
            const turntable1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), new THREE.MeshBasicMaterial({color: 0x333333}));
            turntable1.position.set(px - 0.5, terrainY + 2.55, pz - 4);
            turntable1.name = 'turntable1';
            scene.add(turntable1);
            
            const turntable2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), new THREE.MeshBasicMaterial({color: 0x333333}));
            turntable2.position.set(px + 0.5, terrainY + 2.55, pz - 4);
            turntable2.name = 'turntable2';
            scene.add(turntable2);
            
            // Disco ball
            const discoBallGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const discoBallMat = new THREE.MeshBasicMaterial({color: 0xC0C0C0});
            const discoBall = new THREE.Mesh(discoBallGeo, discoBallMat);
            discoBall.position.set(px, terrainY + 8, pz);
            discoBall.name = 'discoBall';
            scene.add(discoBall);
            
            // Disco ball string
            const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 3, 8);
            const stringMat = new THREE.MeshBasicMaterial({color: 0x888888});
            const string = new THREE.Mesh(stringGeo, stringMat);
            string.position.set(px, terrainY + 9.5, pz);
            scene.add(string);
            
            // Party lights (poles with glowing tops)
            const lightPositions = [[-4, -4], [4, -4], [-4, 4], [4, 4]];
            const partyLights = [];
            lightPositions.forEach(([lx, lz], i) => {
                // Pole
                for (let y = 1; y <= 5; y++) {
                    createBlock(px + lx, terrainY + y, pz + lz, materials.stone);
                }
                // Light orb
                const lightOrb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 8, 8),
                    new THREE.MeshBasicMaterial({color: danceColors[i]})
                );
                lightOrb.position.set(px + lx, terrainY + 6, pz + lz);
                lightOrb.userData.baseColor = danceColors[i];
                lightOrb.userData.index = i;
                scene.add(lightOrb);
                partyLights.push(lightOrb);
            });
            
            // Party banner
            const bannerCanvas = document.createElement('canvas');
            bannerCanvas.width = 256;
            bannerCanvas.height = 64;
            const bCtx = bannerCanvas.getContext('2d');
            bCtx.fillStyle = '#FF1493';
            bCtx.fillRect(0, 0, 256, 64);
            bCtx.fillStyle = '#FFD700';
            bCtx.font = 'bold 28px Arial';
            bCtx.textAlign = 'center';
            bCtx.fillText('üéâ VILLAGE PARTY! üéâ', 128, 42);
            const bannerTex = new THREE.CanvasTexture(bannerCanvas);
            const bannerMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 1.5),
                new THREE.MeshBasicMaterial({map: bannerTex, side: THREE.DoubleSide})
            );
            bannerMesh.position.set(px, terrainY + 7, pz + 5);
            scene.add(bannerMesh);
            
            // Confetti particles
            const confettiParticles = [];
            const confettiColors = [0xFF0080, 0x00FFFF, 0xFFFF00, 0xFF00FF, 0x00FF00, 0xFF6600];
            for (let i = 0; i < 50; i++) {
                const confetti = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.02),
                    new THREE.MeshBasicMaterial({color: confettiColors[i % confettiColors.length]})
                );
                confetti.position.set(
                    px + (Math.random() - 0.5) * 10,
                    terrainY + 5 + Math.random() * 5,
                    pz + (Math.random() - 0.5) * 10
                );
                confetti.userData = {
                    vx: (Math.random() - 0.5) * 0.05,
                    vy: -0.02 - Math.random() * 0.03,
                    vz: (Math.random() - 0.5) * 0.05,
                    rotSpeed: (Math.random() - 0.5) * 0.2,
                    baseY: terrainY
                };
                scene.add(confetti);
                confettiParticles.push(confetti);
            }
            
            // Music notes floating
            const musicNotes = [];
            const noteSymbols = ['‚ô™', '‚ô´', '‚ô¨'];
            for (let i = 0; i < 8; i++) {
                const noteCanvas = document.createElement('canvas');
                noteCanvas.width = 64;
                noteCanvas.height = 64;
                const nCtx = noteCanvas.getContext('2d');
                nCtx.fillStyle = ['#FF69B4', '#00FFFF', '#FFD700'][i % 3];
                nCtx.font = '48px Arial';
                nCtx.textAlign = 'center';
                nCtx.fillText(noteSymbols[i % 3], 32, 48);
                const noteTex = new THREE.CanvasTexture(noteCanvas);
                const noteMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.8),
                    new THREE.MeshBasicMaterial({map: noteTex, transparent: true, side: THREE.DoubleSide})
                );
                noteMesh.position.set(
                    px + (Math.random() - 0.5) * 6,
                    terrainY + 3 + Math.random() * 3,
                    pz + (Math.random() - 0.5) * 6
                );
                noteMesh.userData = {
                    baseX: noteMesh.position.x,
                    baseY: noteMesh.position.y,
                    baseZ: noteMesh.position.z,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                };
                scene.add(noteMesh);
                musicNotes.push(noteMesh);
            }
            
            return {
                x: px, z: pz, baseY: terrainY,
                lights: partyLights,
                confetti: confettiParticles,
                notes: musicNotes,
                discoBall: discoBall
            };
        }
        
        const partyZone = createPartyZone();
        
        function updatePartyZone(time) {
            // Animate disco ball
            if (partyZone.discoBall) {
                partyZone.discoBall.rotation.y += 0.05;
            }
            
            // Pulse party lights
            partyZone.lights.forEach((light, i) => {
                const pulse = Math.sin(time * 5 + i * 1.5) * 0.5 + 0.5;
                const hue = (time * 0.1 + i * 0.25) % 1;
                light.material.color.setHSL(hue, 1, 0.3 + pulse * 0.4);
                light.scale.setScalar(0.8 + pulse * 0.4);
            });
            
            // Animate confetti
            partyZone.confetti.forEach(c => {
                c.position.x += c.userData.vx;
                c.position.y += c.userData.vy;
                c.position.z += c.userData.vz;
                c.rotation.x += c.userData.rotSpeed;
                c.rotation.z += c.userData.rotSpeed * 0.7;
                
                // Reset when below ground
                if (c.position.y < c.userData.baseY + 1) {
                    c.position.y = c.userData.baseY + 10;
                    c.position.x = partyZone.x + (Math.random() - 0.5) * 10;
                    c.position.z = partyZone.z + (Math.random() - 0.5) * 10;
                }
            });
            
            // Float music notes
            partyZone.notes.forEach(note => {
                const d = note.userData;
                note.position.x = d.baseX + Math.sin(time * d.speed + d.phase) * 1.5;
                note.position.y = d.baseY + Math.sin(time * d.speed * 0.7 + d.phase) * 0.5 + Math.sin(time * 2) * 0.3;
                note.position.z = d.baseZ + Math.cos(time * d.speed + d.phase) * 1.5;
                note.rotation.y = time;
                note.material.opacity = 0.7 + Math.sin(time * 3 + d.phase) * 0.3;
            });
            
            // Animate turntables
            const t1 = scene.getObjectByName('turntable1');
            const t2 = scene.getObjectByName('turntable2');
            if (t1) t1.rotation.y += 0.1;
            if (t2) t2.rotation.y -= 0.1;
            
            // Pulse dance floor colors
            blocks.forEach(block => {
                if (block.userData && block.userData.isDanceFloor) {
                    const hue = (time * 0.2 + block.position.x * 0.1 + block.position.z * 0.1) % 1;
                    block.material.color.setHSL(hue, 1, 0.5);
                }
            });
        }

        // === CENTRAL FOUNTAIN ===
        function createFountain() {
            const fx = 0, fz = 0;
            const terrainY = Math.floor(noise(fx, fz)) + 6;
            
            // Base pool (octagonal shape approximation)
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    if (Math.abs(x) + Math.abs(z) <= 6) {
                        createBlock(fx + x, terrainY, fz + z, materials.fountain);
                        // Water inside
                        if (Math.abs(x) <= 3 && Math.abs(z) <= 3 && Math.abs(x) + Math.abs(z) <= 5) {
                            createBlock(fx + x, terrainY + 0.3, fz + z, materials.water);
                        }
                    }
                }
            }
            
            // Rim
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    if (Math.abs(x) + Math.abs(z) === 6 || (Math.abs(x) === 4 && Math.abs(z) <= 2) || (Math.abs(z) === 4 && Math.abs(x) <= 2)) {
                        createBlock(fx + x, terrainY + 1, fz + z, materials.fountain);
                    }
                }
            }
            
            // Central pillar
            for (let y = 1; y <= 4; y++) {
                createBlock(fx, terrainY + y, fz, materials.fountain);
            }
            
            // Top basin
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    createBlock(fx + x, terrainY + 5, fz + z, materials.fountain);
                }
            }
            createBlock(fx, terrainY + 5.3, fz, materials.water);
            
            // Animated water particles
            const waterParticles = [];
            const particleGeo = new THREE.SphereGeometry(0.1, 4, 4);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.8 });
            
            for (let i = 0; i < 30; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.userData = {
                    angle: (i / 30) * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.02,
                    height: Math.random(),
                    radius: 0.5 + Math.random() * 1.5
                };
                particle.position.set(fx, terrainY + 5, fz);
                scene.add(particle);
                waterParticles.push(particle);
            }
            
            return { particles: waterParticles, baseY: terrainY + 5, x: fx, z: fz };
        }
        
        const fountain = createFountain();
        
        function updateFountain(time) {
            fountain.particles.forEach(p => {
                const d = p.userData;
                d.height += d.speed;
                if (d.height > 1) d.height = 0;
                
                const arcHeight = Math.sin(d.height * Math.PI) * 3;
                const currentRadius = d.radius * d.height;
                
                p.position.x = fountain.x + Math.cos(d.angle + time) * currentRadius;
                p.position.z = fountain.z + Math.sin(d.angle + time) * currentRadius;
                p.position.y = fountain.baseY + arcHeight;
                
                p.material.opacity = 0.8 - d.height * 0.6;
            });
        }

        // === VOXEL CHARACTERS ===
        const characters = [];
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Character colors
        const skinColors = [0xFFDBB4, 0xE8B89D, 0xC68642, 0x8D5524];
        const shirtColors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFECE48, 0xAA96DA];
        const pantsColors = [0x2C3E50, 0x8B4513, 0x34495E, 0x1E3D59];

        function createVoxelCharacter(type, x, z) {
            const group = new THREE.Group();
            const terrainY = Math.floor(noise(x, z)) + 6;
            
            if (type === 'villager') {
                const skin = skinColors[Math.floor(Math.random() * skinColors.length)];
                const shirt = shirtColors[Math.floor(Math.random() * shirtColors.length)];
                const pants = pantsColors[Math.floor(Math.random() * pantsColors.length)];
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({color: skin}));
                head.position.y = 1.5;
                group.add(head);
                
                // Eyes
                const eyeMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
                leftEye.position.set(-0.12, 1.55, 0.25);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
                rightEye.position.set(0.12, 1.55, 0.25);
                group.add(rightEye);
                
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.3), new THREE.MeshLambertMaterial({color: shirt}));
                body.position.y = 0.95;
                group.add(body);
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({color: pants});
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), legMat);
                leftLeg.position.set(-0.12, 0.4, 0);
                leftLeg.name = 'leftLeg';
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), legMat);
                rightLeg.position.set(0.12, 0.4, 0);
                rightLeg.name = 'rightLeg';
                group.add(rightLeg);
                
                // Arms
                const armMat = new THREE.MeshLambertMaterial({color: skin});
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), armMat);
                leftArm.position.set(-0.35, 0.95, 0);
                leftArm.name = 'leftArm';
                group.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), armMat);
                rightArm.position.set(0.35, 0.95, 0);
                rightArm.name = 'rightArm';
                group.add(rightArm);
                
            } else if (type === 'sheep') {
                // Fluffy body
                const wool = new THREE.MeshLambertMaterial({color: 0xF5F5F5});
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), wool);
                body.position.y = 0.6;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.4), new THREE.MeshLambertMaterial({color: 0x333333}));
                head.position.set(0, 0.7, 0.7);
                group.add(head);
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({color: 0x333333});
                [[-0.25, 0.2, -0.35], [0.25, 0.2, -0.35], [-0.25, 0.2, 0.35], [0.25, 0.2, 0.35]].forEach((pos, i) => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), legMat);
                    leg.position.set(...pos);
                    leg.name = 'leg' + i;
                    group.add(leg);
                });
                
            } else if (type === 'pig') {
                const pink = new THREE.MeshLambertMaterial({color: 0xFFB6C1});
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.9), pink);
                body.position.y = 0.45;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.4, 0.4), pink);
                head.position.set(0, 0.5, 0.55);
                group.add(head);
                
                // Snout
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.1), new THREE.MeshLambertMaterial({color: 0xFF9999}));
                snout.position.set(0, 0.45, 0.8);
                group.add(snout);
                
                // Legs
                [[-0.2, 0.15, -0.25], [0.2, 0.15, -0.25], [-0.2, 0.15, 0.25], [0.2, 0.15, 0.25]].forEach((pos, i) => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.3, 0.12), pink);
                    leg.position.set(...pos);
                    leg.name = 'leg' + i;
                    group.add(leg);
                });
                
            } else if (type === 'mario') {
                // It's-a me, Mario! Voxel style
                const red = new THREE.MeshLambertMaterial({color: 0xFF0000});
                const blue = new THREE.MeshLambertMaterial({color: 0x0000FF});
                const skin = new THREE.MeshLambertMaterial({color: 0xFFDBB4});
                const brown = new THREE.MeshLambertMaterial({color: 0x8B4513});
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skin);
                head.position.y = 1.5;
                group.add(head);
                
                // Mario's iconic cap
                const capMain = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.15, 0.55), red);
                capMain.position.y = 1.8;
                group.add(capMain);
                const capBrim = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.2), red);
                capBrim.position.set(0, 1.72, 0.35);
                group.add(capBrim);
                
                // M emblem on cap
                const mLogo = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.12, 0.02), new THREE.MeshBasicMaterial({color: 0xFFFFFF}));
                mLogo.position.set(0, 1.78, 0.29);
                group.add(mLogo);
                
                // Mustache
                const mustache = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.1), brown);
                mustache.position.set(0, 1.35, 0.25);
                group.add(mustache);
                
                // Eyes
                const eyeMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
                leftEye.position.set(-0.12, 1.55, 0.25);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
                rightEye.position.set(0.12, 1.55, 0.25);
                group.add(rightEye);
                
                // Body (red shirt)
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.3), red);
                body.position.y = 1.0;
                group.add(body);
                
                // Blue overalls
                const overalls = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.35, 0.32), blue);
                overalls.position.y = 0.75;
                group.add(overalls);
                
                // Yellow buttons on overalls
                const buttonMat = new THREE.MeshBasicMaterial({color: 0xFFD700});
                const leftButton = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), buttonMat);
                leftButton.position.set(-0.15, 0.85, 0.18);
                group.add(leftButton);
                const rightButton = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), buttonMat);
                rightButton.position.set(0.15, 0.85, 0.18);
                group.add(rightButton);
                
                // Legs (blue)
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), blue);
                leftLeg.position.set(-0.12, 0.35, 0);
                leftLeg.name = 'leftLeg';
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), blue);
                rightLeg.position.set(0.12, 0.35, 0);
                rightLeg.name = 'rightLeg';
                group.add(rightLeg);
                
                // Brown shoes
                const leftShoe = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.12, 0.35), brown);
                leftShoe.position.set(-0.12, 0.1, 0.05);
                group.add(leftShoe);
                const rightShoe = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.12, 0.35), brown);
                rightShoe.position.set(0.12, 0.1, 0.05);
                group.add(rightShoe);
                
                // Arms (red sleeves with skin hands)
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), red);
                leftArm.position.set(-0.35, 1.0, 0);
                leftArm.name = 'leftArm';
                group.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), red);
                rightArm.position.set(0.35, 1.0, 0);
                rightArm.name = 'rightArm';
                group.add(rightArm);
                
                // Gloves (white)
                const gloveMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
                const leftGlove = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.15, 0.18), gloveMat);
                leftGlove.position.set(-0.35, 0.72, 0);
                group.add(leftGlove);
                const rightGlove = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.15, 0.18), gloveMat);
                rightGlove.position.set(0.35, 0.72, 0);
                group.add(rightGlove);
                
            } else if (type === 'wizard') {
                // Mysterious robed figure
                const robeColor = new THREE.MeshLambertMaterial({color: 0x4B0082});
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.4), robeColor);
                body.position.y = 0.7;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshLambertMaterial({color: 0xFFDBB4}));
                head.position.y = 1.4;
                group.add(head);
                
                // Wizard hat
                const hatBase = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.6), robeColor);
                hatBase.position.y = 1.65;
                group.add(hatBase);
                const hatTop = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), robeColor);
                hatTop.position.y = 1.9;
                group.add(hatTop);
                const hatTip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), robeColor);
                hatTip.position.y = 2.3;
                group.add(hatTip);
                
                // Glowing staff
                const staff = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1.5, 0.08), new THREE.MeshLambertMaterial({color: 0x8B4513}));
                staff.position.set(0.4, 0.9, 0);
                group.add(staff);
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), new THREE.MeshBasicMaterial({color: 0x00FFFF}));
                orb.position.set(0.4, 1.7, 0);
                orb.name = 'orb';
                group.add(orb);
                
                // Beard
                const beard = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.35, 0.15), new THREE.MeshLambertMaterial({color: 0xCCCCCC}));
                beard.position.set(0, 1.15, 0.22);
                group.add(beard);
            }
            
            group.position.set(x, terrainY, z);
            group.userData = {
                type: type,
                targetX: x,
                targetZ: z,
                wanderTimer: Math.random() * 100,
                walkPhase: Math.random() * Math.PI * 2,
                isPartying: false,
                partyTimer: Math.random() * 20,
                dancePhase: Math.random() * Math.PI * 2
            };
            
            characterGroup.add(group);
            characters.push(group);
            return group;
        }

        // Spawn characters around the world
        for (let i = 0; i < 8; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('villager', x, z);
        }
        for (let i = 0; i < 6; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('sheep', x, z);
        }
        for (let i = 0; i < 5; i++) {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            createVoxelCharacter('pig', x, z);
        }
        // One mysterious wizard
        createVoxelCharacter('wizard', 10, 10);
        
        // === CINEMA SCREEN ===
        const cinemaGroup = new THREE.Group();
        const screenX = -15, screenZ = -20;
        const screenTerrainY = Math.floor(noise(screenX, screenZ)) + 6;
        
        // Screen frame (dark blocks)
        const frameMat = new THREE.MeshLambertMaterial({color: 0x1a1a1a});
        for (let fx = -4; fx <= 4; fx++) {
            for (let fy = 0; fy <= 6; fy++) {
                if (fx === -4 || fx === 4 || fy === 0 || fy === 6) {
                    const frameBlock = new THREE.Mesh(blockGeometry, frameMat);
                    frameBlock.position.set(screenX + fx, screenTerrainY + fy, screenZ);
                    scene.add(frameBlock);
                    blocks.push(frameBlock);
                }
            }
        }
        
        // Movie screen (emissive white surface)
        const screenGeo = new THREE.PlaneGeometry(7, 5);
        const screenCanvas = document.createElement('canvas');
        screenCanvas.width = 320;
        screenCanvas.height = 180;
        const screenCtx = screenCanvas.getContext('2d');
        const screenTexture = new THREE.CanvasTexture(screenCanvas);
        screenTexture.minFilter = THREE.NearestFilter;
        screenTexture.magFilter = THREE.NearestFilter;
        const screenMat = new THREE.MeshBasicMaterial({map: screenTexture});
        const screenMesh = new THREE.Mesh(screenGeo, screenMat);
        screenMesh.position.set(screenX, screenTerrainY + 3.5, screenZ + 0.1);
        scene.add(screenMesh);
        
        // Cinema seats (stone blocks)
        for (let row = 0; row < 3; row++) {
            for (let seat = -3; seat <= 3; seat++) {
                const seatBlock = new THREE.Mesh(blockGeometry, materials.stone);
                seatBlock.position.set(screenX + seat, screenTerrainY, screenZ + 5 + row * 2);
                seatBlock.scale.y = 0.5;
                scene.add(seatBlock);
            }
        }
        
        // Movie animation state
        let movieFrame = 0;
        let moviePlaying = true; // Auto-play for viewers
        let nearScreen = false;
        let fullscreenMode = false;
        
        // Pixel art drawing helpers
        function drawPixelMario(ctx, x, y, scale = 1) {
            ctx.fillStyle = '#FF0000'; // Red cap
            ctx.fillRect(x + 3*scale, y, 5*scale, scale);
            ctx.fillRect(x + 2*scale, y + scale, 8*scale, scale);
            ctx.fillStyle = '#FFDBAC'; // Skin
            ctx.fillRect(x + 2*scale, y + 2*scale, 3*scale, scale);
            ctx.fillRect(x + scale, y + 3*scale, 3*scale, scale);
            ctx.fillStyle = '#8B4513'; // Hair/mustache
            ctx.fillRect(x + 5*scale, y + 2*scale, 3*scale, scale);
            ctx.fillRect(x + 2*scale, y + 4*scale, 6*scale, scale);
            ctx.fillStyle = '#FF0000'; // Body
            ctx.fillRect(x + 2*scale, y + 5*scale, 6*scale, 2*scale);
            ctx.fillStyle = '#0000FF'; // Overalls
            ctx.fillRect(x + 2*scale, y + 7*scale, 2*scale, 3*scale);
            ctx.fillRect(x + 6*scale, y + 7*scale, 2*scale, 3*scale);
        }
        
        function drawPixelPeach(ctx, x, y, scale = 1) {
            ctx.fillStyle = '#FFD700'; // Crown
            ctx.fillRect(x + 2*scale, y, 4*scale, 2*scale);
            ctx.fillStyle = '#FFB6C1'; // Hair
            ctx.fillRect(x + scale, y + 2*scale, 6*scale, 3*scale);
            ctx.fillStyle = '#FFDBAC'; // Face
            ctx.fillRect(x + 2*scale, y + 3*scale, 4*scale, 2*scale);
            ctx.fillStyle = '#FF69B4'; // Dress
            ctx.fillRect(x + scale, y + 5*scale, 6*scale, 5*scale);
        }
        
        function drawPixelBowser(ctx, x, y, scale = 1) {
            ctx.fillStyle = '#228B22'; // Green body
            ctx.fillRect(x + 2*scale, y + 2*scale, 8*scale, 6*scale);
            ctx.fillStyle = '#FFD700'; // Yellow belly
            ctx.fillRect(x + 4*scale, y + 4*scale, 4*scale, 3*scale);
            ctx.fillStyle = '#8B0000'; // Red hair
            ctx.fillRect(x + 3*scale, y, 6*scale, 3*scale);
            ctx.fillStyle = '#FFFFFF'; // Horns
            ctx.fillRect(x + 2*scale, y, 2*scale, 2*scale);
            ctx.fillRect(x + 8*scale, y, 2*scale, 2*scale);
            ctx.fillStyle = '#8B4513'; // Shell
            ctx.fillRect(x + scale, y + 3*scale, 2*scale, 4*scale);
            ctx.fillRect(x + 9*scale, y + 3*scale, 2*scale, 4*scale);
        }
        
        function drawMovieFrame(ctx, frame) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const scene = Math.floor(frame / 120) % 5;
            
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            if (scene === 0) {
                // Scene 1: Castle, Peach captured
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(0, 0, w, h * 0.6);
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, h * 0.6, w, h * 0.4);
                // Castle
                ctx.fillStyle = '#808080';
                ctx.fillRect(w * 0.6, h * 0.2, w * 0.3, h * 0.5);
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(w * 0.65, h * 0.1, w * 0.08, h * 0.15);
                ctx.fillRect(w * 0.77, h * 0.1, w * 0.08, h * 0.15);
                // Bowser with Peach
                drawPixelBowser(ctx, w * 0.65, h * 0.35, 3);
                drawPixelPeach(ctx, w * 0.72, h * 0.38, 2);
                // Text
                ctx.fillStyle = '#FFF';
                ctx.font = '16px Courier New';
                ctx.fillText('BOWSER CAPTURES PRINCESS PEACH!', 20, 30);
            } else if (scene === 1) {
                // Scene 2: Mario sets off
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, w, h * 0.7);
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, h * 0.7, w, h * 0.3);
                // Pipes
                ctx.fillStyle = '#00AA00';
                ctx.fillRect(50, h * 0.55, 40, h * 0.2);
                ctx.fillRect(200, h * 0.5, 40, h * 0.25);
                // Mario running (animated)
                const marioX = 30 + (frame % 120) * 2;
                drawPixelMario(ctx, marioX, h * 0.55, 3);
                ctx.fillStyle = '#FFF';
                ctx.font = '16px Courier New';
                ctx.fillText('MARIO BEGINS HIS JOURNEY!', 20, 30);
            } else if (scene === 2) {
                // Scene 3: Battle with enemies
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(0, h * 0.7, w, h * 0.3);
                // Lava
                ctx.fillStyle = '#FF4500';
                for (let i = 0; i < 10; i++) {
                    ctx.fillRect(i * 35, h * 0.75 + Math.sin(frame * 0.1 + i) * 5, 30, 20);
                }
                // Mario jumping
                const jumpY = h * 0.4 + Math.sin(frame * 0.1) * 30;
                drawPixelMario(ctx, w * 0.3, jumpY, 3);
                // Fireballs
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(w * 0.5 + Math.sin(frame * 0.05) * 50, h * 0.5, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = '16px Courier New';
                ctx.fillText('DANGEROUS OBSTACLES AHEAD!', 20, 30);
            } else if (scene === 3) {
                // Scene 4: Final battle
                ctx.fillStyle = '#2d132c';
                ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#4a1942';
                ctx.fillRect(0, h * 0.65, w, h * 0.35);
                // Bowser
                drawPixelBowser(ctx, w * 0.6, h * 0.4, 4);
                // Mario attacking
                const attackX = w * 0.2 + (frame % 60) * 2;
                drawPixelMario(ctx, attackX, h * 0.45, 3);
                // Fire effects
                ctx.fillStyle = '#FF6600';
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(w * 0.4 + Math.random() * 100, h * 0.3 + Math.random() * 50, 8, 8);
                }
                // Stars (damage)
                ctx.fillStyle = '#FFD700';
                ctx.font = '20px Arial';
                ctx.fillText('‚òÖ', w * 0.7 + Math.sin(frame * 0.2) * 20, h * 0.35);
                ctx.fillStyle = '#FFF';
                ctx.font = '16px Courier New';
                ctx.fillText('EPIC BATTLE WITH BOWSER!', 20, 30);
            } else {
                // Scene 5: Victory!
                ctx.fillStyle = '#FFB6C1';
                ctx.fillRect(0, 0, w, h);
                // Hearts
                ctx.fillStyle = '#FF0000';
                for (let i = 0; i < 8; i++) {
                    const hx = (i * 45 + frame) % (w + 50) - 25;
                    const hy = h * 0.2 + Math.sin(frame * 0.05 + i) * 20;
                    ctx.font = '24px Arial';
                    ctx.fillText('‚ù§', hx, hy);
                }
                // Mario and Peach together
                drawPixelMario(ctx, w * 0.35, h * 0.45, 3);
                drawPixelPeach(ctx, w * 0.5, h * 0.43, 3);
                // Confetti
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 20; i++) {
                    ctx.fillRect(
                        (i * 20 + frame * 2) % w,
                        (frame + i * 30) % h,
                        4, 4
                    );
                }
                ctx.fillStyle = '#000';
                ctx.font = 'bold 20px Courier New';
                ctx.fillText('MARIO SAVES PEACH! THE END!', 30, 30);
                ctx.font = '14px Courier New';
                ctx.fillText('‚ô™ And they lived happily ever after ‚ô™', 50, h - 20);
            }
        }
        
        // Update movie screen
        function updateMovieScreen() {
            if (moviePlaying) {
                movieFrame++;
                drawMovieFrame(screenCtx, movieFrame);
                screenTexture.needsUpdate = true;
                
                // Also update fullscreen canvas if open
                if (fullscreenMode) {
                    const cinemaCtx = document.getElementById('cinema-canvas').getContext('2d');
                    cinemaCtx.imageSmoothingEnabled = false;
                    drawMovieFrame(cinemaCtx, movieFrame);
                }
            }
        }
        
        // Check proximity to screen
        function checkScreenProximity() {
            const dx = player.x - screenX;
            const dz = player.z - (screenZ + 6);
            const dist = Math.sqrt(dx*dx + dz*dz);
            nearScreen = dist < 8;
            document.getElementById('screen-prompt').style.display = nearScreen && !fullscreenMode ? 'block' : 'none';
        }
        
        // F key to watch movie fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyF' && nearScreen && !fullscreenMode) {
                fullscreenMode = true;
                document.getElementById('cinema-overlay').style.display = 'flex';
                movieFrame = 0; // Restart movie
            }
            if (e.code === 'Escape' && fullscreenMode) {
                fullscreenMode = false;
                document.getElementById('cinema-overlay').style.display = 'none';
            }
        });
        
        document.getElementById('cinema-close').addEventListener('click', () => {
            fullscreenMode = false;
            document.getElementById('cinema-overlay').style.display = 'none';
        });
        
        // It's-a Mario!
        createVoxelCharacter('mario', -5, 8);

        function updateCharacters(time) {
            characters.forEach(char => {
                const data = char.userData;
                data.wanderTimer -= 0.016;
                data.partyTimer -= 0.016;
                
                // Check if should go to party
                if (data.partyTimer <= 0 && (data.type === 'villager' || data.type === 'mario')) {
                    data.isPartying = !data.isPartying;
                    data.partyTimer = 10 + Math.random() * 15;
                }
                
                // Pick new target when timer runs out
                if (data.wanderTimer <= 0) {
                    if (data.isPartying && partyZone) {
                        // Go to party zone!
                        data.targetX = partyZone.x + (Math.random() - 0.5) * 5;
                        data.targetZ = partyZone.z + (Math.random() - 0.5) * 5;
                    } else {
                        data.targetX = char.position.x + (Math.random() - 0.5) * 10;
                        data.targetZ = char.position.z + (Math.random() - 0.5) * 10;
                    }
                    data.targetX = Math.max(-35, Math.min(35, data.targetX));
                    data.targetZ = Math.max(-35, Math.min(35, data.targetZ));
                    data.wanderTimer = 3 + Math.random() * 5;
                }
                
                // Move towards target
                const dx = data.targetX - char.position.x;
                const dz = data.targetZ - char.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                
                if (dist > 0.5) {
                    const speed = data.type === 'wizard' ? 0.02 : (data.type === 'mario' ? 0.05 : 0.03);
                    char.position.x += (dx / dist) * speed;
                    char.position.z += (dz / dist) * speed;
                    char.rotation.y = Math.atan2(dx, dz);
                    
                    // Update Y position based on terrain
                    const terrainY = Math.floor(noise(char.position.x, char.position.z)) + 6;
                    char.position.y = terrainY + (data.type === 'wizard' ? Math.sin(time * 2) * 0.3 : 0);
                    
                    // Animate legs/arms
                    data.walkPhase += 0.15;
                    char.children.forEach(part => {
                        if (part.name === 'leftLeg' || part.name === 'leg0' || part.name === 'leg2') {
                            part.rotation.x = Math.sin(data.walkPhase) * 0.5;
                        }
                        if (part.name === 'rightLeg' || part.name === 'leg1' || part.name === 'leg3') {
                            part.rotation.x = Math.sin(data.walkPhase + Math.PI) * 0.5;
                        }
                        if (part.name === 'leftArm') {
                            part.rotation.x = Math.sin(data.walkPhase + Math.PI) * 0.4;
                        }
                        if (part.name === 'rightArm') {
                            part.rotation.x = Math.sin(data.walkPhase) * 0.4;
                        }
                        // Wizard orb glow
                        if (part.name === 'orb') {
                            part.material.color.setHSL((time * 0.1) % 1, 1, 0.6);
                        }
                    });
                } else if (data.isPartying && partyZone) {
                    // DANCE PARTY ANIMATIONS!
                    const px = partyZone.x;
                    const pz = partyZone.z;
                    const distToParty = Math.sqrt(Math.pow(char.position.x - px, 2) + Math.pow(char.position.z - pz, 2));
                    
                    if (distToParty < 6) {
                        data.dancePhase += 0.2;
                        
                        // Bouncing up and down
                        const terrainY = Math.floor(noise(char.position.x, char.position.z)) + 6;
                        char.position.y = terrainY + Math.abs(Math.sin(data.dancePhase)) * 0.5;
                        
                        // Spinning occasionally
                        char.rotation.y += Math.sin(data.dancePhase * 0.3) * 0.1;
                        
                        // Arm waving
                        char.children.forEach(part => {
                            if (part.name === 'leftArm') {
                                part.rotation.x = Math.sin(data.dancePhase * 2) * 1.2;
                                part.rotation.z = Math.sin(data.dancePhase) * 0.5 - 0.5;
                            }
                            if (part.name === 'rightArm') {
                                part.rotation.x = Math.sin(data.dancePhase * 2 + Math.PI) * 1.2;
                                part.rotation.z = -Math.sin(data.dancePhase) * 0.5 + 0.5;
                            }
                            if (part.name === 'leftLeg' || part.name === 'leg0' || part.name === 'leg2') {
                                part.rotation.x = Math.sin(data.dancePhase * 3) * 0.4;
                            }
                            if (part.name === 'rightLeg' || part.name === 'leg1' || part.name === 'leg3') {
                                part.rotation.x = Math.sin(data.dancePhase * 3 + Math.PI) * 0.4;
                            }
                        });
                    }
                }
            });
        }

        // Raycaster for block selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Center of screen
        let selectedBlock = null;
        let selectedBlockType = 'grass';
        
        // Selection highlight
        const highlightGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const highlightMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.3,
            side: THREE.BackSide
        });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
        highlightMesh.visible = false;
        scene.add(highlightMesh);
        
        // Inventory slot selection
        document.querySelectorAll('.inv-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('selected'));
                slot.classList.add('selected');
                selectedBlockType = slot.dataset.block;
                showActionHint('Selected: ' + selectedBlockType.toUpperCase());
            });
        });
        
        function showActionHint(text) {
            const hint = document.getElementById('action-hint');
            hint.textContent = text;
            hint.style.opacity = '1';
            setTimeout(() => hint.style.opacity = '0', 1000);
        }
        
        // Mining (click to remove)
        renderer.domElement.addEventListener('click', (e) => {
            if (selectedBlock && blocks.includes(selectedBlock)) {
                scene.remove(selectedBlock);
                blocks.splice(blocks.indexOf(selectedBlock), 1);
                blockCount--;
                document.getElementById('block-count').textContent = blockCount;
                showActionHint('‚õèÔ∏è MINED!');
                highlightMesh.visible = false;
                selectedBlock = null;
            }
        });
        
        // Place block (M key)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM' && selectedBlock) {
                // Get the face normal to place block adjacent
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(blocks);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const normal = intersect.face.normal;
                    const newPos = new THREE.Vector3(
                        Math.round(intersect.object.position.x + normal.x),
                        Math.round(intersect.object.position.y + normal.y),
                        Math.round(intersect.object.position.z + normal.z)
                    );
                    createBlock(newPos.x, newPos.y, newPos.z, materials[selectedBlockType]);
                    document.getElementById('block-count').textContent = blockCount;
                    showActionHint('üß± PLACED!');
                }
            }
        });
        
        function updateBlockSelection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0 && intersects[0].distance < 10) {
                selectedBlock = intersects[0].object;
                highlightMesh.position.copy(selectedBlock.position);
                highlightMesh.visible = true;
            } else {
                selectedBlock = null;
                highlightMesh.visible = false;
            }
        }

        // Player setup - Calculate ground height at spawn
        const spawnHeight = Math.floor(noise(0, 0)) + 5 + 2; // +2 for player eye level above surface
        const player = {
            x: 0,
            y: spawnHeight,
            z: 0,
            yaw: 0,
            pitch: 0,
            velocityY: 0,
            speed: 0.15,
            jumpForce: 0.3,
            // Smooth camera targets
            targetX: 0,
            targetY: spawnHeight,
            targetZ: 0,
            targetYaw: 0,
            targetPitch: 0
        };
        
        // Collision detection helper
        function getTerrainHeight(x, z) {
            const baseHeight = Math.floor(noise(x, z)) + 6;
            // Check for buildings/structures at this position
            let maxHeight = baseHeight;
            blocks.forEach(block => {
                const bx = block.position.x;
                const bz = block.position.z;
                const by = block.position.y;
                if (Math.abs(x - bx) < 1 && Math.abs(z - bz) < 1) {
                    maxHeight = Math.max(maxHeight, by + 1);
                }
            });
            return maxHeight;
        }
        
        function checkCollision(x, y, z) {
            const minHeight = getTerrainHeight(x, z) + 1.5; // Player eye level above ground
            return Math.max(y, minHeight);
        }

        camera.position.set(player.x, player.y, player.z);

        // Controls
        const keys = {};
        let autoMode = true;
        let autoTime = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'ShiftLeft'].includes(e.code)) {
                autoMode = false;
                document.getElementById('mode-indicator').textContent = 'üéÆ PLAYER CONTROL';
                document.getElementById('mode-indicator').style.color = '#00ff00';
                document.getElementById('mode-indicator').style.borderColor = '#00ff00';
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Re-enable auto mode after inactivity
        let inactivityTimer;
        document.addEventListener('keydown', () => {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                autoMode = true;
                document.getElementById('mode-indicator').textContent = 'ü§ñ AUTO-EXPLORE MODE';
                document.getElementById('mode-indicator').style.color = '#ffcc00';
                document.getElementById('mode-indicator').style.borderColor = '#ffcc00';
            }, 10000);
        });

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (autoMode) {
                // Auto-explore: smooth cinematic camera movement
                autoTime += 0.003; // Slower for smoother movement
                
                // Figure-8 path visiting the castle
                const pathScale = 35;
                const castleVisit = Math.sin(autoTime * 0.3) > 0.5;
                if (castleVisit) {
                    // Orbit around the castle
                    player.targetX = 30 + Math.sin(autoTime * 2) * 20;
                    player.targetZ = -10 + Math.cos(autoTime * 2) * 20;
                } else {
                    player.targetX = Math.sin(autoTime) * pathScale * Math.cos(autoTime * 0.5);
                    player.targetZ = Math.cos(autoTime) * pathScale;
                }
                
                // Calculate terrain height and stay above it
                const terrainY = getTerrainHeight(player.targetX, player.targetZ);
                player.targetY = terrainY + 4 + Math.sin(autoTime * 1.5) * 1.5;
                
                // Smooth look direction (look slightly ahead)
                const lookAheadTime = autoTime + 0.1;
                const lookX = Math.sin(lookAheadTime) * pathScale * Math.cos(lookAheadTime * 0.5);
                const lookZ = Math.cos(lookAheadTime) * pathScale;
                player.targetYaw = Math.atan2(lookX - player.targetX, lookZ - player.targetZ) + Math.PI;
                player.targetPitch = -0.15 + Math.sin(autoTime * 2) * 0.08;
                
                // Smooth interpolation (lerp)
                const smoothFactor = 0.02;
                player.x += (player.targetX - player.x) * smoothFactor;
                player.y += (player.targetY - player.y) * smoothFactor;
                player.z += (player.targetZ - player.z) * smoothFactor;
                
                // Smooth yaw interpolation (handle wrap-around)
                let yawDiff = player.targetYaw - player.yaw;
                while (yawDiff > Math.PI) yawDiff -= Math.PI * 2;
                while (yawDiff < -Math.PI) yawDiff += Math.PI * 2;
                player.yaw += yawDiff * smoothFactor * 2;
                player.pitch += (player.targetPitch - player.pitch) * smoothFactor * 2;
            } else {
                // Player control
                const moveX = Math.sin(player.yaw) * player.speed;
                const moveZ = Math.cos(player.yaw) * player.speed;

                if (keys['ArrowUp']) {
                    player.x -= moveX;
                    player.z -= moveZ;
                }
                if (keys['ArrowDown']) {
                    player.x += moveX;
                    player.z += moveZ;
                }
                if (keys['ArrowLeft']) {
                    player.yaw += 0.03;
                }
                if (keys['ArrowRight']) {
                    player.yaw -= 0.03;
                }
                if (keys['Space']) {
                    player.y += player.speed;
                }
                if (keys['ShiftLeft']) {
                    player.y -= player.speed;
                }
                
                // Apply collision - prevent going inside blocks
                player.y = checkCollision(player.x, player.y, player.z);
            }

            // Update camera
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            // Update block selection
            updateBlockSelection();
            
            // Update characters
            updateCharacters(autoTime);

            // Update HUD
            document.getElementById('pos').textContent = 
                `${Math.floor(player.x)}, ${Math.floor(player.y)}, ${Math.floor(player.z)}`;
            
            // Update movie screen
            updateMovieScreen();
            checkScreenProximity();
            
            // Update fountain animation
            updateFountain(autoTime * 10);
            
            // Update party zone
            updatePartyZone(autoTime * 10);
            
            // Rotate castle star
            const castleStar = scene.getObjectByName('castleStar');
            if (castleStar) {
                castleStar.rotation.y += 0.02;
                castleStar.rotation.x = Math.sin(autoTime * 5) * 0.2;
                castleStar.position.y = marioCastle.baseY + 23 + Math.sin(autoTime * 8) * 0.3;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>